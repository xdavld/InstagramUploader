{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"sink.js","sources":["file:///Users/david/src/5.%20Semester/SoftwareEngineering-Project/node_modules/.pnpm/effect%403.10.3/node_modules/effect/src/internal/sink.ts"],"sourcesContent":["import * as Arr from \"../Array.js\"\nimport * as Cause from \"../Cause.js\"\nimport type * as Channel from \"../Channel.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport type * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Exit from \"../Exit.js\"\nimport { constTrue, dual, identity, pipe } from \"../Function.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport type * as MergeDecision from \"../MergeDecision.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, type Predicate, type Refinement } from \"../Predicate.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Queue from \"../Queue.js\"\nimport * as Ref from \"../Ref.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Sink from \"../Sink.js\"\nimport * as channel from \"./channel.js\"\nimport * as mergeDecision from \"./channel/mergeDecision.js\"\nimport * as core from \"./core-stream.js\"\n\n/** @internal */\nexport const SinkTypeId: Sink.SinkTypeId = Symbol.for(\"effect/Sink\") as Sink.SinkTypeId\n\nconst sinkVariance = {\n  /* c8 ignore next */\n  _A: (_: never) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _L: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class SinkImpl<out A, in In = unknown, out L = never, out E = never, out R = never>\n  implements Sink.Sink<A, In, L, E, R>\n{\n  readonly [SinkTypeId] = sinkVariance\n  constructor(\n    readonly channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>\n  ) {\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isSink = (u: unknown): u is Sink.Sink<unknown, unknown, unknown, unknown, unknown> =>\n  hasProperty(u, SinkTypeId)\n\n/** @internal */\nexport const suspend = <A, In, L, E, R>(evaluate: LazyArg<Sink.Sink<A, In, L, E, R>>): Sink.Sink<A, In, L, E, R> =>\n  new SinkImpl(core.suspend(() => toChannel(evaluate())))\n\n/** @internal */\nexport const as = dual<\n  <A2>(a: A2) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E, R>,\n  <A, In, L, E, R, A2>(self: Sink.Sink<A, In, L, E, R>, a: A2) => Sink.Sink<A2, In, L, E, R>\n>(\n  2,\n  (self, a) => pipe(self, map(() => a))\n)\n\n/** @internal */\nexport const collectAll = <In>(): Sink.Sink<Chunk.Chunk<In>, In> => new SinkImpl(collectAllLoop(Chunk.empty()))\n\n/** @internal */\nconst collectAllLoop = <In>(\n  acc: Chunk.Chunk<In>\n): Channel.Channel<never, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<In>) => collectAllLoop(pipe(acc, Chunk.appendAll(chunk))),\n    onFailure: core.failCause,\n    onDone: () => core.succeed(acc)\n  })\n\n/** @internal */\nexport const collectAllN = <In>(n: number): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  suspend(() => fromChannel(collectAllNLoop(n, Chunk.empty())))\n\n/** @internal */\nconst collectAllNLoop = <In>(\n  n: number,\n  acc: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<In>) => {\n      const [collected, leftovers] = Chunk.splitAt(chunk, n)\n      if (collected.length < n) {\n        return collectAllNLoop(n - collected.length, Chunk.appendAll(acc, collected))\n      }\n      if (Chunk.isEmpty(leftovers)) {\n        return core.succeed(Chunk.appendAll(acc, collected))\n      }\n      return core.flatMap(core.write(leftovers), () => core.succeed(Chunk.appendAll(acc, collected)))\n    },\n    onFailure: core.failCause,\n    onDone: () => core.succeed(acc)\n  })\n\n/** @internal */\nexport const collectAllFrom = <A, In, L extends In, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<Chunk.Chunk<A>, In, L, E, R> =>\n  collectAllWhileWith(self, {\n    initial: Chunk.empty<A>(),\n    while: constTrue,\n    body: (chunk, a) => pipe(chunk, Chunk.append(a))\n  })\n\n/** @internal */\nexport const collectAllToMap = <In, K>(\n  key: (input: In) => K,\n  merge: (x: In, y: In) => In\n): Sink.Sink<HashMap.HashMap<K, In>, In> => {\n  return pipe(\n    foldLeftChunks(HashMap.empty<K, In>(), (map, chunk) =>\n      pipe(\n        chunk,\n        Chunk.reduce(map, (map, input) => {\n          const k: K = key(input)\n          const v: In = pipe(map, HashMap.has(k)) ?\n            merge(pipe(map, HashMap.unsafeGet(k)), input) :\n            input\n          return pipe(map, HashMap.set(k, v))\n        })\n      ))\n  )\n}\n\n/** @internal */\nexport const collectAllToMapN = <In, K>(\n  n: number,\n  key: (input: In) => K,\n  merge: (x: In, y: In) => In\n): Sink.Sink<HashMap.HashMap<K, In>, In, In> => {\n  return foldWeighted<HashMap.HashMap<K, In>, In>({\n    initial: HashMap.empty(),\n    maxCost: n,\n    cost: (acc, input) => pipe(acc, HashMap.has(key(input))) ? 0 : 1,\n    body: (acc, input) => {\n      const k: K = key(input)\n      const v: In = pipe(acc, HashMap.has(k)) ?\n        merge(pipe(acc, HashMap.unsafeGet(k)), input) :\n        input\n      return pipe(acc, HashMap.set(k, v))\n    }\n  })\n}\n\n/** @internal */\nexport const collectAllToSet = <In>(): Sink.Sink<HashSet.HashSet<In>, In> =>\n  foldLeftChunks<HashSet.HashSet<In>, In>(\n    HashSet.empty(),\n    (acc, chunk) => pipe(chunk, Chunk.reduce(acc, (acc, input) => pipe(acc, HashSet.add(input))))\n  )\n\n/** @internal */\nexport const collectAllToSetN = <In>(n: number): Sink.Sink<HashSet.HashSet<In>, In, In> =>\n  foldWeighted<HashSet.HashSet<In>, In>({\n    initial: HashSet.empty(),\n    maxCost: n,\n    cost: (acc, input) => HashSet.has(acc, input) ? 0 : 1,\n    body: (acc, input) => HashSet.add(acc, input)\n  })\n\n/** @internal */\nexport const collectAllUntil = <In>(p: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In> => {\n  return pipe(\n    fold<[Chunk.Chunk<In>, boolean], In>(\n      [Chunk.empty(), true],\n      (tuple) => tuple[1],\n      ([chunk, _], input) => [pipe(chunk, Chunk.append(input)), !p(input)]\n    ),\n    map((tuple) => tuple[0])\n  )\n}\n\n/** @internal */\nexport const collectAllUntilEffect = <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => {\n  return pipe(\n    foldEffect<[Chunk.Chunk<In>, boolean], In, E, R>(\n      [Chunk.empty(), true],\n      (tuple) => tuple[1],\n      ([chunk, _], input) => pipe(p(input), Effect.map((bool) => [pipe(chunk, Chunk.append(input)), !bool]))\n    ),\n    map((tuple) => tuple[0])\n  )\n}\n\n/** @internal */\nexport const collectAllWhile: {\n  <In, Out extends In>(refinement: Refinement<In, Out>): Sink.Sink<Chunk.Chunk<Out>, In, In>\n  <In>(predicate: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In>\n} = <In>(predicate: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  fromChannel(collectAllWhileReader(predicate, Chunk.empty()))\n\n/** @internal */\nconst collectAllWhileReader = <In>(\n  predicate: Predicate<In>,\n  done: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [collected, leftovers] = pipe(Chunk.toReadonlyArray(input), Arr.span(predicate))\n      if (leftovers.length === 0) {\n        return collectAllWhileReader(\n          predicate,\n          pipe(done, Chunk.appendAll(Chunk.unsafeFromArray(collected)))\n        )\n      }\n      return pipe(\n        core.write(Chunk.unsafeFromArray(leftovers)),\n        channel.zipRight(core.succeed(pipe(done, Chunk.appendAll(Chunk.unsafeFromArray(collected)))))\n      )\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeed(done)\n  })\n\n/** @internal */\nexport const collectAllWhileEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<Chunk.Chunk<In>, In, In, E, R> => fromChannel(collectAllWhileEffectReader(predicate, Chunk.empty()))\n\n/** @internal */\nconst collectAllWhileEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>,\n  done: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, never, Chunk.Chunk<In>, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(pipe(input, Effect.takeWhile(predicate), Effect.map(Chunk.unsafeFromArray))),\n        core.flatMap((collected) => {\n          const leftovers = pipe(input, Chunk.drop(collected.length))\n          if (Chunk.isEmpty(leftovers)) {\n            return collectAllWhileEffectReader(predicate, pipe(done, Chunk.appendAll(collected)))\n          }\n          return pipe(core.write(leftovers), channel.zipRight(core.succeed(pipe(done, Chunk.appendAll(collected)))))\n        })\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeed(done)\n  })\n\n/** @internal */\nexport const collectAllWhileWith: {\n  <A, S>(\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): <In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<S, In, L, E, R>\n  <A, In, L extends In, E, R, S>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): Sink.Sink<S, In, L, E, R>\n} = dual(\n  2,\n  <A, In, L extends In, E, R, S>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): Sink.Sink<S, In, L, E, R> => {\n    const refs = pipe(\n      Ref.make(Chunk.empty<In>()),\n      Effect.zip(Ref.make(false))\n    )\n    const newChannel = pipe(\n      core.fromEffect(refs),\n      core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n        const upstreamMarker: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> = core\n          .readWith({\n            onInput: (input) => pipe(core.write(input), core.flatMap(() => upstreamMarker)),\n            onFailure: core.fail,\n            onDone: (done) => pipe(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))\n          })\n        return pipe(\n          upstreamMarker,\n          core.pipeTo(channel.bufferChunk(leftoversRef)),\n          core.pipeTo(\n            collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)\n          )\n        )\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\nconst collectAllWhileWithLoop = <Z, In, L extends In, E, R, S>(\n  self: Sink.Sink<Z, In, L, E, R>,\n  leftoversRef: Ref.Ref<Chunk.Chunk<In>>,\n  upstreamDoneRef: Ref.Ref<boolean>,\n  currentResult: S,\n  p: Predicate<Z>,\n  f: (s: S, z: Z) => S\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, S, unknown, R> => {\n  return pipe(\n    toChannel(self),\n    channel.doneCollect,\n    channel.foldChannel({\n      onFailure: core.fail,\n      onSuccess: ([leftovers, doneValue]) =>\n        p(doneValue)\n          ? pipe(\n            core.fromEffect(\n              Ref.set(leftoversRef, Chunk.flatten(leftovers as Chunk.Chunk<Chunk.Chunk<In>>))\n            ),\n            core.flatMap(() =>\n              pipe(\n                core.fromEffect(Ref.get(upstreamDoneRef)),\n                core.flatMap((upstreamDone) => {\n                  const accumulatedResult = f(currentResult, doneValue)\n                  return upstreamDone\n                    ? pipe(core.write(Chunk.flatten(leftovers)), channel.as(accumulatedResult))\n                    : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f)\n                })\n              )\n            )\n          )\n          : pipe(core.write(Chunk.flatten(leftovers)), channel.as(currentResult))\n    })\n  )\n}\n\n/** @internal */\nexport const collectLeftover = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<[A, Chunk.Chunk<L>], In, never, E, R> =>\n  new SinkImpl(pipe(core.collectElements(toChannel(self)), channel.map(([chunks, z]) => [z, Chunk.flatten(chunks)])))\n\n/** @internal */\nexport const mapInput = dual<\n  <In0, In>(f: (input: In0) => In) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E, R>,\n  <A, In, L, E, R, In0>(self: Sink.Sink<A, In, L, E, R>, f: (input: In0) => In) => Sink.Sink<A, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0>(self: Sink.Sink<A, In, L, E, R>, f: (input: In0) => In): Sink.Sink<A, In0, L, E, R> =>\n    pipe(self, mapInputChunks(Chunk.map(f)))\n)\n\n/** @internal */\nexport const mapInputEffect = dual<\n  <In0, In, E2, R2>(\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ) => Sink.Sink<A, In0, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ): Sink.Sink<A, In0, L, E | E2, R | R2> =>\n    mapInputChunksEffect(\n      self,\n      (chunk) =>\n        Effect.map(\n          Effect.forEach(chunk, (v) => f(v)),\n          Chunk.unsafeFromArray\n        )\n    )\n)\n\n/** @internal */\nexport const mapInputChunks = dual<\n  <In0, In>(\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E, R>,\n  <A, In, L, E, R, In0>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ) => Sink.Sink<A, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ): Sink.Sink<A, In0, L, E, R> => {\n    const loop: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In0>, never, never, unknown, unknown, R> = core.readWith({\n      onInput: (chunk) => pipe(core.write(f(chunk)), core.flatMap(() => loop)),\n      onFailure: core.fail,\n      onDone: core.succeed\n    })\n    return new SinkImpl(pipe(loop, core.pipeTo(toChannel(self))))\n  }\n)\n\n/** @internal */\nexport const mapInputChunksEffect = dual<\n  <In0, In, E2, R2>(\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ) => Sink.Sink<A, In0, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ): Sink.Sink<A, In0, L, E | E2, R | R2> => {\n    const loop: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In0>, E2, never, unknown, unknown, R | R2> = core\n      .readWith({\n        onInput: (chunk) => pipe(core.fromEffect(f(chunk)), core.flatMap(core.write), core.flatMap(() => loop)),\n        onFailure: core.fail,\n        onDone: core.succeed\n      })\n    return new SinkImpl(pipe(loop, channel.pipeToOrFail(toChannel(self))))\n  }\n)\n\n/** @internal */\nexport const die = (defect: unknown): Sink.Sink<never, unknown> => failCause(Cause.die(defect))\n\n/** @internal */\nexport const dieMessage = (message: string): Sink.Sink<never, unknown> =>\n  failCause(Cause.die(new Cause.RuntimeException(message)))\n\n/** @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Sink.Sink<never, unknown> =>\n  failCauseSync(() => Cause.die(evaluate()))\n\n/** @internal */\nexport const dimap = dual<\n  <In0, In, A, A2>(\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E, R>,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ) => Sink.Sink<A2, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ): Sink.Sink<A2, In0, L, E, R> => map(mapInput(self, options.onInput), options.onDone)\n)\n\n/** @internal */\nexport const dimapEffect = dual<\n  <In0, In, E2, R2, A, A2, E3, R3>(\n    options: {\n      readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>,\n  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>\n>(\n  2,\n  (self, options) =>\n    mapEffect(\n      mapInputEffect(self, options.onInput),\n      options.onDone\n    )\n)\n\n/** @internal */\nexport const dimapChunks = dual<\n  <In0, In, A, A2>(\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n      readonly onDone: (a: A) => A2\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E, R>,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n      readonly onDone: (a: A) => A2\n    }\n  ) => Sink.Sink<A2, In0, L, E, R>\n>(\n  2,\n  (self, options) =>\n    map(\n      mapInputChunks(self, options.onInput),\n      options.onDone\n    )\n)\n\n/** @internal */\nexport const dimapChunksEffect = dual<\n  <In0, In, E2, R2, A, A2, E3, R3>(\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>,\n  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>\n>(\n  2,\n  (self, options) => mapEffect(mapInputChunksEffect(self, options.onInput), options.onDone)\n)\n\n/** @internal */\nexport const drain: Sink.Sink<void, unknown> = new SinkImpl(\n  channel.drain(channel.identityChannel())\n)\n\n/** @internal */\nexport const drop = <In>(n: number): Sink.Sink<unknown, In, In> => suspend(() => new SinkImpl(dropLoop(n)))\n\n/** @internal */\nconst dropLoop = <In>(\n  n: number\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const dropped = pipe(input, Chunk.drop(n))\n      const leftover = Math.max(n - input.length, 0)\n      const more = Chunk.isEmpty(input) || leftover > 0\n      if (more) {\n        return dropLoop(leftover)\n      }\n      return pipe(\n        core.write(dropped),\n        channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, never, unknown>())\n      )\n    },\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const dropUntil = <In>(predicate: Predicate<In>): Sink.Sink<unknown, In, In> =>\n  new SinkImpl(\n    pipe(toChannel(dropWhile((input: In) => !predicate(input))), channel.pipeToOrFail(toChannel(drop<In>(1))))\n  )\n\n/** @internal */\nexport const dropUntilEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<unknown, In, In, E, R> => suspend(() => new SinkImpl(dropUntilEffectReader(predicate)))\n\n/** @internal */\nconst dropUntilEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, unknown, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        input,\n        Effect.dropUntil(predicate),\n        Effect.map((leftover) => {\n          const more = leftover.length === 0\n          return more ?\n            dropUntilEffectReader(predicate) :\n            pipe(\n              core.write(Chunk.unsafeFromArray(leftover)),\n              channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, E, unknown>())\n            )\n        }),\n        channel.unwrap\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const dropWhile = <In>(predicate: Predicate<In>): Sink.Sink<unknown, In, In> =>\n  new SinkImpl(dropWhileReader(predicate))\n\n/** @internal */\nconst dropWhileReader = <In>(\n  predicate: Predicate<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const out = pipe(input, Chunk.dropWhile(predicate))\n      if (Chunk.isEmpty(out)) {\n        return dropWhileReader(predicate)\n      }\n      return pipe(core.write(out), channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, never, unknown>()))\n    },\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n\n/** @internal */\nexport const dropWhileEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<unknown, In, In, E, R> => suspend(() => new SinkImpl(dropWhileEffectReader(predicate)))\n\n/** @internal */\nconst dropWhileEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, unknown, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        input,\n        Effect.dropWhile(predicate),\n        Effect.map((leftover) => {\n          const more = leftover.length === 0\n          return more ?\n            dropWhileEffectReader(predicate) :\n            pipe(\n              core.write(Chunk.unsafeFromArray(leftover)),\n              channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, E, unknown>())\n            )\n        }),\n        channel.unwrap\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const ensuring = dual<\n  <X, R2>(\n    finalizer: Effect.Effect<X, never, R2>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E, R2 | R>,\n  <A, In, L, E, R, X, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    finalizer: Effect.Effect<X, never, R2>\n  ) => Sink.Sink<A, In, L, E, R2 | R>\n>(\n  2,\n  (self, finalizer) => new SinkImpl(pipe(self, toChannel, channel.ensuring(finalizer)))\n)\n\n/** @internal */\nexport const ensuringWith = dual<\n  <A, E, X, R2>(\n    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ) => <In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E, R2 | R>,\n  <A, In, L, E, R, X, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ) => Sink.Sink<A, In, L, E, R2 | R>\n>(\n  2,\n  (self, finalizer) => new SinkImpl(pipe(self, toChannel, core.ensuringWith(finalizer)))\n)\n\n/** @internal */\nexport const context = <R>(): Sink.Sink<Context.Context<R>, unknown, never, never, R> => fromEffect(Effect.context<R>())\n\n/** @internal */\nexport const contextWith = <R, Z>(\n  f: (context: Context.Context<R>) => Z\n): Sink.Sink<Z, unknown, never, never, R> => pipe(context<R>(), map(f))\n\n/** @internal */\nexport const contextWithEffect = <R0, A, E, R>(\n  f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>\n): Sink.Sink<A, unknown, never, E, R0 | R> => pipe(context<R0>(), mapEffect(f))\n\n/** @internal */\nexport const contextWithSink = <R0, A, In, L, E, R>(\n  f: (context: Context.Context<R0>) => Sink.Sink<A, In, L, E, R>\n): Sink.Sink<A, In, L, E, R0 | R> =>\n  new SinkImpl(channel.unwrap(pipe(Effect.contextWith((context) => toChannel(f(context))))))\n\n/** @internal */\nexport const every = <In>(predicate: Predicate<In>): Sink.Sink<boolean, In, In> =>\n  fold(true, identity, (acc, input) => acc && predicate(input))\n\n/** @internal */\nexport const fail = <E>(e: E): Sink.Sink<never, unknown, never, E> => new SinkImpl(core.fail(e))\n\n/** @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failSync(evaluate))\n\n/** @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failCause(cause))\n\n/** @internal */\nexport const failCauseSync = <E>(evaluate: LazyArg<Cause.Cause<E>>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failCauseSync(evaluate))\n\n/** @internal */\nexport const filterInput: {\n  <In, In1 extends In, In2 extends In1>(\n    f: Refinement<In1, In2>\n  ): <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In2, L, E, R>\n  <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In1, L, E, R>\n} = <In, In1 extends In>(f: Predicate<In1>) => {\n  return <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>): Sink.Sink<A, In1, L, E, R> =>\n    pipe(self, mapInputChunks(Chunk.filter(f)))\n}\n\n/** @internal */\nexport const filterInputEffect = dual<\n  <In, In1 extends In, E2, R2>(\n    f: (input: In1) => Effect.Effect<boolean, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In1, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In1 extends In, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In1) => Effect.Effect<boolean, E2, R2>\n  ) => Sink.Sink<A, In1, L, E2 | E, R2 | R>\n>(\n  2,\n  (self, f) =>\n    mapInputChunksEffect(\n      self,\n      (chunk) => Effect.map(Effect.filter(chunk, f), Chunk.unsafeFromArray)\n    )\n)\n\n/** @internal */\nexport const findEffect = dual<\n  <A, E2, R2>(\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => <In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R>,\n  <A, In, L extends In, E, R, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L extends In, E, R, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ): Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R> => {\n    const newChannel = pipe(\n      core.fromEffect(pipe(\n        Ref.make(Chunk.empty<In>()),\n        Effect.zip(Ref.make(false))\n      )),\n      core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n        const upstreamMarker: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> = core\n          .readWith({\n            onInput: (input) => pipe(core.write(input), core.flatMap(() => upstreamMarker)),\n            onFailure: core.fail,\n            onDone: (done) => pipe(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))\n          })\n        const loop: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E | E2, never, Option.Option<A>, unknown, R | R2> =\n          channel.foldChannel(core.collectElements(toChannel(self)), {\n            onFailure: core.fail,\n            onSuccess: ([leftovers, doneValue]) =>\n              pipe(\n                core.fromEffect(f(doneValue)),\n                core.flatMap((satisfied) =>\n                  pipe(\n                    core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers))),\n                    channel.zipRight(\n                      pipe(\n                        core.fromEffect(Ref.get(upstreamDoneRef)),\n                        core.flatMap((upstreamDone) => {\n                          if (satisfied) {\n                            return pipe(core.write(Chunk.flatten(leftovers)), channel.as(Option.some(doneValue)))\n                          }\n                          if (upstreamDone) {\n                            return pipe(core.write(Chunk.flatten(leftovers)), channel.as(Option.none()))\n                          }\n                          return loop\n                        })\n                      )\n                    )\n                  )\n                )\n              )\n          })\n        return pipe(upstreamMarker, core.pipeTo(channel.bufferChunk(leftoversRef)), core.pipeTo(loop))\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const fold = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => S\n): Sink.Sink<S, In, In> => suspend(() => new SinkImpl(foldReader(s, contFn, f)))\n\n/** @internal */\nconst foldReader = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (z: S, input: In) => S\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, S, unknown> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length)\n      if (Chunk.isNonEmpty(leftovers)) {\n        return pipe(core.write(leftovers), channel.as(nextS))\n      }\n      return foldReader(nextS, contFn, f)\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nconst foldChunkSplit = <S, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  contFn: Predicate<S>,\n  f: (z: S, input: In) => S,\n  index: number,\n  length: number\n): [S, Chunk.Chunk<In>] => {\n  if (index === length) {\n    return [s, Chunk.empty()]\n  }\n  const s1 = f(s, pipe(chunk, Chunk.unsafeGet(index)))\n  if (contFn(s1)) {\n    return foldChunkSplit(s1, chunk, contFn, f, index + 1, length)\n  }\n  return [s1, pipe(chunk, Chunk.drop(index + 1))]\n}\n\n/** @internal */\nexport const foldSink = dual<\n  <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (a: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ) => <L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (a: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ) => Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (z: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ): Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2> => {\n    const newChannel: Channel.Channel<\n      Chunk.Chunk<L1 | L2>,\n      Chunk.Chunk<In1 & In2>,\n      E1 | E2,\n      never,\n      A1 | A2,\n      unknown,\n      R | R1 | R2\n    > = pipe(\n      toChannel(self),\n      core.collectElements,\n      channel.foldChannel({\n        onFailure: (error) => toChannel(options.onFailure(error)),\n        onSuccess: ([leftovers, z]) =>\n          core.suspend(() => {\n            const leftoversRef = {\n              ref: pipe(leftovers, Chunk.filter(Chunk.isNonEmpty)) as Chunk.Chunk<Chunk.Chunk<L1 | L2>>\n            }\n            const refReader = pipe(\n              core.sync(() => {\n                const ref = leftoversRef.ref\n                leftoversRef.ref = Chunk.empty()\n                return ref\n              }),\n              // This cast is safe because of the L1 >: L <: In1 bound. It follows that\n              // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].\n              core.flatMap((chunk) => channel.writeChunk(chunk as Chunk.Chunk<Chunk.Chunk<In1 & In2>>))\n            )\n            const passthrough = channel.identityChannel<Chunk.Chunk<In1 & In2>, never, unknown>()\n            const continuationSink = pipe(\n              refReader,\n              channel.zipRight(passthrough),\n              core.pipeTo(toChannel(options.onSuccess(z)))\n            )\n            return core.flatMap(\n              core.collectElements(continuationSink),\n              ([newLeftovers, z1]) =>\n                pipe(\n                  core.succeed(leftoversRef.ref),\n                  core.flatMap(channel.writeChunk),\n                  channel.zipRight(channel.writeChunk(newLeftovers)),\n                  channel.as(z1)\n                )\n            )\n          })\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const foldChunks = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Sink.Sink<S, In> => suspend(() => new SinkImpl(foldChunksReader(s, contFn, f)))\n\n/** @internal */\nconst foldChunksReader = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Channel.Channel<never, Chunk.Chunk<In>, never, never, S, unknown> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => foldChunksReader(f(s, input), contFn, f),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nexport const foldChunksEffect = <S, In, E, R>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => suspend(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)))\n\n/** @internal */\nconst foldChunksEffectReader = <S, R, E, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Channel.Channel<never, Chunk.Chunk<In>, E, E, S, unknown, R> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(f(s, input)),\n        core.flatMap((s) => foldChunksEffectReader(s, contFn, f))\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nexport const foldEffect = <S, In, E, R>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => suspend(() => new SinkImpl(foldEffectReader(s, contFn, f)))\n\n/** @internal */\nconst foldEffectReader = <S, In, R, E>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, S, unknown, R> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(foldChunkSplitEffect(s, input, contFn, f)),\n        core.flatMap(([nextS, leftovers]) =>\n          pipe(\n            leftovers,\n            Option.match({\n              onNone: () => foldEffectReader(nextS, contFn, f),\n              onSome: (leftover) => pipe(core.write(leftover), channel.as(nextS))\n            })\n          )\n        )\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nconst foldChunkSplitEffect = <S, R, E, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Effect.Effect<[S, Option.Option<Chunk.Chunk<In>>], E, R> =>\n  foldChunkSplitEffectInternal(s, chunk, 0, chunk.length, contFn, f)\n\n/** @internal */\nconst foldChunkSplitEffectInternal = <S, R, E, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  index: number,\n  length: number,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Effect.Effect<[S, Option.Option<Chunk.Chunk<In>>], E, R> => {\n  if (index === length) {\n    return Effect.succeed([s, Option.none()])\n  }\n  return pipe(\n    f(s, pipe(chunk, Chunk.unsafeGet(index))),\n    Effect.flatMap((s1) =>\n      contFn(s1) ?\n        foldChunkSplitEffectInternal(s1, chunk, index + 1, length, contFn, f) :\n        Effect.succeed([s1, Option.some(pipe(chunk, Chunk.drop(index + 1)))])\n    )\n  )\n}\n\n/** @internal */\nexport const foldLeft = <S, In>(s: S, f: (s: S, input: In) => S): Sink.Sink<S, In> =>\n  ignoreLeftover(fold(s, constTrue, f))\n\n/** @internal */\nexport const foldLeftChunks = <S, In>(\n  s: S,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Sink.Sink<S, In> => foldChunks(s, constTrue, f)\n\n/** @internal */\nexport const foldLeftChunksEffect = <S, In, E, R>(\n  s: S,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, never, E, R> => ignoreLeftover(foldChunksEffect(s, constTrue, f))\n\n/** @internal */\nexport const foldLeftEffect = <S, In, E, R>(\n  s: S,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => foldEffect(s, constTrue, f)\n\n/** @internal */\nexport const foldUntil = <S, In>(s: S, max: number, f: (s: S, input: In) => S): Sink.Sink<S, In, In> =>\n  pipe(\n    fold<[S, number], In>(\n      [s, 0],\n      (tuple) => tuple[1] < max,\n      ([output, count], input) => [f(output, input), count + 1]\n    ),\n    map((tuple) => tuple[0])\n  )\n\n/** @internal */\nexport const foldUntilEffect = <S, In, E, R>(\n  s: S,\n  max: number,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> =>\n  pipe(\n    foldEffect(\n      [s, 0 as number] as const,\n      (tuple) => tuple[1] < max,\n      ([output, count], input: In) => pipe(f(output, input), Effect.map((s) => [s, count + 1] as const))\n    ),\n    map((tuple) => tuple[0])\n  )\n\n/** @internal */\nexport const foldWeighted = <S, In>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => number\n    readonly body: (s: S, input: In) => S\n  }\n): Sink.Sink<S, In, In> =>\n  foldWeightedDecompose({\n    ...options,\n    decompose: Chunk.of\n  })\n\n/** @internal */\nexport const foldWeightedDecompose = <S, In>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => number\n    readonly decompose: (input: In) => Chunk.Chunk<In>\n    readonly body: (s: S, input: In) => S\n  }\n): Sink.Sink<S, In, In> =>\n  suspend(() =>\n    new SinkImpl(\n      foldWeightedDecomposeLoop(\n        options.initial,\n        0,\n        false,\n        options.maxCost,\n        options.cost,\n        options.decompose,\n        options.body\n      )\n    )\n  )\n\n/** @internal */\nconst foldWeightedDecomposeLoop = <S, In>(\n  s: S,\n  cost: number,\n  dirty: boolean,\n  max: number,\n  costFn: (s: S, input: In) => number,\n  decompose: (input: In) => Chunk.Chunk<In>,\n  f: (s: S, input: In) => S\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, S, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(\n        input,\n        0,\n        s,\n        cost,\n        dirty,\n        max,\n        costFn,\n        decompose,\n        f\n      )\n      if (Chunk.isNonEmpty(leftovers)) {\n        return pipe(core.write(leftovers), channel.zipRight(core.succeedNow(nextS)))\n      }\n      if (cost > max) {\n        return core.succeedNow(nextS)\n      }\n      return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max, costFn, decompose, f)\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n\n/** @internal */\nconst foldWeightedDecomposeFold = <In, S>(\n  input: Chunk.Chunk<In>,\n  index: number,\n  s: S,\n  cost: number,\n  dirty: boolean,\n  max: number,\n  costFn: (s: S, input: In) => number,\n  decompose: (input: In) => Chunk.Chunk<In>,\n  f: (s: S, input: In) => S\n): [S, number, boolean, Chunk.Chunk<In>] => {\n  if (index === input.length) {\n    return [s, cost, dirty, Chunk.empty<In>()]\n  }\n  const elem = pipe(input, Chunk.unsafeGet(index))\n  const total = cost + costFn(s, elem)\n  if (total <= max) {\n    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max, costFn, decompose, f)\n  }\n  const decomposed = decompose(elem)\n  if (decomposed.length <= 1 && !dirty) {\n    // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n    // minimize \"injury\", we only allow this when we haven't added anything else\n    // to the aggregate (dirty = false).\n    return [f(s, elem), total, true, pipe(input, Chunk.drop(index + 1))]\n  }\n  if (decomposed.length <= 1 && dirty) {\n    // If the state is dirty and `elem` cannot be decomposed, we stop folding\n    // and include `elem` in the leftovers.\n    return [s, cost, dirty, pipe(input, Chunk.drop(index))]\n  }\n  // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n  // into the chunk we're processing and see if we can aggregate further.\n  const next = pipe(decomposed, Chunk.appendAll(pipe(input, Chunk.drop(index + 1))))\n  return foldWeightedDecomposeFold(next, 0, s, cost, dirty, max, costFn, decompose, f)\n}\n\n/** @internal */\nexport const foldWeightedDecomposeEffect = <S, In, E, R, E2, R2, E3, R3>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>\n    readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n    readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>\n  }\n): Sink.Sink<S, In, In, E | E2 | E3, R | R2 | R3> =>\n  suspend(() =>\n    new SinkImpl(\n      foldWeightedDecomposeEffectLoop(\n        options.initial,\n        options.maxCost,\n        options.cost,\n        options.decompose,\n        options.body,\n        0,\n        false\n      )\n    )\n  )\n\n/** @internal */\nexport const foldWeightedEffect = <S, In, E, R, E2, R2>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>\n    readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>\n  }\n): Sink.Sink<S, In, In, E | E2, R | R2> =>\n  foldWeightedDecomposeEffect({\n    ...options,\n    decompose: (input) => Effect.succeed(Chunk.of(input))\n  })\n\nconst foldWeightedDecomposeEffectLoop = <S, In, E, R, E2, R2, E3, R3>(\n  s: S,\n  max: number,\n  costFn: (s: S, input: In) => Effect.Effect<number, E, R>,\n  decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>,\n  f: (s: S, input: In) => Effect.Effect<S, E3, R3>,\n  cost: number,\n  dirty: boolean\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E | E2 | E3, E | E2 | E3, S, unknown, R | R2 | R3> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, dirty, cost, 0)),\n        core.flatMap(([nextS, nextCost, nextDirty, leftovers]) => {\n          if (Chunk.isNonEmpty(leftovers)) {\n            return pipe(core.write(leftovers), channel.zipRight(core.succeedNow(nextS)))\n          }\n          if (cost > max) {\n            return core.succeedNow(nextS)\n          }\n          return foldWeightedDecomposeEffectLoop(nextS, max, costFn, decompose, f, nextCost, nextDirty)\n        })\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n\n/** @internal */\nconst foldWeightedDecomposeEffectFold = <S, In, E, R, E2, R2, E3, R3>(\n  s: S,\n  max: number,\n  costFn: (s: S, input: In) => Effect.Effect<number, E, R>,\n  decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>,\n  f: (s: S, input: In) => Effect.Effect<S, E3, R3>,\n  input: Chunk.Chunk<In>,\n  dirty: boolean,\n  cost: number,\n  index: number\n): Effect.Effect<[S, number, boolean, Chunk.Chunk<In>], E | E2 | E3, R | R2 | R3> => {\n  if (index === input.length) {\n    return Effect.succeed([s, cost, dirty, Chunk.empty<In>()])\n  }\n  const elem = pipe(input, Chunk.unsafeGet(index))\n  return pipe(\n    costFn(s, elem),\n    Effect.map((newCost) => cost + newCost),\n    Effect.flatMap((total) => {\n      if (total <= max) {\n        return pipe(\n          f(s, elem),\n          Effect.flatMap((s) =>\n            foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, true, total, index + 1)\n          )\n        )\n      }\n      return pipe(\n        decompose(elem),\n        Effect.flatMap((decomposed) => {\n          if (decomposed.length <= 1 && !dirty) {\n            // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n            // minimize \"injury\", we only allow this when we haven't added anything else\n            // to the aggregate (dirty = false).\n            return pipe(\n              f(s, elem),\n              Effect.map((s) => [s, total, true, pipe(input, Chunk.drop(index + 1))])\n            )\n          }\n          if (decomposed.length <= 1 && dirty) {\n            // If the state is dirty and `elem` cannot be decomposed, we stop folding\n            // and include `elem` in th leftovers.\n            return Effect.succeed([s, cost, dirty, pipe(input, Chunk.drop(index))])\n          }\n          // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n          // into the chunk we're processing and see if we can aggregate further.\n          const next = pipe(decomposed, Chunk.appendAll(pipe(input, Chunk.drop(index + 1))))\n          return foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, next, dirty, cost, 0)\n        })\n      )\n    })\n  )\n}\n\n/** @internal */\nexport const flatMap = dual<\n  <A, A1, In, In1 extends In, L1, E1, R1>(\n    f: (a: A) => Sink.Sink<A1, In1, L1, E1, R1>\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1, In & In1, L | L1, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Sink.Sink<A1, In1, L1, E1, R1>\n  ) => Sink.Sink<A1, In & In1, L | L1, E1 | E, R1 | R>\n>(\n  2,\n  (self, f) => foldSink(self, { onFailure: fail, onSuccess: f })\n)\n\n/** @internal */\nexport const forEach = <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>): Sink.Sink<void, In, never, E, R> => {\n  const process: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(core.fromEffect(Effect.forEach(input, (v) => f(v), { discard: true })), core.flatMap(() => process)),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nexport const forEachChunk = <In, X, E, R>(\n  f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>\n): Sink.Sink<void, In, never, E, R> => {\n  const process: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) => pipe(core.fromEffect(f(input)), core.flatMap(() => process)),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nexport const forEachWhile = <In, E, R>(\n  f: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<void, In, In, E, R> => {\n  const process: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) => forEachWhileReader(f, input, 0, input.length, process),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nconst forEachWhileReader = <In, E, R>(\n  f: (input: In) => Effect.Effect<boolean, E, R>,\n  input: Chunk.Chunk<In>,\n  index: number,\n  length: number,\n  cont: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R> => {\n  if (index === length) {\n    return cont\n  }\n  return pipe(\n    core.fromEffect(f(pipe(input, Chunk.unsafeGet(index)))),\n    core.flatMap((bool) =>\n      bool ?\n        forEachWhileReader(f, input, index + 1, length, cont) :\n        core.write(pipe(input, Chunk.drop(index)))\n    ),\n    channel.catchAll((error) => pipe(core.write(pipe(input, Chunk.drop(index))), channel.zipRight(core.fail(error))))\n  )\n}\n\n/** @internal */\nexport const forEachChunkWhile = <In, E, R>(\n  f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>\n): Sink.Sink<void, In, In, E, R> => {\n  const reader: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(f(input)),\n        core.flatMap((cont) => cont ? reader : core.void)\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n  return new SinkImpl(reader)\n}\n\n/** @internal */\nexport const fromChannel = <L, In, E, A, R>(\n  channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>\n): Sink.Sink<A, In, L, E, R> => new SinkImpl(channel)\n\n/** @internal */\nexport const fromEffect = <A, E, R>(effect: Effect.Effect<A, E, R>): Sink.Sink<A, unknown, never, E, R> =>\n  new SinkImpl(core.fromEffect(effect))\n\n/** @internal */\nexport const fromPubSub = <In>(\n  pubsub: PubSub.PubSub<In>,\n  options?: {\n    readonly shutdown?: boolean | undefined\n  }\n): Sink.Sink<void, In> => fromQueue(pubsub, options)\n\n/** @internal */\nexport const fromPush = <In, L0, R0, L, R>(\n  push: Effect.Effect<\n    (_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>,\n    never,\n    R\n  >\n): Sink.Sink<R0, In, L, L0, Exclude<R, Scope.Scope>> =>\n  new SinkImpl(channel.unwrapScoped(pipe(push, Effect.map(fromPushPull))))\n\nconst fromPushPull = <In, Z, E, L, R>(\n  push: (\n    option: Option.Option<Chunk.Chunk<In>>\n  ) => Effect.Effect<void, readonly [Either.Either<Z, E>, Chunk.Chunk<L>], R>\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, Z, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      channel.foldChannel(core.fromEffect(push(Option.some(input))), {\n        onFailure: ([either, leftovers]) =>\n          Either.match(either, {\n            onLeft: (error) => pipe(core.write(leftovers), channel.zipRight(core.fail(error))),\n            onRight: (z) => pipe(core.write(leftovers), channel.zipRight(core.succeedNow(z)))\n          }),\n        onSuccess: () => fromPushPull(push)\n      }),\n    onFailure: core.fail,\n    onDone: () =>\n      channel.foldChannel(core.fromEffect(push(Option.none())), {\n        onFailure: ([either, leftovers]) =>\n          Either.match(either, {\n            onLeft: (error) => pipe(core.write(leftovers), channel.zipRight(core.fail(error))),\n            onRight: (z) => pipe(core.write(leftovers), channel.zipRight(core.succeedNow(z)))\n          }),\n        onSuccess: () =>\n          core.fromEffect(\n            Effect.dieMessage(\n              \"BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/effect/issues\"\n            )\n          )\n      })\n  })\n\n/** @internal */\nexport const fromQueue = <In>(\n  queue: Queue.Enqueue<In>,\n  options?: {\n    readonly shutdown?: boolean | undefined\n  }\n): Sink.Sink<void, In> =>\n  options?.shutdown ?\n    unwrapScoped(\n      Effect.map(\n        Effect.acquireRelease(Effect.succeed(queue), Queue.shutdown),\n        fromQueue\n      )\n    ) :\n    forEachChunk((input: Chunk.Chunk<In>) => pipe(Queue.offerAll(queue, input)))\n\n/** @internal */\nexport const head = <In>(): Sink.Sink<Option.Option<In>, In, In> =>\n  fold(\n    Option.none() as Option.Option<In>,\n    Option.isNone,\n    (option, input) =>\n      Option.match(option, {\n        onNone: () => Option.some(input),\n        onSome: () => option\n      })\n  )\n\n/** @internal */\nexport const ignoreLeftover = <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>): Sink.Sink<A, In, never, E, R> =>\n  new SinkImpl(channel.drain(toChannel(self)))\n\n/** @internal */\nexport const last = <In>(): Sink.Sink<Option.Option<In>, In, In> =>\n  foldLeftChunks(Option.none<In>(), (s, input) => Option.orElse(Chunk.last(input), () => s))\n\n/** @internal */\nexport const leftover = <L>(chunk: Chunk.Chunk<L>): Sink.Sink<void, unknown, L> =>\n  new SinkImpl(core.suspend(() => core.write(chunk)))\n\n/** @internal */\nexport const map = dual<\n  <A, A2>(f: (a: A) => A2) => <In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E, R>,\n  <A, In, L, E, R, A2>(self: Sink.Sink<A, In, L, E, R>, f: (a: A) => A2) => Sink.Sink<A2, In, L, E, R>\n>(2, (self, f) => {\n  return new SinkImpl(pipe(toChannel(self), channel.map(f)))\n})\n\n/** @internal */\nexport const mapEffect = dual<\n  <A, A2, E2, R2>(\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => <In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => Sink.Sink<A2, In, L, E2 | E, R2 | R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapEffect(f)))\n)\n\n/** @internal */\nexport const mapError = dual<\n  <E, E2>(f: (error: E) => E2) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(self: Sink.Sink<A, In, L, E, R>, f: (error: E) => E2) => Sink.Sink<A, In, L, E2, R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapError(f)))\n)\n\n/** @internal */\nexport const mapLeftover = dual<\n  <L, L2>(f: (leftover: L) => L2) => <A, In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L2, E, R>,\n  <A, In, L, E, R, L2>(self: Sink.Sink<A, In, L, E, R>, f: (leftover: L) => L2) => Sink.Sink<A, In, L2, E, R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapOut(Chunk.map(f))))\n)\n\n/** @internal */\nexport const never: Sink.Sink<never, unknown> = fromEffect(Effect.never)\n\n/** @internal */\nexport const orElse = dual<\n  <A2, In2, L2, E2, R2>(\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ) => Sink.Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A2, In2, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ): Sink.Sink<A | A2, In & In2, L | L2, E | E2, R | R2> =>\n    new SinkImpl<A | A2, In & In2, L | L2, E | E2, R | R2>(\n      pipe(toChannel(self), channel.orElse(() => toChannel(that())))\n    )\n)\n\n/** @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, In, L, E>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E>,\n  <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>, context: Context.Context<R>) => Sink.Sink<A, In, L, E>\n>(\n  2,\n  (self, context) => new SinkImpl(pipe(toChannel(self), core.provideContext(context)))\n)\n\n/** @internal */\nexport const race = dual<\n  <R1, E1, In1, L1, A1>(\n    that: Sink.Sink<A1, In1, L1, E1, R1>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A1, In1, L1, E1, R1>\n  ) => Sink.Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>\n>(\n  2,\n  (self, that) => pipe(self, raceBoth(that), map(Either.merge))\n)\n\n/** @internal */\nexport const raceBoth = dual<\n  <A1, In1, L1, E1, R1>(\n    that: Sink.Sink<A1, In1, L1, E1, R1>,\n    options?: {\n      readonly capacity?: number | undefined\n    }\n  ) => <A, In, L, E, R>(\n    self: Sink.Sink<A, In, L, E, R>\n  ) => Sink.Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A1, In1, L1, E1, R1>,\n    options?: {\n      readonly capacity?: number | undefined\n    }\n  ) => Sink.Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>\n>(\n  (args) => isSink(args[1]),\n  (self, that, options) =>\n    raceWith(self, {\n      other: that,\n      onSelfDone: (selfDone) => mergeDecision.Done(Effect.map(selfDone, Either.left)),\n      onOtherDone: (thatDone) => mergeDecision.Done(Effect.map(thatDone, Either.right)),\n      capacity: options?.capacity ?? 16\n    })\n)\n\n/** @internal */\nexport const raceWith = dual<\n  <A2, In2, L2, E2, R2, A, E, A3, A4>(\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ) => <In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ) => Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ): Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R> => {\n    const scoped = Effect.gen(function*($) {\n      const pubsub = yield* $(\n        PubSub.bounded<Either.Either<Chunk.Chunk<In & In2>, Exit.Exit<unknown>>>(options?.capacity ?? 16)\n      )\n      const channel1 = yield* $(channel.fromPubSubScoped(pubsub))\n      const channel2 = yield* $(channel.fromPubSubScoped(pubsub))\n      const reader = channel.toPubSub(pubsub)\n      const writer = pipe(\n        channel1,\n        core.pipeTo(toChannel(self)),\n        channel.mergeWith({\n          other: pipe(channel2, core.pipeTo(toChannel(options.other))),\n          onSelfDone: options.onSelfDone,\n          onOtherDone: options.onOtherDone\n        })\n      )\n      const racedChannel: Channel.Channel<\n        Chunk.Chunk<L | L2>,\n        Chunk.Chunk<In & In2>,\n        E | E2,\n        never,\n        A3 | A4,\n        unknown,\n        R | R2\n      > = channel.mergeWith(reader, {\n        other: writer,\n        onSelfDone: (_) => mergeDecision.Await((exit) => Effect.suspend(() => exit)),\n        onOtherDone: (done) => mergeDecision.Done(Effect.suspend(() => done))\n      })\n      return new SinkImpl(racedChannel)\n    })\n    return unwrapScoped(scoped)\n  }\n)\n\n/** @internal */\nexport const refineOrDie = dual<\n  <E, E2>(\n    pf: (error: E) => Option.Option<E2>\n  ) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    pf: (error: E) => Option.Option<E2>\n  ) => Sink.Sink<A, In, L, E2, R>\n>(\n  2,\n  (self, pf) => pipe(self, refineOrDieWith(pf, identity))\n)\n\n/** @internal */\nexport const refineOrDieWith = dual<\n  <E, E2>(\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => Sink.Sink<A, In, L, E2, R>\n>(\n  3,\n  (self, pf, f) => {\n    const newChannel = pipe(\n      self,\n      toChannel,\n      channel.catchAll((error) =>\n        Option.match(pf(error), {\n          onNone: () => core.failCauseSync(() => Cause.die(f(error))),\n          onSome: core.fail\n        })\n      )\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const service = <T extends Context.Tag<any, any>>(\n  tag: T\n): Sink.Sink<Context.Tag.Service<T>, unknown, never, never, Context.Tag.Identifier<T>> => serviceWith(tag, identity)\n\n/** @internal */\nexport const serviceWith = <T extends Context.Tag<any, any>, Z>(\n  tag: T,\n  f: (service: Context.Tag.Service<T>) => Z\n): Sink.Sink<Z, unknown, never, never, Context.Tag.Identifier<T>> => fromEffect(Effect.map(tag, f))\n\n/** @internal */\nexport const serviceWithEffect = <T extends Context.Tag<any, any>, R, E, Z>(\n  tag: T,\n  f: (service: Context.Tag.Service<T>) => Effect.Effect<Z, E, R>\n): Sink.Sink<Z, unknown, never, E, R | Context.Tag.Identifier<T>> => fromEffect(Effect.flatMap(tag, f))\n\n/** @internal */\nexport const serviceWithSink = <T extends Context.Tag<any, any>, R, E, In, L, Z>(\n  tag: T,\n  f: (service: Context.Tag.Service<T>) => Sink.Sink<Z, In, L, E, R>\n): Sink.Sink<Z, In, L, E, R | Context.Tag.Identifier<T>> =>\n  new SinkImpl(pipe(Effect.map(tag, (service) => toChannel(f(service))), channel.unwrap))\n\n/** @internal */\nexport const some = <In>(predicate: Predicate<In>): Sink.Sink<boolean, In, In> =>\n  fold(false, (bool) => !bool, (acc, input) => acc || predicate(input))\n\n/** @internal */\nexport const splitWhere = dual<\n  <In>(f: Predicate<In>) => <A, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, In, E, R>,\n  <A, In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>, f: Predicate<In>) => Sink.Sink<A, In, In, E, R>\n>(2, <A, In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>, f: Predicate<In>): Sink.Sink<A, In, In, E, R> => {\n  const newChannel = pipe(\n    core.fromEffect(Ref.make(Chunk.empty<In>())),\n    core.flatMap((ref) =>\n      pipe(\n        splitWhereSplitter<In, E>(false, ref, f),\n        channel.pipeToOrFail(toChannel(self)),\n        core.collectElements,\n        core.flatMap(([leftovers, z]) =>\n          pipe(\n            core.fromEffect(Ref.get(ref)),\n            core.flatMap((leftover) =>\n              pipe(\n                core.write<Chunk.Chunk<In>>(pipe(leftover, Chunk.appendAll(Chunk.flatten(leftovers)))),\n                channel.zipRight(core.succeed(z))\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n  return new SinkImpl(newChannel)\n})\n\n/** @internal */\nconst splitWhereSplitter = <A, E>(\n  written: boolean,\n  leftovers: Ref.Ref<Chunk.Chunk<A>>,\n  f: Predicate<A>\n): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, never, unknown, unknown> =>\n  core.readWithCause({\n    onInput: (input) => {\n      if (Chunk.isEmpty(input)) {\n        return splitWhereSplitter(written, leftovers, f)\n      }\n      if (written) {\n        const index = indexWhere(input, f)\n        if (index === -1) {\n          return channel.zipRight(\n            core.write(input),\n            splitWhereSplitter<A, E>(true, leftovers, f)\n          )\n        }\n        const [left, right] = Chunk.splitAt(input, index)\n        return channel.zipRight(\n          core.write(left),\n          core.fromEffect(Ref.set(leftovers, right))\n        )\n      }\n      const index = indexWhere(input, f, 1)\n      if (index === -1) {\n        return channel.zipRight(\n          core.write(input),\n          splitWhereSplitter<A, E>(true, leftovers, f)\n        )\n      }\n      const [left, right] = pipe(input, Chunk.splitAt(Math.max(index, 1)))\n      return channel.zipRight(core.write(left), core.fromEffect(Ref.set(leftovers, right)))\n    },\n    onFailure: core.failCause,\n    onDone: core.succeed\n  })\n\n/** @internal */\nconst indexWhere = <A>(self: Chunk.Chunk<A>, predicate: Predicate<A>, from = 0): number => {\n  const iterator = self[Symbol.iterator]()\n  let index = 0\n  let result = -1\n  let next: IteratorResult<A, any>\n  while (result < 0 && (next = iterator.next()) && !next.done) {\n    const a = next.value\n    if (index >= from && predicate(a)) {\n      result = index\n    }\n    index = index + 1\n  }\n  return result\n}\n\n/** @internal */\nexport const succeed = <A>(a: A): Sink.Sink<A, unknown> => new SinkImpl(core.succeed(a))\n\n/** @internal */\nexport const sum: Sink.Sink<number, number> = foldLeftChunks(\n  0,\n  (acc, chunk) => acc + Chunk.reduce(chunk, 0, (s, a) => s + a)\n)\n\n/** @internal */\nexport const summarized = dual<\n  <A2, E2, R2, A3>(\n    summary: Effect.Effect<A2, E2, R2>,\n    f: (start: A2, end: A2) => A3\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<[A, A3], In, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    summary: Effect.Effect<A2, E2, R2>,\n    f: (start: A2, end: A2) => A3\n  ) => Sink.Sink<[A, A3], In, L, E2 | E, R2 | R>\n>(\n  3,\n  (self, summary, f) => {\n    const newChannel = pipe(\n      core.fromEffect(summary),\n      core.flatMap((start) =>\n        pipe(\n          self,\n          toChannel,\n          core.flatMap((done) =>\n            pipe(\n              core.fromEffect(summary),\n              channel.map((end) => [done, f(start, end)])\n            )\n          )\n        )\n      )\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const sync = <A>(evaluate: LazyArg<A>): Sink.Sink<A, unknown> => new SinkImpl(core.sync(evaluate))\n\n/** @internal */\nexport const take = <In>(n: number): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  pipe(\n    foldChunks<Chunk.Chunk<In>, In>(\n      Chunk.empty(),\n      (chunk) => chunk.length < n,\n      (acc, chunk) => pipe(acc, Chunk.appendAll(chunk))\n    ),\n    flatMap((acc) => {\n      const [taken, leftover] = pipe(acc, Chunk.splitAt(n))\n      return new SinkImpl(pipe(core.write(leftover), channel.zipRight(core.succeedNow(taken))))\n    })\n  )\n\n/** @internal */\nexport const toChannel = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R> =>\n  Effect.isEffect(self) ?\n    toChannel(fromEffect(self as Effect.Effect<A, E, R>)) :\n    (self as SinkImpl<A, In, L, E, R>).channel\n\n/** @internal */\nexport const unwrap = <A, In, L, E2, R2, E, R>(\n  effect: Effect.Effect<Sink.Sink<A, In, L, E2, R2>, E, R>\n): Sink.Sink<A, In, L, E | E2, R | R2> =>\n  new SinkImpl(\n    channel.unwrap(pipe(effect, Effect.map((sink) => toChannel(sink))))\n  )\n\n/** @internal */\nexport const unwrapScoped = <A, In, L, E, R>(\n  effect: Effect.Effect<Sink.Sink<A, In, L, E, R>, E, R>\n): Sink.Sink<A, In, L, E, Exclude<R, Scope.Scope>> => {\n  return new SinkImpl(channel.unwrapScoped(pipe(effect, Effect.map((sink) => toChannel(sink)))))\n}\n\n/** @internal */\nexport const withDuration = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<[A, Duration.Duration], In, L, E, R> =>\n  pipe(self, summarized(Clock.currentTimeMillis, (start, end) => Duration.millis(end - start)))\n\n/** @internal */\nexport const zip = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (z, z2) => [z, z2], options)\n)\n\n/** @internal */\nexport const zipLeft = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (z, _) => z, options)\n)\n\n/** @internal */\nexport const zipRight = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (_, z2) => z2, options)\n)\n\n/** @internal */\nexport const zipWith = dual<\n  <A2, In, In2 extends In, L2, E2, R2, A, A3>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R> =>\n    options?.concurrent ?\n      raceWith(self, {\n        other: that,\n        onSelfDone: Exit.match({\n          onFailure: (cause) => mergeDecision.Done(Effect.failCause(cause)),\n          onSuccess: (leftZ) =>\n            mergeDecision.Await<R | R2, E2, A2, E | E2, A3>(\n              Exit.match({\n                onFailure: Effect.failCause,\n                onSuccess: (rightZ) => Effect.succeed(f(leftZ, rightZ))\n              })\n            )\n        }),\n        onOtherDone: Exit.match({\n          onFailure: (cause) => mergeDecision.Done(Effect.failCause(cause)),\n          onSuccess: (rightZ) =>\n            mergeDecision.Await<R | R2, E, A, E | E2, A3>(\n              Exit.match({\n                onFailure: Effect.failCause,\n                onSuccess: (leftZ) => Effect.succeed(f(leftZ, rightZ))\n              })\n            )\n        })\n      }) :\n      flatMap(self, (z) => map(that, (z2) => f(z, z2)))\n)\n\n// Circular with Channel\n\n/** @internal */\nexport const channelToSink = <OutElem, InElem, OutErr, InErr, OutDone, Env>(\n  self: Channel.Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>\n): Sink.Sink<OutDone, InElem, OutElem, OutErr, Env> => new SinkImpl(self)\n\n// Constants\n\n/** @internal */\nexport const count: Sink.Sink<number, unknown> = foldLeftChunks(\n  0,\n  (acc, chunk) => acc + chunk.length\n)\n\n/** @internal */\nexport const mkString: Sink.Sink<string, unknown> = suspend(() => {\n  const strings: Array<string> = []\n  return pipe(\n    foldLeftChunks<void, unknown>(void 0, (_, elems) =>\n      Chunk.map(elems, (elem) => {\n        strings.push(String(elem))\n      })),\n    map(() => strings.join(\"\"))\n  )\n})\n\n/** @internal */\nexport const timed: Sink.Sink<Duration.Duration, unknown> = pipe(\n  withDuration(drain),\n  map((tuple) => tuple[1])\n)\n"],"names":["Arr","Cause","Chunk","Clock","Duration","Effect","Either","Exit","constTrue","dual","identity","pipe","HashMap","HashSet","Option","pipeArguments","hasProperty","PubSub","Queue","Ref","channel","mergeDecision","core","SinkTypeId","Symbol","for","sinkVariance","_A","_","_In","_L","_E","_R","SinkImpl","constructor","arguments","isSink","u","suspend","evaluate","toChannel","as","self","a","map","collectAll","collectAllLoop","empty","acc","readWithCause","onInput","chunk","appendAll","onFailure","failCause","onDone","succeed","collectAllN","n","fromChannel","collectAllNLoop","collected","leftovers","splitAt","length","isEmpty","flatMap","write","collectAllFrom","collectAllWhileWith","initial","while","body","append","collectAllToMap","key","merge","foldLeftChunks","reduce","input","k","v","has","unsafeGet","set","collectAllToMapN","foldWeighted","maxCost","cost","collectAllToSet","add","collectAllToSetN","collectAllUntil","p","fold","tuple","collectAllUntilEffect","foldEffect","bool","collectAllWhile","predicate","collectAllWhileReader","done","readWith","toReadonlyArray","span","unsafeFromArray","zipRight","fail","collectAllWhileEffect","collectAllWhileEffectReader","fromEffect","takeWhile","drop","options","refs","make","zip","newChannel","leftoversRef","upstreamDoneRef","upstreamMarker","pipeTo","bufferChunk","collectAllWhileWithLoop","currentResult","f","doneCollect","foldChannel","onSuccess","doneValue","flatten","get","upstreamDone","accumulatedResult","collectLeftover","collectElements","chunks","z","mapInput","mapInputChunks","mapInputEffect","mapInputChunksEffect","forEach","loop","pipeToOrFail","die","defect","dieMessage","message","RuntimeException","dieSync","failCauseSync","dimap","dimapEffect","mapEffect","dimapChunks","dimapChunksEffect","drain","identityChannel","dropLoop","dropped","leftover","Math","max","more","void","dropUntil","dropWhile","dropUntilEffect","dropUntilEffectReader","unwrap","dropWhileReader","out","succeedNow","dropWhileEffect","dropWhileEffectReader","ensuring","finalizer","ensuringWith","context","contextWith","contextWithEffect","contextWithSink","every","e","failSync","cause","filterInput","filter","filterInputEffect","findEffect","satisfied","some","none","s","contFn","foldReader","nextS","foldChunkSplit","isNonEmpty","index","s1","foldSink","error","ref","refReader","sync","writeChunk","passthrough","continuationSink","newLeftovers","z1","foldChunks","foldChunksReader","foldChunksEffect","foldChunksEffectReader","foldEffectReader","foldChunkSplitEffect","match","onNone","onSome","foldChunkSplitEffectInternal","foldLeft","ignoreLeftover","foldLeftChunksEffect","foldLeftEffect","foldUntil","output","count","foldUntilEffect","foldWeightedDecompose","decompose","of","foldWeightedDecomposeLoop","dirty","costFn","nextCost","nextDirty","foldWeightedDecomposeFold","elem","total","decomposed","next","foldWeightedDecomposeEffect","foldWeightedDecomposeEffectLoop","foldWeightedEffect","foldWeightedDecomposeEffectFold","newCost","process","discard","forEachChunk","forEachWhile","forEachWhileReader","cont","catchAll","forEachChunkWhile","reader","effect","fromPubSub","pubsub","fromQueue","fromPush","push","unwrapScoped","fromPushPull","either","onLeft","onRight","queue","shutdown","acquireRelease","offerAll","head","isNone","option","last","orElse","mapError","mapLeftover","mapOut","never","that","provideContext","race","raceBoth","args","raceWith","other","onSelfDone","selfDone","Done","left","onOtherDone","thatDone","right","capacity","scoped","gen","$","bounded","channel1","fromPubSubScoped","channel2","toPubSub","writer","mergeWith","racedChannel","Await","exit","refineOrDie","pf","refineOrDieWith","service","tag","serviceWith","serviceWithEffect","serviceWithSink","splitWhere","splitWhereSplitter","written","indexWhere","from","iterator","result","value","sum","summarized","summary","start","end","take","taken","isEffect","sink","withDuration","currentTimeMillis","millis","zipWith","z2","zipLeft","concurrent","leftZ","rightZ","channelToSink","mkString","strings","elems","String","join","timed"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 868, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}