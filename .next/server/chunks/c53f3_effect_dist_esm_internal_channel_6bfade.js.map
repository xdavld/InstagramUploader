{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"channel.js","sources":["file:///Users/david/src/5.%20Semester/SoftwareEngineering-Project/node_modules/.pnpm/effect%403.10.3/node_modules/effect/src/internal/channel.ts"],"sourcesContent":["import * as Cause from \"../Cause.js\"\nimport type * as Channel from \"../Channel.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport * as Deferred from \"../Deferred.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Exit from \"../Exit.js\"\nimport * as Fiber from \"../Fiber.js\"\nimport * as FiberRef from \"../FiberRef.js\"\nimport { constVoid, dual, identity, pipe } from \"../Function.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport * as Layer from \"../Layer.js\"\nimport type * as MergeDecision from \"../MergeDecision.js\"\nimport type * as MergeState from \"../MergeState.js\"\nimport type * as MergeStrategy from \"../MergeStrategy.js\"\nimport * as Option from \"../Option.js\"\nimport { hasProperty, type Predicate } from \"../Predicate.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Queue from \"../Queue.js\"\nimport * as Ref from \"../Ref.js\"\nimport * as Scope from \"../Scope.js\"\nimport type * as SingleProducerAsyncInput from \"../SingleProducerAsyncInput.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport * as executor from \"./channel/channelExecutor.js\"\nimport type * as ChannelState from \"./channel/channelState.js\"\nimport * as mergeDecision from \"./channel/mergeDecision.js\"\nimport * as mergeState from \"./channel/mergeState.js\"\nimport * as _mergeStrategy from \"./channel/mergeStrategy.js\"\nimport * as singleProducerAsyncInput from \"./channel/singleProducerAsyncInput.js\"\nimport * as coreEffect from \"./core-effect.js\"\nimport * as core from \"./core-stream.js\"\nimport * as MergeDecisionOpCodes from \"./opCodes/channelMergeDecision.js\"\nimport * as MergeStateOpCodes from \"./opCodes/channelMergeState.js\"\nimport * as ChannelStateOpCodes from \"./opCodes/channelState.js\"\nimport * as tracer from \"./tracer.js\"\n\n/** @internal */\nexport const acquireUseRelease = <Acquired, OutErr, Env, OutElem1, InElem, InErr, OutDone, InDone>(\n  acquire: Effect.Effect<Acquired, OutErr, Env>,\n  use: (a: Acquired) => Channel.Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  release: (a: Acquired, exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>\n): Channel.Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env> =>\n  core.flatMap(\n    core.fromEffect(\n      Ref.make<\n        (exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>\n      >(() => Effect.void)\n    ),\n    (ref) =>\n      pipe(\n        core.fromEffect(\n          Effect.uninterruptible(\n            Effect.tap(\n              acquire,\n              (a) => Ref.set(ref, (exit) => release(a, exit))\n            )\n          )\n        ),\n        core.flatMap(use),\n        core.ensuringWith((exit) => Effect.flatMap(Ref.get(ref), (f) => f(exit)))\n      )\n  )\n\n/** @internal */\nexport const as = dual<\n  <OutDone2>(\n    value: OutDone2\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    value: OutDone2\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  value: OutDone2\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env> => map(self, () => value))\n\n/** @internal */\nexport const asVoid = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, void, InDone, Env> => map(self, constVoid)\n\n/** @internal */\nexport const buffer = <InElem, InErr, InDone>(\n  options: {\n    readonly empty: InElem\n    readonly isEmpty: Predicate<InElem>\n    readonly ref: Ref.Ref<InElem>\n  }\n): Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone> =>\n  core.suspend(() => {\n    const doBuffer = <InErr, InElem, InDone>(\n      empty: InElem,\n      isEmpty: Predicate<InElem>,\n      ref: Ref.Ref<InElem>\n    ): Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone> =>\n      unwrap(\n        Ref.modify(ref, (inElem) =>\n          isEmpty(inElem) ?\n            [\n              core.readWith({\n                onInput: (input: InElem) =>\n                  core.flatMap(\n                    core.write(input),\n                    () => doBuffer<InErr, InElem, InDone>(empty, isEmpty, ref)\n                  ),\n                onFailure: (error: InErr) => core.fail(error),\n                onDone: (done: InDone) => core.succeedNow(done)\n              }),\n              inElem\n            ] as const :\n            [\n              core.flatMap(\n                core.write(inElem),\n                () => doBuffer<InErr, InElem, InDone>(empty, isEmpty, ref)\n              ),\n              empty\n            ] as const)\n      )\n    return doBuffer(options.empty, options.isEmpty, options.ref)\n  })\n\n/** @internal */\nexport const bufferChunk = <InElem, InErr, InDone>(\n  ref: Ref.Ref<Chunk.Chunk<InElem>>\n): Channel.Channel<Chunk.Chunk<InElem>, Chunk.Chunk<InElem>, InErr, InErr, InDone, InDone> =>\n  buffer({\n    empty: Chunk.empty(),\n    isEmpty: Chunk.isEmpty,\n    ref\n  })\n\n/** @internal */\nexport const catchAll = dual<\n  <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  2,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone | OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    core.catchAllCause(self, (cause) =>\n      Either.match(Cause.failureOrCause(cause), {\n        onLeft: f,\n        onRight: core.failCause\n      }))\n)\n\n/** @internal */\nexport const concatMap = dual<\n  <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(\n    f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n  ) => <Env, InErr, InElem, InDone, OutErr, OutDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem2,\n    InElem & InElem2,\n    OutErr2 | OutErr,\n    InErr & InErr2,\n    unknown,\n    InDone & InDone2,\n    Env2 | Env\n  >,\n  <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n  ) => Channel.Channel<\n    OutElem2,\n    InElem & InElem2,\n    OutErr2 | OutErr,\n    InErr & InErr2,\n    unknown,\n    InDone & InDone2,\n    Env2 | Env\n  >\n>(2, <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>\n): Channel.Channel<\n  OutElem2,\n  InElem & InElem2,\n  OutErr | OutErr2,\n  InErr & InErr2,\n  unknown,\n  InDone & InDone2,\n  Env | Env2\n> => core.concatMapWith(self, f, () => void 0, () => void 0))\n\n/** @internal */\nexport const collect = dual<\n  <OutElem, OutElem2>(\n    pf: (o: OutElem) => Option.Option<OutElem2>\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    pf: (o: OutElem) => Option.Option<OutElem2>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  pf: (o: OutElem) => Option.Option<OutElem2>\n): Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const collector: Channel.Channel<OutElem2, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWith({\n      onInput: (out) =>\n        Option.match(pf(out), {\n          onNone: () => collector,\n          onSome: (out2) => core.flatMap(core.write(out2), () => collector)\n        }),\n      onFailure: core.fail,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, collector)\n})\n\n/** @internal */\nexport const concatOut = <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >\n): Channel.Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env> => core.concatAll(self)\n\n/** @internal */\nexport const mapInput = dual<\n  <InDone0, InDone>(\n    f: (a: InDone0) => InDone\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InDone0) => InDone\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InDone0) => InDone\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone0> = core.readWith({\n    onInput: (inElem: InElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: core.fail,\n    onDone: (done: InDone0) => core.succeedNow(f(done))\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputEffect = dual<\n  <InDone0, InDone, InErr, Env1>(\n    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n  ) => <OutElem, InElem, OutErr, OutDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr, InDone, InDone0, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: core.fail,\n    onDone: (done) => core.fromEffect(f(done))\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputError = dual<\n  <InErr0, InErr>(\n    f: (a: InErr0) => InErr\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InErr0) => InErr\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InErr0) => InErr\n): Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr0, InDone, InDone> = core.readWith({\n    onInput: (inElem: InElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: (error) => core.fail(f(error)),\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputErrorEffect = dual<\n  <InErr0, InDone, InErr, Env1>(\n    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n  ) => <OutElem, InElem, OutErr, OutDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem, InErr, InErr0, InDone, InDone, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(inElem), () => reader),\n    onFailure: (error) => core.fromEffect(f(error)),\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputIn = dual<\n  <InElem0, InElem>(\n    f: (a: InElem0) => InElem\n  ) => <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InElem0) => InElem\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InElem0) => InElem\n): Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<InElem, InElem0, InErr, InErr, InDone, InDone> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.write(f(inElem)), () => reader),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const mapInputInEffect = dual<\n  <InElem0, InElem, InErr, Env1>(\n    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n  ) => <OutElem, OutErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n  ) => Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>\n): Channel.Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<InElem, InElem0, InErr, InErr, InDone, InDone, Env1> = core.readWith({\n    onInput: (inElem) => core.flatMap(core.flatMap(core.fromEffect(f(inElem)), core.write), () => reader),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n  return core.pipeTo(reader, self)\n})\n\n/** @internal */\nexport const doneCollect = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env> =>\n  core.suspend(() => {\n    const builder: Array<OutElem> = []\n    return pipe(\n      core.pipeTo(self, doneCollectReader<Env, OutErr, OutElem, OutDone>(builder)),\n      core.flatMap((outDone) => core.succeed([Chunk.unsafeFromArray(builder), outDone]))\n    )\n  })\n\n/** @internal */\nconst doneCollectReader = <Env, OutErr, OutElem, OutDone>(\n  builder: Array<OutElem>\n): Channel.Channel<never, OutElem, OutErr, OutErr, OutDone, OutDone, Env> => {\n  return core.readWith({\n    onInput: (outElem) =>\n      core.flatMap(\n        core.sync(() => {\n          builder.push(outElem)\n        }),\n        () => doneCollectReader<Env, OutErr, OutElem, OutDone>(builder)\n      ),\n    onFailure: core.fail,\n    onDone: core.succeed\n  })\n}\n\n/** @internal */\nexport const drain = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const drainer: Channel.Channel<never, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWithCause({\n      onInput: () => drainer,\n      onFailure: core.failCause,\n      onDone: core.succeed\n    })\n  return core.pipeTo(self, drainer)\n}\n\n/** @internal */\nexport const emitCollect = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env> =>\n  core.flatMap(doneCollect(self), core.write)\n\n/** @internal */\nexport const ensuring = dual<\n  <Z, Env1>(\n    finalizer: Effect.Effect<Z, never, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    finalizer: Effect.Effect<Z, never, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, Z>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  finalizer: Effect.Effect<Z, never, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1> =>\n  core.ensuringWith(self, () => finalizer))\n\n/** @internal */\nexport const context = <Env>(): Channel.Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env> =>\n  core.fromEffect(Effect.context<Env>())\n\n/** @internal */\nexport const contextWith = <Env, OutDone>(\n  f: (env: Context.Context<Env>) => OutDone\n): Channel.Channel<never, unknown, never, unknown, OutDone, unknown, Env> => map(context<Env>(), f)\n\n/** @internal */\nexport const contextWithChannel = <\n  Env,\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env1\n>(\n  f: (env: Context.Context<Env>) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1> => core.flatMap(context<Env>(), f)\n\n/** @internal */\nexport const contextWithEffect = <Env, OutDone, OutErr, Env1>(\n  f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>\n): Channel.Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1> => mapEffect(context<Env>(), f)\n\n/** @internal */\nexport const flatten = <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone2,\n  InDone1,\n  Env1,\n  InDone,\n  Env\n>(\n  self: Channel.Channel<\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>,\n    InDone,\n    Env\n  >\n): Channel.Channel<\n  OutElem | OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone2,\n  InDone & InDone1,\n  Env | Env1\n> => core.flatMap(self, identity)\n\n/** @internal */\nexport const foldChannel = dual<\n  <\n    OutErr,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutDone,\n    OutElem2,\n    InElem2,\n    OutErr2,\n    InErr2,\n    OutDone2,\n    InDone2,\n    Env2\n  >(\n    options: {\n      readonly onFailure: (\n        error: OutErr\n      ) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSuccess: (\n        done: OutDone\n      ) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n    }\n  ) => <Env, InErr, InElem, InDone, OutElem>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem2 | OutElem,\n    InElem & InElem1 & InElem2,\n    OutErr1 | OutErr2,\n    InErr & InErr1 & InErr2,\n    OutDone1 | OutDone2,\n    InDone & InDone1 & InDone2,\n    Env1 | Env2 | Env\n  >,\n  <\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutElem2,\n    InElem2,\n    OutErr2,\n    InErr2,\n    OutDone2,\n    InDone2,\n    Env2\n  >(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    options: {\n      readonly onFailure: (\n        error: OutErr\n      ) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSuccess: (\n        done: OutDone\n      ) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem2 | OutElem,\n    InElem & InElem1 & InElem2,\n    OutErr1 | OutErr2,\n    InErr & InErr1 & InErr2,\n    OutDone1 | OutDone2,\n    InDone & InDone1 & InDone2,\n    Env1 | Env2 | Env\n  >\n>(2, <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone1,\n  InDone1,\n  Env1,\n  OutElem2,\n  InElem2,\n  OutErr2,\n  InErr2,\n  OutDone2,\n  InDone2,\n  Env2\n>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  options: {\n    readonly onFailure: (error: OutErr) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n    readonly onSuccess: (done: OutDone) => Channel.Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>\n  }\n): Channel.Channel<\n  OutElem | OutElem2 | OutElem1,\n  InElem & InElem1 & InElem2,\n  OutErr2 | OutErr1,\n  InErr & InErr1 & InErr2,\n  OutDone2 | OutDone1,\n  InDone & InDone1 & InDone2,\n  Env | Env1 | Env2\n> =>\n  core.foldCauseChannel(self, {\n    onFailure: (cause) => {\n      const either = Cause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\": {\n          return options.onFailure(either.left)\n        }\n        case \"Right\": {\n          return core.failCause(either.right)\n        }\n      }\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/** @internal */\nexport const fromEither = <R, L>(\n  either: Either.Either<R, L>\n): Channel.Channel<never, unknown, L, unknown, R, unknown> =>\n  core.suspend(() => Either.match(either, { onLeft: core.fail, onRight: core.succeed }))\n\n/** @internal */\nexport const fromInput = <Err, Elem, Done>(\n  input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  unwrap(\n    input.takeWith(\n      core.failCause,\n      (elem) => core.flatMap(core.write(elem), () => fromInput(input)),\n      core.succeed\n    )\n  )\n\n/** @internal */\nexport const fromPubSub = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  unwrapScoped(Effect.map(PubSub.subscribe(pubsub), fromQueue))\n\n/** @internal */\nexport const fromPubSubScoped = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Effect.Effect<Channel.Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope> =>\n  Effect.map(PubSub.subscribe(pubsub), fromQueue)\n\n/** @internal */\nexport const fromOption = <A>(\n  option: Option.Option<A>\n): Channel.Channel<never, unknown, Option.Option<never>, unknown, A, unknown> =>\n  core.suspend(() =>\n    Option.match(option, {\n      onNone: () => core.fail(Option.none()),\n      onSome: core.succeed\n    })\n  )\n\n/** @internal */\nexport const fromQueue = <Done, Err, Elem>(\n  queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> => core.suspend(() => fromQueueInternal(queue))\n\n/** @internal */\nconst fromQueueInternal = <Done, Err, Elem>(\n  queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<Elem, unknown, Err, unknown, Done, unknown> =>\n  pipe(\n    core.fromEffect(Queue.take(queue)),\n    core.flatMap(Either.match({\n      onLeft: Exit.match({\n        onFailure: core.failCause,\n        onSuccess: core.succeedNow\n      }),\n      onRight: (elem) =>\n        core.flatMap(\n          core.write(elem),\n          () => fromQueueInternal(queue)\n        )\n    }))\n  )\n\n/** @internal */\nexport const identityChannel = <Elem, Err, Done>(): Channel.Channel<Elem, Elem, Err, Err, Done, Done> =>\n  core.readWith({\n    onInput: (input: Elem) => core.flatMap(core.write(input), () => identityChannel()),\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n\n/** @internal */\nexport const interruptWhen = dual<\n  <OutDone1, OutErr1, Env1>(\n    effect: Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    effect: Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  effect: Effect.Effect<OutDone1, OutErr1, Env1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env1 | Env> =>\n  mergeWith(self, {\n    other: core.fromEffect(effect),\n    onSelfDone: (selfDone) => mergeDecision.Done(Effect.suspend(() => selfDone)),\n    onOtherDone: (effectDone) => mergeDecision.Done(Effect.suspend(() => effectDone))\n  }))\n\n/** @internal */\nexport const interruptWhenDeferred = dual<\n  <OutDone1, OutErr1>(\n    deferred: Deferred.Deferred<OutDone1, OutErr1>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    deferred: Deferred.Deferred<OutDone1, OutErr1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, OutErr1, OutDone1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  deferred: Deferred.Deferred<OutDone1, OutErr1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env> =>\n  interruptWhen(self, Deferred.await(deferred)))\n\n/** @internal */\nexport const map = dual<\n  <OutDone, OutDone2>(\n    f: (out: OutDone) => OutDone2\n  ) => <OutElem, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (out: OutDone) => OutDone2\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>\n>(2, <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, OutDone2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (out: OutDone) => OutDone2\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env> =>\n  core.flatMap(self, (a) => core.sync(() => f(a))))\n\n/** @internal */\nexport const mapEffect = dual<\n  <OutDone, OutDone1, OutErr1, Env1>(\n    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => <OutElem, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1> =>\n  core.flatMap(self, (z) => core.fromEffect(f(z))))\n\n/** @internal */\nexport const mapError = dual<\n  <OutErr, OutErr2>(\n    f: (err: OutErr) => OutErr2\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (err: OutErr) => OutErr2\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (err: OutErr) => OutErr2\n): Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env> => mapErrorCause(self, Cause.map(f)))\n\n/** @internal */\nexport const mapErrorCause = dual<\n  <OutErr, OutErr2>(\n    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n  ) => Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>\n): Channel.Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env> =>\n  core.catchAllCause(self, (cause) => core.failCause(f(cause))))\n\n/** @internal */\nexport const mapOut = dual<\n  <OutElem, OutElem2>(\n    f: (o: OutElem) => OutElem2\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => OutElem2\n  ) => Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => OutElem2\n): Channel.Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env> => {\n  const reader: Channel.Channel<OutElem2, OutElem, OutErr, OutErr, OutDone, OutDone, Env> = core\n    .readWith({\n      onInput: (outElem) => core.flatMap(core.write(f(outElem)), () => reader),\n      onFailure: core.fail,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, reader)\n})\n\n/** @internal */\nexport const mapOutEffect = dual<\n  <OutElem, OutElem1, OutErr1, Env1>(\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>\n): Channel.Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1> => {\n  const reader: Channel.Channel<OutElem1, OutElem, OutErr | OutErr1, OutErr, OutDone, OutDone, Env | Env1> = core\n    .readWithCause({\n      onInput: (outElem) =>\n        pipe(\n          core.fromEffect(f(outElem)),\n          core.flatMap(core.write),\n          core.flatMap(() => reader)\n        ),\n      onFailure: core.failCause,\n      onDone: core.succeedNow\n    })\n  return core.pipeTo(self, reader)\n})\n\n/** @internal */\nexport const mapOutEffectPar = dual<\n  <OutElem, OutElem1, OutErr1, Env1>(\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n    n: number\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n    n: number\n  ) => Channel.Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,\n  n: number\n): Channel.Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1> =>\n  pipe(\n    Effect.gen(function*($) {\n      const queue = yield* $(\n        Effect.acquireRelease(\n          Queue.bounded<Effect.Effect<Either.Either<OutElem1, OutDone>, OutErr | OutErr1, Env1>>(n),\n          (queue) => Queue.shutdown(queue)\n        )\n      )\n      const errorSignal = yield* $(Deferred.make<never, OutErr1>())\n      const withPermits = n === Number.POSITIVE_INFINITY ?\n        ((_: number) => identity) :\n        (yield* $(Effect.makeSemaphore(n))).withPermits\n      const pull = yield* $(toPull(self))\n      yield* $(\n        Effect.matchCauseEffect(pull, {\n          onFailure: (cause) => Queue.offer(queue, Effect.failCause(cause)),\n          onSuccess: (either) =>\n            Either.match(\n              either,\n              {\n                onLeft: (outDone) => {\n                  const lock = withPermits(n)\n                  return Effect.zipRight(\n                    Effect.interruptible(lock(Effect.void)),\n                    Effect.asVoid(Queue.offer(\n                      queue,\n                      Effect.succeed(Either.left(outDone))\n                    ))\n                  )\n                },\n                onRight: (outElem) =>\n                  Effect.gen(function*($) {\n                    const deferred = yield* $(Deferred.make<OutElem1, OutErr1>())\n                    const latch = yield* $(Deferred.make<void>())\n                    yield* $(Effect.asVoid(Queue.offer(\n                      queue,\n                      Effect.map(Deferred.await(deferred), Either.right)\n                    )))\n                    yield* $(\n                      Deferred.succeed(latch, void 0),\n                      Effect.zipRight(\n                        pipe(\n                          Effect.uninterruptibleMask((restore) =>\n                            pipe(\n                              Effect.exit(restore(Deferred.await(errorSignal))),\n                              Effect.raceFirst(Effect.exit(restore(f(outElem)))),\n                              // TODO: remove\n                              Effect.flatMap((exit) => Effect.suspend(() => exit))\n                            )\n                          ),\n                          Effect.tapErrorCause((cause) => Deferred.failCause(errorSignal, cause)),\n                          Effect.intoDeferred(deferred)\n                        )\n                      ),\n                      withPermits(1),\n                      Effect.forkScoped\n                    )\n                    yield* $(Deferred.await(latch))\n                  })\n              }\n            )\n        }),\n        Effect.forever,\n        Effect.interruptible,\n        Effect.forkScoped\n      )\n      return queue\n    }),\n    Effect.map((queue) => {\n      const consumer: Channel.Channel<OutElem1, unknown, OutErr | OutErr1, unknown, OutDone, unknown, Env1> = unwrap(\n        Effect.matchCause(Effect.flatten(Queue.take(queue)), {\n          onFailure: core.failCause,\n          onSuccess: Either.match({\n            onLeft: core.succeedNow,\n            onRight: (outElem) => core.flatMap(core.write(outElem), () => consumer)\n          })\n        })\n      )\n      return consumer\n    }),\n    unwrapScoped\n  ))\n\n/** @internal */\nexport const mergeAll = (\n  options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n) => {\n  return <\n    OutElem,\n    InElem1,\n    OutErr1,\n    InErr1,\n    InDone1,\n    Env1,\n    InElem,\n    OutErr,\n    InErr,\n    InDone,\n    Env\n  >(\n    channels: Channel.Channel<\n      Channel.Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      unknown,\n      InDone,\n      Env\n    >\n  ): Channel.Channel<\n    OutElem,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  > => mergeAllWith(options)(channels, constVoid)\n}\n\n/** @internal */\nexport const mergeAllUnbounded = <\n  OutElem,\n  InElem1,\n  OutErr1,\n  InErr1,\n  InDone1,\n  Env1,\n  InElem,\n  OutErr,\n  InErr,\n  InDone,\n  Env\n>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    unknown,\n    InDone,\n    Env\n  >\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: \"unbounded\" })(channels, constVoid)\n\n/** @internal */\nexport const mergeAllUnboundedWith = <\n  OutElem,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone,\n  InDone1,\n  Env1,\n  InElem,\n  OutErr,\n  InErr,\n  InDone,\n  Env\n>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  f: (o1: OutDone, o2: OutDone) => OutDone\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: \"unbounded\" })(channels, f)\n\n/** @internal */\nexport const mergeAllWith = (\n  {\n    bufferSize = 16,\n    concurrency,\n    mergeStrategy = _mergeStrategy.BackPressure()\n  }: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n) =>\n<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n  channels: Channel.Channel<\n    Channel.Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  f: (o1: OutDone, o2: OutDone) => OutDone\n): Channel.Channel<\n  OutElem,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone,\n  InDone & InDone1,\n  Env | Env1\n> =>\n  pipe(\n    Effect.gen(function*($) {\n      const concurrencyN = concurrency === \"unbounded\" ? Number.MAX_SAFE_INTEGER : concurrency\n      const input = yield* $(singleProducerAsyncInput.make<\n        InErr & InErr1,\n        InElem & InElem1,\n        InDone & InDone1\n      >())\n      const queueReader = fromInput(input)\n      const queue = yield* $(\n        Effect.acquireRelease(\n          Queue.bounded<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr | OutErr1, Env>>(bufferSize),\n          (queue) => Queue.shutdown(queue)\n        )\n      )\n      const cancelers = yield* $(\n        Effect.acquireRelease(\n          Queue.unbounded<Deferred.Deferred<void>>(),\n          (queue) => Queue.shutdown(queue)\n        )\n      )\n      const lastDone = yield* $(Ref.make<Option.Option<OutDone>>(Option.none()))\n      const errorSignal = yield* $(Deferred.make<void>())\n      const withPermits = (yield* $(Effect.makeSemaphore(concurrencyN)))\n        .withPermits\n      const pull = yield* $(toPull(channels))\n      const evaluatePull = (\n        pull: Effect.Effect<Either.Either<OutElem, OutDone>, OutErr | OutErr1, Env | Env1>\n      ) =>\n        pipe(\n          Effect.flatMap(\n            pull,\n            Either.match({\n              onLeft: (done) => Effect.succeed(Option.some(done)),\n              onRight: (outElem) =>\n                Effect.as(\n                  Queue.offer(queue, Effect.succeed(Either.right(outElem))),\n                  Option.none()\n                )\n            })\n          ),\n          Effect.repeat({ until: (_): _ is Option.Some<OutDone> => Option.isSome(_) }),\n          Effect.flatMap((outDone) =>\n            Ref.update(\n              lastDone,\n              Option.match({\n                onNone: () => Option.some(outDone.value),\n                onSome: (lastDone) => Option.some(f(lastDone, outDone.value))\n              })\n            )\n          ),\n          Effect.catchAllCause((cause) =>\n            Cause.isInterrupted(cause) ?\n              Effect.failCause(cause) :\n              pipe(\n                Queue.offer(queue, Effect.failCause(cause)),\n                Effect.zipRight(Deferred.succeed(errorSignal, void 0)),\n                Effect.asVoid\n              )\n          )\n        )\n      yield* $(\n        Effect.matchCauseEffect(pull, {\n          onFailure: (cause) =>\n            pipe(\n              Queue.offer(queue, Effect.failCause(cause)),\n              Effect.zipRight(Effect.succeed(false))\n            ),\n          onSuccess: Either.match({\n            onLeft: (outDone) =>\n              Effect.raceWith(\n                Effect.interruptible(Deferred.await(errorSignal)),\n                Effect.interruptible(withPermits(concurrencyN)(Effect.void)),\n                {\n                  onSelfDone: (_, permitAcquisition) => Effect.as(Fiber.interrupt(permitAcquisition), false),\n                  onOtherDone: (_, failureAwait) =>\n                    Effect.zipRight(\n                      Fiber.interrupt(failureAwait),\n                      pipe(\n                        Ref.get(lastDone),\n                        Effect.flatMap(Option.match({\n                          onNone: () => Queue.offer(queue, Effect.succeed(Either.left(outDone))),\n                          onSome: (lastDone) => Queue.offer(queue, Effect.succeed(Either.left(f(lastDone, outDone))))\n                        })),\n                        Effect.as(false)\n                      )\n                    )\n                }\n              ),\n            onRight: (channel) =>\n              _mergeStrategy.match(mergeStrategy, {\n                onBackPressure: () =>\n                  Effect.gen(function*($) {\n                    const latch = yield* $(Deferred.make<void>())\n                    const raceEffects: Effect.Effect<void, OutErr | OutErr1, Env | Env1> = pipe(\n                      queueReader,\n                      core.pipeTo(channel),\n                      toPull,\n                      Effect.flatMap((pull) =>\n                        Effect.race(\n                          evaluatePull(pull),\n                          Effect.interruptible(Deferred.await(errorSignal))\n                        )\n                      ),\n                      Effect.scoped\n                    )\n                    yield* $(\n                      Deferred.succeed(latch, void 0),\n                      Effect.zipRight(raceEffects),\n                      withPermits(1),\n                      Effect.forkScoped\n                    )\n                    yield* $(Deferred.await(latch))\n                    const errored = yield* $(Deferred.isDone(errorSignal))\n                    return !errored\n                  }),\n                onBufferSliding: () =>\n                  Effect.gen(function*($) {\n                    const canceler = yield* $(Deferred.make<void>())\n                    const latch = yield* $(Deferred.make<void>())\n                    const size = yield* $(Queue.size(cancelers))\n                    yield* $(\n                      Queue.take(cancelers),\n                      Effect.flatMap((_) => Deferred.succeed(_, void 0)),\n                      Effect.when(() => size >= concurrencyN)\n                    )\n                    yield* $(Queue.offer(cancelers, canceler))\n                    const raceEffects: Effect.Effect<void, OutErr | OutErr1, Env | Env1> = pipe(\n                      queueReader,\n                      core.pipeTo(channel),\n                      toPull,\n                      Effect.flatMap((pull) =>\n                        pipe(\n                          evaluatePull(pull),\n                          Effect.race(Effect.interruptible(Deferred.await(errorSignal))),\n                          Effect.race(Effect.interruptible(Deferred.await(canceler)))\n                        )\n                      ),\n                      Effect.scoped\n                    )\n                    yield* $(\n                      Deferred.succeed(latch, void 0),\n                      Effect.zipRight(raceEffects),\n                      withPermits(1),\n                      Effect.forkScoped\n                    )\n                    yield* $(Deferred.await(latch))\n                    const errored = yield* $(Deferred.isDone(errorSignal))\n                    return !errored\n                  })\n              })\n          })\n        }),\n        Effect.repeat({ while: (_) => _ }),\n        Effect.forkScoped\n      )\n      return [queue, input] as const\n    }),\n    Effect.map(([queue, input]) => {\n      const consumer: Channel.Channel<OutElem, unknown, OutErr | OutErr1, unknown, OutDone, unknown, Env | Env1> = pipe(\n        Queue.take(queue),\n        Effect.flatten,\n        Effect.matchCause({\n          onFailure: core.failCause,\n          onSuccess: Either.match({\n            onLeft: core.succeedNow,\n            onRight: (outElem) => core.flatMap(core.write(outElem), () => consumer)\n          })\n        }),\n        unwrap\n      )\n      return core.embedInput(consumer, input)\n    }),\n    unwrapScoped\n  )\n\n/** @internal */\nexport const mergeMap = dual<\n  <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n    f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    options: {\n      readonly concurrency: number | \"unbounded\"\n      readonly bufferSize?: number | undefined\n      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n    }\n  ) => <InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    options: {\n      readonly concurrency: number | \"unbounded\"\n      readonly bufferSize?: number | undefined\n      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (outElem: OutElem) => Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n  options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n    readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined\n  }\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAll(options)(mapOut(self, f)))\n\n/** @internal */\nexport const mergeOut = dual<\n  (\n    n: number\n  ) => <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone,\n      InDone,\n      Env\n    >\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  >,\n  <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone,\n      InDone,\n      Env\n    >,\n    n: number\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    unknown,\n    InDone & InDone1,\n    Env | Env1\n  >\n>(2, <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  n: number\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  unknown,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAll({ concurrency: n })(mapOut(self, identity)))\n\n/** @internal */\nexport const mergeOutWith = dual<\n  <OutDone1>(\n    n: number,\n    f: (o1: OutDone1, o2: OutDone1) => OutDone1\n  ) => <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone1,\n      InDone,\n      Env\n    >\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  >,\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<\n      Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n      InElem,\n      OutErr,\n      InErr,\n      OutDone1,\n      InDone,\n      Env\n    >,\n    n: number,\n    f: (o1: OutDone1, o2: OutDone1) => OutDone1\n  ) => Channel.Channel<\n    OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  >\n>(3, <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(\n  self: Channel.Channel<\n    Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone1,\n    InDone,\n    Env\n  >,\n  n: number,\n  f: (o1: OutDone1, o2: OutDone1) => OutDone1\n): Channel.Channel<\n  OutElem1,\n  InElem & InElem1,\n  OutErr | OutErr1,\n  InErr & InErr1,\n  OutDone1,\n  InDone & InDone1,\n  Env | Env1\n> => mergeAllWith({ concurrency: n })(mapOut(self, identity), f))\n\n/** @internal */\nexport const mergeWith = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(\n    options: {\n      readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSelfDone: (\n        exit: Exit.Exit<OutDone, OutErr>\n      ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n      readonly onOtherDone: (\n        ex: Exit.Exit<OutDone1, OutErr1>\n      ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n    }\n  ) => <Env, InErr, InElem, InDone, OutElem>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr2 | OutErr3,\n    InErr & InErr1,\n    OutDone2 | OutDone3,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env,\n    OutElem1,\n    InElem1,\n    OutErr1,\n    InErr1,\n    OutDone1,\n    InDone1,\n    Env1,\n    OutErr2,\n    OutDone2,\n    OutErr3,\n    OutDone3\n  >(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    options: {\n      readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n      readonly onSelfDone: (\n        exit: Exit.Exit<OutDone, OutErr>\n      ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n      readonly onOtherDone: (\n        ex: Exit.Exit<OutDone1, OutErr1>\n      ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr2 | OutErr3,\n    InErr & InErr1,\n    OutDone2 | OutDone3,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(2, <\n  OutElem,\n  InElem,\n  OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  Env,\n  OutElem1,\n  InElem1,\n  OutErr1,\n  InErr1,\n  OutDone1,\n  InDone1,\n  Env1,\n  OutErr2,\n  OutDone2,\n  OutErr3,\n  OutDone3\n>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  options: {\n    readonly other: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>\n    readonly onSelfDone: (\n      exit: Exit.Exit<OutDone, OutErr>\n    ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>\n    readonly onOtherDone: (\n      ex: Exit.Exit<OutDone1, OutErr1>\n    ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>\n  }\n): Channel.Channel<\n  OutElem | OutElem1,\n  InElem & InElem1,\n  OutErr2 | OutErr3,\n  InErr & InErr1,\n  OutDone2 | OutDone3,\n  InDone & InDone1,\n  Env1 | Env\n> =>\n  unwrapScoped(\n    Effect.flatMap(\n      singleProducerAsyncInput.make<\n        InErr & InErr1,\n        InElem & InElem1,\n        InDone & InDone1\n      >(),\n      (input) => {\n        const queueReader = fromInput(input)\n        return Effect.map(\n          Effect.all([\n            toPull(core.pipeTo(queueReader, self)),\n            toPull(core.pipeTo(queueReader, options.other)),\n            Effect.scope\n          ]),\n          ([pullL, pullR, scope]) => {\n            type State = MergeState.MergeState<\n              Env | Env1,\n              OutErr,\n              OutErr1,\n              OutErr2 | OutErr3,\n              OutElem | OutElem1,\n              OutDone,\n              OutDone1,\n              OutDone2 | OutDone3\n            >\n\n            const handleSide = <Err, Done, Err2, Done2>(\n              exit: Exit.Exit<Either.Either<OutElem | OutElem1, Done>, Err>,\n              fiber: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done2>, Err2>,\n              pull: Effect.Effect<Either.Either<OutElem | OutElem1, Done>, Err, Env | Env1>\n            ) =>\n            (\n              done: (\n                ex: Exit.Exit<Done, Err>\n              ) => MergeDecision.MergeDecision<\n                Env | Env1,\n                Err2,\n                Done2,\n                OutErr2 | OutErr3,\n                OutDone2 | OutDone3\n              >,\n              both: (\n                f1: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done>, Err>,\n                f2: Fiber.Fiber<Either.Either<OutElem | OutElem1, Done2>, Err2>\n              ) => State,\n              single: (\n                f: (\n                  ex: Exit.Exit<Done2, Err2>\n                ) => Effect.Effect<OutDone2 | OutDone3, OutErr2 | OutErr3, Env | Env1>\n              ) => State\n            ): Effect.Effect<\n              Channel.Channel<\n                OutElem | OutElem1,\n                unknown,\n                OutErr2 | OutErr3,\n                unknown,\n                OutDone2 | OutDone3,\n                unknown,\n                Env | Env1\n              >,\n              never,\n              Env | Env1\n            > => {\n              const onDecision = (\n                decision: MergeDecision.MergeDecision<\n                  Env | Env1,\n                  Err2,\n                  Done2,\n                  OutErr2 | OutErr3,\n                  OutDone2 | OutDone3\n                >\n              ): Effect.Effect<\n                Channel.Channel<\n                  OutElem | OutElem1,\n                  unknown,\n                  OutErr2 | OutErr3,\n                  unknown,\n                  OutDone2 | OutDone3,\n                  unknown,\n                  Env | Env1\n                >\n              > => {\n                const op = decision as mergeDecision.Primitive\n                if (op._tag === MergeDecisionOpCodes.OP_DONE) {\n                  return Effect.succeed(\n                    core.fromEffect(\n                      Effect.zipRight(\n                        Fiber.interrupt(fiber),\n                        op.effect\n                      )\n                    )\n                  )\n                }\n                return Effect.map(\n                  Fiber.await(fiber),\n                  Exit.match({\n                    onFailure: (cause) => core.fromEffect(op.f(Exit.failCause(cause))),\n                    onSuccess: Either.match({\n                      onLeft: (done) => core.fromEffect(op.f(Exit.succeed(done))),\n                      onRight: (elem) => zipRight(core.write(elem), go(single(op.f)))\n                    })\n                  })\n                )\n              }\n\n              return Exit.match(exit, {\n                onFailure: (cause) => onDecision(done(Exit.failCause(cause))),\n                onSuccess: Either.match({\n                  onLeft: (z) => onDecision(done(Exit.succeed(z))),\n                  onRight: (elem) =>\n                    Effect.succeed(\n                      core.flatMap(core.write(elem), () =>\n                        core.flatMap(\n                          core.fromEffect(Effect.forkDaemon(pull)),\n                          (leftFiber) => go(both(leftFiber, fiber))\n                        ))\n                    )\n                })\n              })\n            }\n\n            const go = (\n              state: State\n            ): Channel.Channel<\n              OutElem | OutElem1,\n              unknown,\n              OutErr2 | OutErr3,\n              unknown,\n              OutDone2 | OutDone3,\n              unknown,\n              Env | Env1\n            > => {\n              switch (state._tag) {\n                case MergeStateOpCodes.OP_BOTH_RUNNING: {\n                  const leftJoin = Effect.interruptible(Fiber.join(state.left))\n                  const rightJoin = Effect.interruptible(Fiber.join(state.right))\n                  return unwrap(\n                    Effect.raceWith(leftJoin, rightJoin, {\n                      onSelfDone: (leftExit, rf) =>\n                        Effect.zipRight(\n                          Fiber.interrupt(rf),\n                          handleSide(leftExit, state.right, pullL)(\n                            options.onSelfDone,\n                            mergeState.BothRunning,\n                            (f) => mergeState.LeftDone(f)\n                          )\n                        ),\n                      onOtherDone: (rightExit, lf) =>\n                        Effect.zipRight(\n                          Fiber.interrupt(lf),\n                          handleSide(rightExit, state.left, pullR)(\n                            options.onOtherDone as (\n                              ex: Exit.Exit<OutDone1, InErr1 | OutErr1>\n                            ) => MergeDecision.MergeDecision<\n                              Env1 | Env,\n                              OutErr,\n                              OutDone,\n                              OutErr2 | OutErr3,\n                              OutDone2 | OutDone3\n                            >,\n                            (left, right) => mergeState.BothRunning(right, left),\n                            (f) => mergeState.RightDone(f)\n                          )\n                        )\n                    })\n                  )\n                }\n                case MergeStateOpCodes.OP_LEFT_DONE: {\n                  return unwrap(\n                    Effect.map(\n                      Effect.exit(pullR),\n                      Exit.match({\n                        onFailure: (cause) => core.fromEffect(state.f(Exit.failCause(cause))),\n                        onSuccess: Either.match({\n                          onLeft: (done) => core.fromEffect(state.f(Exit.succeed(done))),\n                          onRight: (elem) =>\n                            core.flatMap(\n                              core.write(elem),\n                              () => go(mergeState.LeftDone(state.f))\n                            )\n                        })\n                      })\n                    )\n                  )\n                }\n                case MergeStateOpCodes.OP_RIGHT_DONE: {\n                  return unwrap(\n                    Effect.map(\n                      Effect.exit(pullL),\n                      Exit.match({\n                        onFailure: (cause) => core.fromEffect(state.f(Exit.failCause(cause))),\n                        onSuccess: Either.match({\n                          onLeft: (done) => core.fromEffect(state.f(Exit.succeed(done))),\n                          onRight: (elem) =>\n                            core.flatMap(\n                              core.write(elem),\n                              () => go(mergeState.RightDone(state.f))\n                            )\n                        })\n                      })\n                    )\n                  )\n                }\n              }\n            }\n\n            return pipe(\n              core.fromEffect(\n                Effect.zipWith(\n                  Effect.forkIn(pullL, scope),\n                  Effect.forkIn(pullR, scope),\n                  (left, right): State =>\n                    mergeState.BothRunning<\n                      Env | Env1,\n                      OutErr,\n                      OutErr1,\n                      OutErr2 | OutErr3,\n                      OutElem | OutElem1,\n                      OutDone,\n                      OutDone1,\n                      OutDone2 | OutDone3\n                    >(left, right)\n                )\n              ),\n              core.flatMap(go),\n              core.embedInput(input)\n            )\n          }\n        )\n      }\n    )\n  ))\n\n/** @internal */\nexport const never: Channel.Channel<never, unknown, never, unknown, never, unknown> = core.fromEffect(\n  Effect.never\n)\n\n/** @internal */\nexport const orDie = dual<\n  <E>(\n    error: LazyArg<E>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    error: LazyArg<E>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  error: LazyArg<E>\n): Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env> => orDieWith(self, error))\n\n/** @internal */\nexport const orDieWith = dual<\n  <OutErr>(\n    f: (e: OutErr) => unknown\n  ) => <OutElem, InElem, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (e: OutErr) => unknown\n  ) => Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (e: OutErr) => unknown\n): Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env> =>\n  catchAll(self, (e) => {\n    throw f(e)\n  }) as Channel.Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>)\n\n/** @internal */\nexport const orElse = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone1 | OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  2,\n  <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: LazyArg<Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr1,\n    InErr & InErr1,\n    OutDone | OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > => catchAll(self, that)\n)\n\n/** @internal */\nexport const pipeToOrFail = dual<\n  <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(\n    that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n  ) => <InElem, OutErr, InErr, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n  ) => Channel.Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  that: Channel.Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>\n): Channel.Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2> =>\n  core.suspend(() => {\n    let channelException: Channel.ChannelException<OutErr | OutErr2> | undefined = undefined\n\n    const reader: Channel.Channel<OutElem, OutElem, never, OutErr, OutDone, OutDone, Env> = core\n      .readWith({\n        onInput: (outElem) => core.flatMap(core.write(outElem), () => reader),\n        onFailure: (outErr) => {\n          channelException = ChannelException(outErr)\n          return core.failCause(Cause.die(channelException))\n        },\n        onDone: core.succeedNow\n      })\n\n    const writer: Channel.Channel<\n      OutElem2,\n      OutElem2,\n      OutErr2,\n      OutErr2,\n      OutDone2,\n      OutDone2,\n      Env2\n    > = core.readWithCause({\n      onInput: (outElem) => pipe(core.write(outElem), core.flatMap(() => writer)),\n      onFailure: (cause) =>\n        Cause.isDieType(cause) &&\n          isChannelException(cause.defect) &&\n          Equal.equals(cause.defect, channelException)\n          ? core.fail(cause.defect.error as OutErr2)\n          : core.failCause(cause),\n      onDone: core.succeedNow\n    })\n\n    return core.pipeTo(core.pipeTo(core.pipeTo(self, reader), that), writer)\n  }))\n\n/** @internal */\nexport const provideService = dual<\n  <T extends Context.Tag<any, any>>(\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Context.Tag.Identifier<T>>>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, T extends Context.Tag<any, any>>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Context.Tag.Identifier<T>>>\n>(3, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, T extends Context.Tag<any, any>>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  tag: T,\n  service: Context.Tag.Service<T>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Context.Tag.Identifier<T>>> => {\n  return core.flatMap(\n    context<any>(),\n    (context) => core.provideContext(self, Context.add(context, tag, service))\n  )\n})\n\n/** @internal */\nexport const provideLayer = dual<\n  <Env, OutErr2, Env0>(\n    layer: Layer.Layer<Env, OutErr2, Env0>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    layer: Layer.Layer<Env, OutErr2, Env0>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  layer: Layer.Layer<Env, OutErr2, Env0>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0> =>\n  unwrapScoped(Effect.map(Layer.build(layer), (env) => core.provideContext(self, env))))\n\n/** @internal */\nexport const mapInputContext = dual<\n  <Env0, Env>(\n    f: (env: Context.Context<Env0>) => Context.Context<Env>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    f: (env: Context.Context<Env0>) => Context.Context<Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n  f: (env: Context.Context<Env0>) => Context.Context<Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0> =>\n  contextWithChannel((context: Context.Context<Env0>) => core.provideContext(self, f(context))))\n\n/** @internal */\nexport const provideSomeLayer = dual<\n  <R2, OutErr2, Env0>(\n    layer: Layer.Layer<R2, OutErr2, Env0>\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>,\n    layer: Layer.Layer<R2, OutErr2, Env0>\n  ) => Channel.Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>\n>(2, <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>,\n  layer: Layer.Layer<R2, OutErr2, Env0>\n): Channel.Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>> =>\n  // @ts-expect-error\n  provideLayer(self, Layer.merge(Layer.context<Exclude<R, R2>>(), layer)))\n\n/** @internal */\nexport const read = <In>(): Channel.Channel<never, In, Option.Option<never>, unknown, In, unknown> =>\n  core.readOrFail<Option.Option<never>, In>(Option.none())\n\n/** @internal */\nexport const repeated = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env> => core.flatMap(self, () => repeated(self))\n\n/** @internal */\nexport const run = <OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Exclude<Env, Scope.Scope>> => Effect.scoped(executor.runScoped(self))\n\n/** @internal */\nexport const runCollect = <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Exclude<Env, Scope.Scope>> =>\n  executor.run(core.collectElements(self))\n\n/** @internal */\nexport const runDrain = <OutElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<OutDone, OutErr, Exclude<Env, Scope.Scope>> => executor.run(drain(self))\n\n/** @internal */\nexport const scoped = <A, E, R>(\n  effect: Effect.Effect<A, E, R>\n): Channel.Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>> =>\n  unwrap(\n    Effect.uninterruptibleMask((restore) =>\n      Effect.map(Scope.make(), (scope) =>\n        core.acquireReleaseOut(\n          Effect.tapErrorCause(\n            restore(Scope.extend(effect, scope)),\n            (cause) => Scope.close(scope, Exit.failCause(cause))\n          ),\n          (_, exit) => Scope.close(scope, exit)\n        ))\n    )\n  )\n\n/** @internal */\nexport const service = <T extends Context.Tag<any, any>>(\n  tag: T\n): Channel.Channel<never, unknown, never, unknown, Context.Tag.Service<T>, unknown, Context.Tag.Identifier<T>> =>\n  core.fromEffect(tag)\n\n/** @internal */\nexport const serviceWith = <T extends Context.Tag<any, any>>(tag: T) =>\n<OutDone>(\n  f: (resource: Context.Tag.Service<T>) => OutDone\n): Channel.Channel<never, unknown, never, unknown, OutDone, unknown, Context.Tag.Identifier<T>> => map(service(tag), f)\n\n/** @internal */\nexport const serviceWithChannel =\n  <T extends Context.Tag<any, any>>(tag: T) =>\n  <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(\n    f: (resource: Context.Tag.Service<T>) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Context.Tag.Identifier<T>> =>\n    core.flatMap(service(tag), f)\n\n/** @internal */\nexport const serviceWithEffect = <T extends Context.Tag<any, any>>(tag: T) =>\n<Env, OutErr, OutDone>(\n  f: (resource: Context.Tag.Service<T>) => Effect.Effect<OutDone, OutErr, Env>\n): Channel.Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Context.Tag.Identifier<T>> =>\n  mapEffect(service(tag), f)\n\n/** @internal */\nexport const splitLines = <Err, Done>(): Channel.Channel<\n  Chunk.Chunk<string>,\n  Chunk.Chunk<string>,\n  Err,\n  Err,\n  Done,\n  Done,\n  never\n> =>\n  core.suspend(() => {\n    let stringBuilder = \"\"\n    let midCRLF = false\n    const splitLinesChunk = (chunk: Chunk.Chunk<string>): Chunk.Chunk<string> => {\n      const chunkBuilder: Array<string> = []\n      Chunk.map(chunk, (str) => {\n        if (str.length !== 0) {\n          let from = 0\n          let indexOfCR = str.indexOf(\"\\r\")\n          let indexOfLF = str.indexOf(\"\\n\")\n          if (midCRLF) {\n            if (indexOfLF === 0) {\n              chunkBuilder.push(stringBuilder)\n              stringBuilder = \"\"\n              from = 1\n              indexOfLF = str.indexOf(\"\\n\", from)\n            } else {\n              stringBuilder = stringBuilder + \"\\r\"\n            }\n            midCRLF = false\n          }\n          while (indexOfCR !== -1 || indexOfLF !== -1) {\n            if (indexOfCR === -1 || (indexOfLF !== -1 && indexOfLF < indexOfCR)) {\n              if (stringBuilder.length === 0) {\n                chunkBuilder.push(str.substring(from, indexOfLF))\n              } else {\n                chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF))\n                stringBuilder = \"\"\n              }\n              from = indexOfLF + 1\n              indexOfLF = str.indexOf(\"\\n\", from)\n            } else {\n              if (str.length === indexOfCR + 1) {\n                midCRLF = true\n                indexOfCR = -1\n              } else {\n                if (indexOfLF === indexOfCR + 1) {\n                  if (stringBuilder.length === 0) {\n                    chunkBuilder.push(str.substring(from, indexOfCR))\n                  } else {\n                    stringBuilder = stringBuilder + str.substring(from, indexOfCR)\n                    chunkBuilder.push(stringBuilder)\n                    stringBuilder = \"\"\n                  }\n                  from = indexOfCR + 2\n                  indexOfCR = str.indexOf(\"\\r\", from)\n                  indexOfLF = str.indexOf(\"\\n\", from)\n                } else {\n                  indexOfCR = str.indexOf(\"\\r\", indexOfCR + 1)\n                }\n              }\n            }\n          }\n          if (midCRLF) {\n            stringBuilder = stringBuilder + str.substring(from, str.length - 1)\n          } else {\n            stringBuilder = stringBuilder + str.substring(from, str.length)\n          }\n        }\n      })\n      return Chunk.unsafeFromArray(chunkBuilder)\n    }\n    const loop: Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never> = core\n      .readWithCause({\n        onInput: (input: Chunk.Chunk<string>) => {\n          const out = splitLinesChunk(input)\n          return Chunk.isEmpty(out)\n            ? loop\n            : core.flatMap(core.write(out), () => loop)\n        },\n        onFailure: (cause) =>\n          stringBuilder.length === 0\n            ? core.failCause(cause)\n            : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.failCause(cause)),\n        onDone: (done) =>\n          stringBuilder.length === 0\n            ? core.succeed(done)\n            : core.flatMap(core.write(Chunk.of(stringBuilder)), () => core.succeed(done))\n      })\n    return loop\n  })\n\n/** @internal */\nexport const toPubSub = <Done, Err, Elem>(\n  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => toQueue(pubsub)\n\n/** @internal */\nexport const toPull = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n  self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env | Scope.Scope> =>\n  Effect.map(\n    Effect.acquireRelease(\n      Effect.sync(() => new executor.ChannelExecutor(self, void 0, identity)),\n      (exec, exit) => {\n        const finalize = exec.close(exit)\n        return finalize === undefined ? Effect.void : finalize\n      }\n    ),\n    (exec) => Effect.suspend(() => interpretToPull(exec.run() as ChannelState.ChannelState<OutErr, Env>, exec))\n  )\n\n/** @internal */\nconst interpretToPull = <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(\n  channelState: ChannelState.ChannelState<OutErr, Env>,\n  exec: executor.ChannelExecutor<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n): Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env> => {\n  const state = channelState as ChannelState.Primitive\n  switch (state._tag) {\n    case ChannelStateOpCodes.OP_DONE: {\n      return Exit.match(exec.getDone(), {\n        onFailure: Effect.failCause,\n        onSuccess: (done): Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env> =>\n          Effect.succeed(Either.left(done))\n      })\n    }\n    case ChannelStateOpCodes.OP_EMIT: {\n      return Effect.succeed(Either.right(exec.getEmit()))\n    }\n    case ChannelStateOpCodes.OP_FROM_EFFECT: {\n      return pipe(\n        state.effect as Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>,\n        Effect.flatMap(() => interpretToPull(exec.run() as ChannelState.ChannelState<OutErr, Env>, exec))\n      )\n    }\n    case ChannelStateOpCodes.OP_READ: {\n      return executor.readUpstream(\n        state,\n        () => interpretToPull(exec.run() as ChannelState.ChannelState<OutErr, Env>, exec),\n        (cause) => Effect.failCause(cause) as Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>\n      )\n    }\n  }\n}\n\n/** @internal */\nexport const toQueue = <Done, Err, Elem>(\n  queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => core.suspend(() => toQueueInternal(queue))\n\n/** @internal */\nconst toQueueInternal = <Err, Done, Elem>(\n  queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>\n): Channel.Channel<never, Elem, never, Err, unknown, Done> => {\n  return core.readWithCause({\n    onInput: (elem) =>\n      core.flatMap(\n        core.fromEffect(Queue.offer(queue, Either.right(elem))),\n        () => toQueueInternal(queue)\n      ),\n    onFailure: (cause) => core.fromEffect(pipe(Queue.offer(queue, Either.left(Exit.failCause(cause))))),\n    onDone: (done) => core.fromEffect(pipe(Queue.offer(queue, Either.left(Exit.succeed(done)))))\n  })\n}\n\n/** @internal */\nexport const unwrap = <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(\n  channel: Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2> => flatten(core.fromEffect(channel))\n\n/** @internal */\nexport const unwrapScoped = <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(\n  self: Effect.Effect<Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>\n): Channel.Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>> =>\n  core.concatAllWith(\n    scoped(self),\n    (d, _) => d,\n    (d, _) => d\n  )\n\n/** @internal */\nexport const updateService = dual<\n  <T extends Context.Tag<any, any>>(\n    tag: T,\n    f: (resource: Context.Tag.Service<T>) => Context.Tag.Service<T>\n  ) => <OutElem, OutErr, InErr, OutDone, InDone, R>(\n    self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>\n  ) => Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, T | R>,\n  <OutElem, OutErr, InErr, OutDone, InDone, R, T extends Context.Tag<any, any>>(\n    self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>,\n    tag: T,\n    f: (resource: Context.Tag.Service<T>) => Context.Tag.Service<T>\n  ) => Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, T | R>\n>(3, <OutElem, OutErr, InErr, OutDone, InDone, R, T extends Context.Tag<any, any>>(\n  self: Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>,\n  tag: T,\n  f: (resource: Context.Tag.Service<T>) => Context.Tag.Service<T>\n): Channel.Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R | T> =>\n  mapInputContext(self, (context: Context.Context<R>) =>\n    Context.merge(\n      context,\n      Context.make(tag, f(Context.unsafeGet(context, tag)))\n    )))\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions\n  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    name: string,\n    options?: Tracer.SpanOptions\n  ): Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  const acquire = Effect.all([\n    Effect.makeSpan(name, options),\n    Effect.context(),\n    Effect.clock,\n    FiberRef.get(FiberRef.currentTracerTimingEnabled)\n  ])\n  if (dataFirst) {\n    const self = arguments[0]\n    return acquireUseRelease(\n      acquire,\n      ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)),\n      ([span, , clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled)\n    )\n  }\n  return (self: Channel.Channel<any>) =>\n    acquireUseRelease(\n      acquire,\n      ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)),\n      ([span, , clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled)\n    )\n} as any\n\n/** @internal */\nexport const writeAll = <OutElem>(\n  ...outs: Array<OutElem>\n): Channel.Channel<OutElem> => writeChunk(Chunk.fromIterable(outs))\n\n/** @internal */\nexport const writeChunk = <OutElem>(\n  outs: Chunk.Chunk<OutElem>\n): Channel.Channel<OutElem> => writeChunkWriter(0, outs.length, outs)\n\n/** @internal */\nconst writeChunkWriter = <OutElem>(\n  idx: number,\n  len: number,\n  chunk: Chunk.Chunk<OutElem>\n): Channel.Channel<OutElem> => {\n  return idx === len\n    ? core.void\n    : pipe(\n      core.write(pipe(chunk, Chunk.unsafeGet(idx))),\n      core.flatMap(() => writeChunkWriter(idx + 1, len, chunk))\n    )\n}\n\n/** @internal */\nexport const zip = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    readonly [OutDone, OutDone1],\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      mergeWith(self, {\n        other: that,\n        onSelfDone: (exit1) => mergeDecision.Await((exit2) => Effect.suspend(() => Exit.zip(exit1, exit2))),\n        onOtherDone: (exit2) => mergeDecision.Await((exit1) => Effect.suspend(() => Exit.zip(exit1, exit2)))\n      }) :\n      core.flatMap(self, (a) => map(that, (b) => [a, b] as const))\n)\n\n/** @internal */\nexport const zipLeft = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      map(zip(self, that, { concurrent: true }), (tuple) => tuple[0]) :\n      core.flatMap(self, (z) => as(that, z))\n)\n\n/** @internal */\nexport const zipRight = dual<\n  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env1 | Env\n  >,\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Channel.Channel<\n    OutElem1 | OutElem,\n    InElem & InElem1,\n    OutErr1 | OutErr,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env1 | Env\n  >\n>(\n  (args) => core.isChannel(args[1]),\n  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(\n    self: Channel.Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,\n    that: Channel.Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Channel.Channel<\n    OutElem | OutElem1,\n    InElem & InElem1,\n    OutErr | OutErr1,\n    InErr & InErr1,\n    OutDone1,\n    InDone & InDone1,\n    Env | Env1\n  > =>\n    options?.concurrent ?\n      map(zip(self, that, { concurrent: true }), (tuple) => tuple[1]) :\n      core.flatMap(self, () => that)\n)\n\n/** @internal */\nexport const ChannelExceptionTypeId: Channel.ChannelExceptionTypeId = Symbol.for(\n  \"effect/Channel/ChannelException\"\n) as Channel.ChannelExceptionTypeId\n\n/** @internal */\nexport const ChannelException = <E>(error: E): Channel.ChannelException<E> => ({\n  _tag: \"ChannelException\",\n  [ChannelExceptionTypeId]: ChannelExceptionTypeId,\n  error\n})\n\n/** @internal */\nexport const isChannelException = (u: unknown): u is Channel.ChannelException<unknown> =>\n  hasProperty(u, ChannelExceptionTypeId)\n"],"names":["Cause","Chunk","Context","Deferred","Effect","Either","Equal","Exit","Fiber","FiberRef","constVoid","dual","identity","pipe","Layer","Option","hasProperty","PubSub","Queue","Ref","Scope","executor","mergeDecision","mergeState","_mergeStrategy","singleProducerAsyncInput","coreEffect","core","MergeDecisionOpCodes","MergeStateOpCodes","ChannelStateOpCodes","tracer","acquireUseRelease","acquire","use","release","flatMap","fromEffect","make","void","ref","uninterruptible","tap","a","set","exit","ensuringWith","get","f","as","self","value","map","asVoid","buffer","options","suspend","doBuffer","empty","isEmpty","unwrap","modify","inElem","readWith","onInput","input","write","onFailure","error","fail","onDone","done","succeedNow","bufferChunk","catchAll","catchAllCause","cause","match","failureOrCause","onLeft","onRight","failCause","concatMap","concatMapWith","collect","pf","collector","out","onNone","onSome","out2","pipeTo","concatOut","concatAll","mapInput","reader","mapInputEffect","mapInputError","mapInputErrorEffect","mapInputIn","mapInputInEffect","doneCollect","builder","doneCollectReader","outDone","succeed","unsafeFromArray","outElem","sync","push","drain","drainer","readWithCause","emitCollect","ensuring","finalizer","context","contextWith","contextWithChannel","contextWithEffect","mapEffect","flatten","foldChannel","foldCauseChannel","either","_tag","left","right","onSuccess","fromEither","fromInput","takeWith","elem","fromPubSub","pubsub","unwrapScoped","subscribe","fromQueue","fromPubSubScoped","fromOption","option","none","queue","fromQueueInternal","take","identityChannel","interruptWhen","effect","mergeWith","other","onSelfDone","selfDone","Done","onOtherDone","effectDone","interruptWhenDeferred","deferred","await","z","mapError","mapErrorCause","mapOut","mapOutEffect","mapOutEffectPar","n","gen","$","acquireRelease","bounded","shutdown","errorSignal","withPermits","Number","POSITIVE_INFINITY","_","makeSemaphore","pull","toPull","matchCauseEffect","offer","lock","zipRight","interruptible","latch","uninterruptibleMask","restore","raceFirst","tapErrorCause","intoDeferred","forkScoped","forever","consumer","matchCause","mergeAll","channels","mergeAllWith","mergeAllUnbounded","concurrency","mergeAllUnboundedWith","bufferSize","mergeStrategy","BackPressure","concurrencyN","MAX_SAFE_INTEGER","queueReader","cancelers","unbounded","lastDone","evaluatePull","some","repeat","until","isSome","update","isInterrupted","raceWith","permitAcquisition","interrupt","failureAwait","channel","onBackPressure","raceEffects","race","scoped","errored","isDone","onBufferSliding","canceler","size","when","while","embedInput","mergeMap","mergeOut","mergeOutWith","all","scope","pullL","pullR","handleSide","fiber","both","single","onDecision","decision","op","OP_DONE","go","forkDaemon","leftFiber","state","OP_BOTH_RUNNING","leftJoin","join","rightJoin","leftExit","rf","BothRunning","LeftDone","rightExit","lf","RightDone","OP_LEFT_DONE","OP_RIGHT_DONE","zipWith","forkIn","never","orDie","orDieWith","e","orElse","that","pipeToOrFail","channelException","undefined","outErr","ChannelException","die","writer","isDieType","isChannelException","defect","equals","provideService","tag","service","provideContext","add","provideLayer","layer","build","env","mapInputContext","provideSomeLayer","merge","read","readOrFail","repeated","run","runScoped","runCollect","collectElements","runDrain","acquireReleaseOut","extend","close","serviceWith","serviceWithChannel","serviceWithEffect","splitLines","stringBuilder","midCRLF","splitLinesChunk","chunk","chunkBuilder","str","length","from","indexOfCR","indexOf","indexOfLF","substring","loop","of","toPubSub","toQueue","ChannelExecutor","exec","finalize","interpretToPull","channelState","getDone","OP_EMIT","getEmit","OP_FROM_EFFECT","OP_READ","readUpstream","toQueueInternal","concatAllWith","d","updateService","unsafeGet","withSpan","dataFirst","arguments","name","addSpanStackTrace","makeSpan","clock","currentTracerTimingEnabled","span","spanTag","timingEnabled","endSpan","writeAll","outs","writeChunk","fromIterable","writeChunkWriter","idx","len","zip","args","isChannel","concurrent","exit1","Await","exit2","b","zipLeft","tuple","ChannelExceptionTypeId","Symbol","for","u"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAO,KAAK2B,IAAI,MAAM,kBAAkB;AAXxC,OAAO,KAAKR,GAAG,MAAM,WAAW;AAhBhC,OAAO,KAAKf,MAAM,MAAM,cAAc;AAMtC,SAASM,SAAS,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,IAAI,QAAQ,gBAAgB;AAThE,OAAO,KAAKZ,KAAK,MAAM,aAAa;AAIpC,OAAO,KAAKI,MAAM,MAAM,cAAc;AANtC,OAAO,KAAKL,KAAK,MAAM,aAAa;AAiBpC,OAAO,KAAKe,MAAM,MAAM,cAAc;AAEtC,OAAO,KAAKE,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,KAAK,MAAM,aAAa;AAZpC,OAAO,KAAKX,IAAI,MAAM,YAAY;AAmBlC,OAAO,KAAKe,aAAa,MAAM,4BAA4B;AAvB3D,OAAO,KAAKnB,QAAQ,MAAM,gBAAgB;AAyB1C,OAAO,KAAKqB,cAAc,MAAM,4BAA4B;AAC5D,OAAO,KAAKC,wBAAwB,MAAM,uCAAuC;AArBjF,OAAO,KAAKjB,KAAK,MAAM,aAAa;AAwBpC,OAAO,KAAKoB,oBAAoB,MAAM,mCAAmC;AACzE,OAAO,KAAKC,iBAAiB,MAAM,gCAAgC;AANnE,OAAO,KAAKN,UAAU,MAAM,yBAAyB;AArBrD,OAAO,KAAKjB,KAAK,MAAM,aAAa;AAJpC,OAAO,KAAKJ,OAAO,MAAM,eAAe;AAUxC,OAAO,KAAKY,KAAK,MAAM,aAAa;AAYpC,OAAO,KAAKO,QAAQ,MAAM,8BAA8B;AAHxD,OAAO,KAAKD,KAAK,MAAM,aAAa;AAapC,OAAO,KAAKU,mBAAmB,MAAM,2BAA2B;AAChE,OAAO,KAAKC,MAAM,MAAM,aAAa;AA1BrC,OAAO,KAAKtB,QAAQ,MAAM,gBAAgB;AAqB1C,OAAO,KAAKiB,UAAU,MAAM,kBAAkB;AAb9C,SAASV,WAAW,QAAwB,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBtD,MAAMgB,iBAAiB,GAAGA,CAC/BC,OAA6C,EAC7CC,GAA4F,EAC5FC,OAA0F,GAE1FR,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACU,UAAU,CACblB,GAAG,gMAACmB,IAAI,CAEN,IAAMlC,MAAM,gMAACmC,IAAI,CAAC,CACrB,GACAC,GAAG,+MACF3B,OAAI,AAAJA,EACEc,IAAI,sNAACU,UAAU,CACbjC,MAAM,gMAACqC,eAAe,CACpBrC,MAAM,gMAACsC,GAAG,CACRT,OAAO,GACNU,CAAC,GAAKxB,GAAG,gMAACyB,GAAG,CAACJ,GAAG,GAAGK,IAAI,GAAKV,OAAO,CAACQ,CAAC,EAAEE,IAAI,CAAC,CAAC,CAChD,CACF,CACF,EACDlB,IAAI,sNAACS,OAAO,CAACF,GAAG,CAAC,EACjBP,IAAI,sNAACmB,YAAY,EAAED,IAAI,GAAKzC,MAAM,gMAACgC,OAAO,CAACjB,GAAG,gMAAC4B,GAAG,CAACP,GAAG,CAAC,GAAGQ,CAAC,GAAKA,CAAC,CAACH,IAAI,CAAC,CAAC,CAAC,CAC1E,CACJ;AAGI,MAAMI,EAAE,GAAA,WAAA,+MAAGtC,OAAAA,AAAI,EAUpB,CAAC,EAAE,CACHuC,IAA2E,EAC3EC,KAAe,GAC4DC,GAAG,CAACF,IAAI,EAAE,IAAMC,KAAK,CAAC,CAAC;AAG7F,MAAME,MAAM,IACjBH,IAA2E,GACJE,GAAG,CAACF,IAAI,EAAExC,oNAAS,CAAC;AAGtF,MAAM4C,MAAM,GACjBC,OAIC,IAED5B,IAAI,sNAAC6B,OAAO,CAAC,MAAK;QAChB,MAAMC,QAAQ,GAAGA,CACfC,KAAa,EACbC,OAA0B,EAC1BnB,GAAoB,GAEpBoB,MAAM,CACJzC,GAAG,gMAAC0C,MAAM,CAACrB,GAAG,GAAGsB,MAAM,GACrBH,OAAO,CAACG,MAAM,CAAC,GACb;oBACEnC,IAAI,sNAACoC,QAAQ,CAAC;wBACZC,OAAO,GAAGC,KAAa,GACrBtC,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACuC,KAAK,CAACD,KAAK,CAAC,EACjB,IAAMR,QAAQ,CAAwBC,KAAK,EAAEC,OAAO,EAAEnB,GAAG,CAAC,CAC3D;wBACH2B,SAAS,EAAGC,KAAY,IAAKzC,IAAI,sNAAC0C,IAAI,CAACD,KAAK,CAAC;wBAC7CE,MAAM,GAAGC,IAAY,GAAK5C,IAAI,sNAAC6C,UAAU,CAACD,IAAI;qBAC/C,CAAC;oBACFT,MAAM;iBACE,GACV;oBACEnC,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACuC,KAAK,CAACJ,MAAM,CAAC,EAClB,IAAML,QAAQ,CAAwBC,KAAK,EAAEC,OAAO,EAAEnB,GAAG,CAAC,CAC3D;oBACDkB,KAAK;iBACG,CAAC,CAChB;QACH,OAAOD,QAAQ,CAACF,OAAO,CAACG,KAAK,EAAEH,OAAO,CAACI,OAAO,EAAEJ,OAAO,CAACf,GAAG,CAAC;IAC9D,CAAC,CAAC;AAGG,MAAMiC,WAAW,IACtBjC,GAAiC,GAEjCc,MAAM,CAAC;QACLI,KAAK,EAAEzD,KAAK,gMAACyD,KAAK,EAAE;QACpBC,OAAO,EAAE1D,KAAK,gMAAC0D,OAAO;QACtBnB;KACD,CAAC;AAGG,MAAMkC,QAAQ,GAAA,WAAA,+MAAG/D,OAAAA,AAAI,EA2B1B,CAAC,EACD,CACEuC,IAA2E,EAC3EF,CAAkG,GAUlGrB,IAAI,sNAACgD,aAAa,CAACzB,IAAI,GAAG0B,KAAK,GAC7BvE,MAAM,gMAACwE,KAAK,CAAC7E,KAAK,gMAAC8E,cAAc,CAACF,KAAK,CAAC,EAAE;YACxCG,MAAM,EAAE/B,CAAC;YACTgC,OAAO,EAAErD,IAAI,sNAACsD,SAAAA;SACf,CAAC,CAAC,CACR;AAGM,MAAMC,SAAS,GAAA,WAAA,IAAGvE,kNAAAA,AAAI,EA0B3B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAwF,GASrFrB,IAAI,sNAACwD,aAAa,CAACjC,IAAI,EAAEF,CAAC,EAAE,IAAM,KAAK,CAAC,EAAE,IAAM,KAAK,CAAC,CAAC,CAAC;AAGtD,MAAMoC,OAAO,GAAA,WAAA,+MAAGzE,OAAAA,AAAI,EAUzB,CAAC,EAAE,CACHuC,IAA2E,EAC3EmC,EAA2C,KAC+B;IAC1E,MAAMC,SAAS,GAA8E3D,IAAI,sNAC9FoC,QAAQ,CAAC;QACRC,OAAO,GAAGuB,GAAG,GACXxE,MAAM,gMAAC8D,KAAK,CAACQ,EAAE,CAACE,GAAG,CAAC,EAAE;gBACpBC,MAAM,EAAEA,CAAA,GAAMF,SAAS;gBACvBG,MAAM,GAAGC,IAAI,GAAK/D,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACwB,IAAI,CAAC,EAAE,IAAMJ,SAAS;aACjE,CAAC;QACJnB,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;IACJ,OAAO7C,IAAI,sNAACgE,MAAM,CAACzC,IAAI,EAAEoC,SAAS,CAAC;AACrC,CAAC,CAAC;AAGK,MAAMM,SAAS,IACpB1C,IAQC,GACyEvB,IAAI,sNAACkE,SAAS,CAAC3C,IAAI,CAAC;AAGzF,MAAM4C,QAAQ,GAAA,WAAA,+MAAGnF,OAAAA,AAAI,EAU1B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAyB,KACiD;IAC1E,MAAM+C,MAAM,GAAmEpE,IAAI,sNAACoC,QAAQ,CAAC;QAC3FC,OAAO,GAAGF,MAAc,GAAKnC,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACJ,MAAM,CAAC,EAAE,IAAMiC,MAAM,CAAC;QAC3E5B,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,GAAGC,IAAa,GAAK5C,IAAI,sNAAC6C,UAAU,CAACxB,CAAC,CAACuB,IAAI,CAAC;KACnD,CAAC;IACF,OAAO5C,IAAI,sNAACgE,MAAM,CAACI,MAAM,EAAE7C,IAAI,CAAC;AAClC,CAAC,CAAC;AAGK,MAAM8C,cAAc,GAAA,WAAA,+MAAGrF,OAAAA,AAAI,EAUhC,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAqD,KAC4B;IACjF,MAAM+C,MAAM,GAAyEpE,IAAI,sNAACoC,QAAQ,CAAC;QACjGC,OAAO,GAAGF,MAAM,GAAKnC,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACJ,MAAM,CAAC,EAAE,IAAMiC,MAAM,CAAC;QACnE5B,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,GAAGC,IAAI,GAAK5C,IAAI,sNAACU,UAAU,CAACW,CAAC,CAACuB,IAAI,CAAC;KAC1C,CAAC;IACF,OAAO5C,IAAI,sNAACgE,MAAM,CAACI,MAAM,EAAE7C,IAAI,CAAC;AAClC,CAAC,CAAC;AAGK,MAAM+C,aAAa,GAAA,WAAA,+MAAGtF,OAAAA,AAAI,EAU/B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAuB,KACmD;IAC1E,MAAM+C,MAAM,GAAmEpE,IAAI,sNAACoC,QAAQ,CAAC;QAC3FC,OAAO,GAAGF,MAAc,GAAKnC,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACJ,MAAM,CAAC,EAAE,IAAMiC,MAAM,CAAC;QAC3E5B,SAAS,GAAGC,KAAK,GAAKzC,IAAI,sNAAC0C,IAAI,CAACrB,CAAC,CAACoB,KAAK,CAAC,CAAC;QACzCE,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;IACF,OAAO7C,IAAI,sNAACgE,MAAM,CAACI,MAAM,EAAE7C,IAAI,CAAC;AAClC,CAAC,CAAC;AAGK,MAAMgD,mBAAmB,GAAA,WAAA,OAAGvF,+MAAAA,AAAI,EAUrC,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAwD,KACyB;IACjF,MAAM+C,MAAM,GAAyEpE,IAAI,sNAACoC,QAAQ,CAAC;QACjGC,OAAO,GAAGF,MAAM,GAAKnC,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACJ,MAAM,CAAC,EAAE,IAAMiC,MAAM,CAAC;QACnE5B,SAAS,GAAGC,KAAK,GAAKzC,IAAI,sNAACU,UAAU,CAACW,CAAC,CAACoB,KAAK,CAAC,CAAC;QAC/CE,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;IACF,OAAO7C,IAAI,sNAACgE,MAAM,CAACI,MAAM,EAAE7C,IAAI,CAAC;AAClC,CAAC,CAAC;AAGK,MAAMiD,UAAU,GAAA,WAAA,OAAGxF,+MAAAA,AAAI,EAU5B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAyB,KACiD;IAC1E,MAAM+C,MAAM,GAAmEpE,IAAI,sNAACoC,QAAQ,CAAC;QAC3FC,OAAO,GAAGF,MAAM,GAAKnC,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAAClB,CAAC,CAACc,MAAM,CAAC,CAAC,EAAE,IAAMiC,MAAM,CAAC;QACtE5B,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;IACF,OAAO7C,IAAI,sNAACgE,MAAM,CAACI,MAAM,EAAE7C,IAAI,CAAC;AAClC,CAAC,CAAC;AAGK,MAAMkD,gBAAgB,GAAA,WAAA,8MAAGzF,QAAAA,AAAI,EAUlC,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAqD,KAC4B;IACjF,MAAM+C,MAAM,GAAyEpE,IAAI,sNAACoC,QAAQ,CAAC;QACjGC,OAAO,GAAGF,MAAM,GAAKnC,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACU,UAAU,CAACW,CAAC,CAACc,MAAM,CAAC,CAAC,EAAEnC,IAAI,sNAACuC,KAAK,CAAC,EAAE,IAAM6B,MAAM,CAAC;QACrG5B,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;IACF,OAAO7C,IAAI,sNAACgE,MAAM,CAACI,MAAM,EAAE7C,IAAI,CAAC;AAClC,CAAC,CAAC;AAGK,MAAMmD,WAAW,GACtBnD,IAA2E,IAE3EvB,IAAI,sNAAC6B,OAAO,CAAC,MAAK;QAChB,MAAM8C,OAAO,GAAmB,EAAE;QAClC,mNAAOzF,OAAAA,AAAI,EACTc,IAAI,sNAACgE,MAAM,CAACzC,IAAI,EAAEqD,iBAAiB,CAAgCD,OAAO,CAAC,CAAC,EAC5E3E,IAAI,sNAACS,OAAO,EAAEoE,OAAO,GAAK7E,IAAI,sNAAC8E,OAAO,CAAC;gBAACxG,KAAK,gMAACyG,eAAe,CAACJ,OAAO,CAAC;gBAAEE,OAAO;aAAC,CAAC,CAAC,CACnF;IACH,CAAC,CAAC;AAEJ,cAAA,GACA,MAAMD,iBAAiB,IACrBD,OAAuB,IACmD;IAC1E,OAAO3E,IAAI,sNAACoC,QAAQ,CAAC;QACnBC,OAAO,EAAG2C,OAAO,IACfhF,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACiF,IAAI,CAAC,MAAK;gBACbN,OAAO,CAACO,IAAI,CAACF,OAAO,CAAC;YACvB,CAAC,CAAC,EACF,IAAMJ,iBAAiB,CAAgCD,OAAO,CAAC,CAChE;QACHnC,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,EAAE3C,IAAI,sNAAC8E,OAAAA;KACd,CAAC;AACJ,CAAC;AAGM,MAAMK,KAAK,IAChB5D,IAA2E,IACJ;IACvE,MAAM6D,OAAO,GAA2EpF,IAAI,sNACzFqF,aAAa,CAAC;QACbhD,OAAO,EAAEA,CAAA,GAAM+C,OAAO;QACtB5C,SAAS,EAAExC,IAAI,sNAACsD,SAAS;QACzBX,MAAM,EAAE3C,IAAI,sNAAC8E,OAAAA;KACd,CAAC;IACJ,OAAO9E,IAAI,sNAACgE,MAAM,CAACzC,IAAI,EAAE6D,OAAO,CAAC;AACnC,CAAC;AAGM,MAAME,WAAW,IACtB/D,IAA2E,GAE3EvB,IAAI,sNAACS,OAAO,CAACiE,WAAW,CAACnD,IAAI,CAAC,EAAEvB,IAAI,sNAACuC,KAAK,CAAC;AAGtC,MAAMgD,QAAQ,GAAA,WAAA,+MAAGvG,OAAAA,AAAI,EAU1B,CAAC,EAAE,CACHuC,IAA2E,EAC3EiE,SAAwC,GAExCxF,IAAI,sNAACmB,YAAY,CAACI,IAAI,EAAE,IAAMiE,SAAS,CAAC,CAAC;AAGpC,MAAMC,OAAO,GAAGA,CAAA,GACrBzF,IAAI,sNAACU,UAAU,CAACjC,MAAM,gMAACgH,OAAO,EAAO,CAAC;AAGjC,MAAMC,WAAW,IACtBrE,CAAyC,GACkCI,GAAG,CAACgE,OAAO,EAAO,EAAEpE,CAAC,CAAC;AAG5F,MAAMsE,kBAAkB,IAU7BtE,CAAwG,GACvBrB,IAAI,sNAACS,OAAO,CAACgF,OAAO,EAAO,EAAEpE,CAAC,CAAC;AAG3G,MAAMuE,iBAAiB,GAC5BvE,CAAsE,IACawE,SAAS,CAACJ,OAAO,EAAO,EAAEpE,CAAC,CAAC;AAG1G,MAAMyE,OAAO,IAelBvE,IAQC,GASEvB,IAAI,sNAACS,OAAO,CAACc,IAAI,EAAEtC,mNAAQ,CAAC;AAG1B,MAAM8G,WAAW,GAAA,WAAA,+MAAG/G,OAAAA,AAAI,EA+E7B,CAAC,EAAE,CAuBHuC,IAA2E,EAC3EK,OAGC,GAUD5B,IAAI,sNAACgG,gBAAgB,CAACzE,IAAI,EAAE;QAC1BiB,SAAS,GAAGS,KAAK,IAAI;YACnB,MAAMgD,MAAM,GAAG5H,KAAK,gMAAC8E,cAAc,CAACF,KAAK,CAAC;YAC1C,OAAQgD,MAAM,CAACC,IAAI;gBACjB,KAAK,MAAM;oBAAE;wBACX,OAAOtE,OAAO,CAACY,SAAS,CAACyD,MAAM,CAACE,IAAI,CAAC;oBACvC;gBACA,KAAK,OAAO;oBAAE;wBACZ,OAAOnG,IAAI,sNAACsD,SAAS,CAAC2C,MAAM,CAACG,KAAK,CAAC;oBACrC;YACF;QACF,CAAC;QACDC,SAAS,EAAEzE,OAAO,CAACyE,SAAAA;KACpB,CAAC,CAAC;AAGE,MAAMC,UAAU,IACrBL,MAA2B,GAE3BjG,IAAI,sNAAC6B,OAAO,CAAC,IAAMnD,MAAM,gMAACwE,KAAK,CAAC+C,MAAM,EAAE;YAAE7C,MAAM,EAAEpD,IAAI,sNAAC0C,IAAI;YAAEW,OAAO,EAAErD,IAAI,sNAAC8E,OAAAA;QAAO,CAAE,CAAC,CAAC;AAGjF,MAAMyB,SAAS,IACpBjE,KAAmE,GAEnEL,MAAM,CACJK,KAAK,CAACkE,QAAQ,CACZxG,IAAI,sNAACsD,SAAS,EACbmD,IAAI,IAAKzG,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACkE,IAAI,CAAC,EAAE,IAAMF,SAAS,CAACjE,KAAK,CAAC,CAAC,EAChEtC,IAAI,sNAAC8E,OAAO,CACb,CACF;AAGI,MAAM4B,UAAU,IACrBC,MAAgE,GAEhEC,YAAY,CAACnI,MAAM,gMAACgD,GAAG,CAACnC,MAAM,gMAACuH,SAAS,CAACF,MAAM,CAAC,EAAEG,SAAS,CAAC,CAAC;AAGxD,MAAMC,gBAAgB,IAC3BJ,MAAgE,GAEhElI,MAAM,gMAACgD,GAAG,CAACnC,MAAM,gMAACuH,SAAS,CAACF,MAAM,CAAC,EAAEG,SAAS,CAAC;AAG1C,MAAME,UAAU,IACrBC,MAAwB,GAExBjH,IAAI,sNAAC6B,OAAO,CAAC,IACXzC,MAAM,gMAAC8D,KAAK,CAAC+D,MAAM,EAAE;YACnBpD,MAAM,EAAEA,CAAA,GAAM7D,IAAI,sNAAC0C,IAAI,CAACtD,MAAM,gMAAC8H,IAAI,EAAE,CAAC;YACtCpD,MAAM,EAAE9D,IAAI,sNAAC8E,OAAAA;SACd,CAAC,CACH;AAGI,MAAMgC,SAAS,IACpBK,KAA+D,GACCnH,IAAI,sNAAC6B,OAAO,CAAC,IAAMuF,iBAAiB,CAACD,KAAK,CAAC,CAAC;AAE9G,cAAA,GACA,MAAMC,iBAAiB,IACrBD,KAA+D,+MAE/DjI,OAAAA,AAAI,EACFc,IAAI,sNAACU,UAAU,CAACnB,KAAK,gMAAC8H,IAAI,CAACF,KAAK,CAAC,CAAC,EAClCnH,IAAI,sNAACS,OAAO,CAAC/B,MAAM,gMAACwE,KAAK,CAAC;QACxBE,MAAM,EAAExE,IAAI,gMAACsE,KAAK,CAAC;YACjBV,SAAS,EAAExC,IAAI,sNAACsD,SAAS;YACzB+C,SAAS,EAAErG,IAAI,sNAAC6C,UAAAA;SACjB,CAAC;QACFQ,OAAO,GAAGoD,IAAI,GACZzG,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACuC,KAAK,CAACkE,IAAI,CAAC,EAChB,IAAMW,iBAAiB,CAACD,KAAK,CAAC;KAEnC,CAAC,CAAC,CACJ;AAGI,MAAMG,eAAe,GAAGA,CAAA,GAC7BtH,IAAI,sNAACoC,QAAQ,CAAC;QACZC,OAAO,EAAGC,KAAW,IAAKtC,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACD,KAAK,CAAC,EAAE,IAAMgF,eAAe,EAAE,CAAC;QAClF9E,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;AAGG,MAAM0E,aAAa,GAAA,WAAA,IAAGvI,kNAAAA,AAAI,EAU/B,CAAC,EAAE,CACHuC,IAA2E,EAC3EiG,MAA8C,GAE9CC,SAAS,CAAClG,IAAI,EAAE;QACdmG,KAAK,EAAE1H,IAAI,sNAACU,UAAU,CAAC8G,MAAM,CAAC;QAC9BG,UAAU,EAAGC,QAAQ,IAAKjI,aAAa,uNAACkI,IAAI,CAACpJ,MAAM,gMAACoD,OAAO,CAAC,IAAM+F,QAAQ,CAAC,CAAC;QAC5EE,WAAW,GAAGC,UAAU,GAAKpI,aAAa,uNAACkI,IAAI,CAACpJ,MAAM,gMAACoD,OAAO,CAAC,IAAMkG,UAAU,CAAC;KACjF,CAAC,CAAC;AAGE,MAAMC,qBAAqB,GAAA,WAAA,+MAAGhJ,OAAI,AAAJA,EAUnC,CAAC,EAAE,CACHuC,IAA2E,EAC3E0G,QAA8C,GAE9CV,aAAa,CAAChG,IAAI,EAAE/C,QAAQ,gMAAC0J,KAAK,CAACD,QAAQ,CAAC,CAAC,CAAC;AAGzC,MAAMxG,GAAG,GAAA,WAAA,+MAAGzC,OAAAA,AAAI,EAUrB,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAA6B,GAE7BrB,IAAI,sNAACS,OAAO,CAACc,IAAI,GAAGP,CAAC,GAAKhB,IAAI,sNAACiF,IAAI,CAAC,IAAM5D,CAAC,CAACL,CAAC,CAAC,CAAC,CAAC,CAAC;AAG5C,MAAM6E,SAAS,GAAA,WAAA,GAAG7G,mNAAAA,AAAI,EAU3B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAyD,GAEzDrB,IAAI,sNAACS,OAAO,CAACc,IAAI,GAAG4G,CAAC,GAAKnI,IAAI,sNAACU,UAAU,CAACW,CAAC,CAAC8G,CAAC,CAAC,CAAC,CAAC,CAAC;AAG5C,MAAMC,QAAQ,GAAA,WAAA,8MAAGpJ,QAAAA,AAAI,EAU1B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAA2B,GACgDgH,aAAa,CAAC9G,IAAI,EAAElD,KAAK,gMAACoD,GAAG,CAACJ,CAAC,CAAC,CAAC,CAAC;AAGxG,MAAMgH,aAAa,GAAA,WAAA,GAAGrJ,mNAAI,AAAJA,EAU3B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAuD,GAEvDrB,IAAI,sNAACgD,aAAa,CAACzB,IAAI,GAAG0B,KAAK,GAAKjD,IAAI,sNAACsD,SAAS,CAACjC,CAAC,CAAC4B,KAAK,CAAC,CAAC,CAAC,CAAC;AAGzD,MAAMqF,MAAM,GAAA,WAAA,+MAAGtJ,OAAAA,AAAI,EAUxB,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAA2B,KAC+C;IAC1E,MAAM+C,MAAM,GAA8EpE,IAAI,sNAC3FoC,QAAQ,CAAC;QACRC,OAAO,GAAG2C,OAAO,GAAKhF,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAAClB,CAAC,CAAC2D,OAAO,CAAC,CAAC,EAAE,IAAMZ,MAAM,CAAC;QACxE5B,SAAS,EAAExC,IAAI,sNAAC0C,IAAI;QACpBC,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;IACJ,OAAO7C,IAAI,sNAACgE,MAAM,CAACzC,IAAI,EAAE6C,MAAM,CAAC;AAClC,CAAC,CAAC;AAGK,MAAMmE,YAAY,GAAA,WAAA,OAAGvJ,+MAAAA,AAAI,EAU9B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAyD,KACkC;IAC3F,MAAM+C,MAAM,GAA+FpE,IAAI,sNAC5GqF,aAAa,CAAC;QACbhD,OAAO,GAAG2C,OAAO,+MACf9F,OAAAA,AAAI,EACFc,IAAI,sNAACU,UAAU,CAACW,CAAC,CAAC2D,OAAO,CAAC,CAAC,EAC3BhF,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAAC,EACxBvC,IAAI,sNAACS,OAAO,CAAC,IAAM2D,MAAM,CAAC,CAC3B;QACH5B,SAAS,EAAExC,IAAI,sNAACsD,SAAS;QACzBX,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;KACd,CAAC;IACJ,OAAO7C,IAAI,sNAACgE,MAAM,CAACzC,IAAI,EAAE6C,MAAM,CAAC;AAClC,CAAC,CAAC;AAGK,MAAMoE,eAAe,GAAA,WAAA,8MAAGxJ,QAAAA,AAAI,EAYjC,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAyD,EACzDoH,CAAS,+MAETvJ,OAAAA,AAAI,EACFT,MAAM,gMAACiK,GAAG,CAAC,UAAUC,CAAC;QACpB,MAAMxB,KAAK,GAAG,OAAOwB,CAAC,CACpBlK,MAAM,gMAACmK,cAAc,CACnBrJ,KAAK,gMAACsJ,OAAO,CAA0EJ,CAAC,CAAC,GACxFtB,KAAK,GAAK5H,KAAK,gMAACuJ,QAAQ,CAAC3B,KAAK,CAAC,CACjC,CACF;QACD,MAAM4B,WAAW,GAAG,OAAOJ,CAAC,CAACnK,QAAQ,gMAACmC,IAAI,EAAkB,CAAC;QAC7D,MAAMqI,WAAW,GAAGP,CAAC,KAAKQ,MAAM,CAACC,iBAAiB,GAC9CC,CAAS,IAAKlK,mNAAQ,GACxB,CAAC,OAAO0J,CAAC,CAAClK,MAAM,gMAAC2K,aAAa,CAACX,CAAC,CAAC,CAAC,EAAEO,WAAW;QACjD,MAAMK,IAAI,GAAG,OAAOV,CAAC,CAACW,MAAM,CAAC/H,IAAI,CAAC,CAAC;QACnC,OAAOoH,CAAC,CACNlK,MAAM,gMAAC8K,gBAAgB,CAACF,IAAI,EAAE;YAC5B7G,SAAS,EAAGS,KAAK,IAAK1D,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAE1I,MAAM,gMAAC6E,SAAS,CAACL,KAAK,CAAC,CAAC;YACjEoD,SAAS,GAAGJ,MAAM,GAChBvH,MAAM,gMAACwE,KAAK,CACV+C,MAAM,EACN;oBACE7C,MAAM,GAAGyB,OAAO,IAAI;wBAClB,MAAM4E,IAAI,GAAGT,WAAW,CAACP,CAAC,CAAC;wBAC3B,OAAOhK,MAAM,gMAACiL,QAAQ,CACpBjL,MAAM,gMAACkL,aAAa,CAACF,IAAI,CAAChL,MAAM,gMAACmC,IAAI,CAAC,CAAC,EACvCnC,MAAM,gMAACiD,MAAM,CAACnC,KAAK,gMAACiK,KAAK,CACvBrC,KAAK,EACL1I,MAAM,gMAACqG,OAAO,CAACpG,MAAM,gMAACyH,IAAI,CAACtB,OAAO,CAAC,CAAC,CACrC,CAAC,CACH;oBACH,CAAC;oBACDxB,OAAO,GAAG2B,OAAO,GACfvG,MAAM,gMAACiK,GAAG,CAAC,UAAUC,CAAC;4BACpB,MAAMV,QAAQ,GAAG,OAAOU,CAAC,CAACnK,QAAQ,gMAACmC,IAAI,EAAqB,CAAC;4BAC7D,MAAMiJ,KAAK,GAAG,OAAOjB,CAAC,CAACnK,QAAQ,gMAACmC,IAAI,EAAQ,CAAC;4BAC7C,OAAOgI,CAAC,CAAClK,MAAM,gMAACiD,MAAM,CAACnC,KAAK,gMAACiK,KAAK,CAChCrC,KAAK,EACL1I,MAAM,gMAACgD,GAAG,CAACjD,QAAQ,gMAAC0J,KAAK,CAACD,QAAQ,CAAC,EAAEvJ,MAAM,gMAAC0H,KAAK,CAAC,CACnD,CAAC,CAAC;4BACH,OAAOuC,CAAC,CACNnK,QAAQ,gMAACsG,OAAO,CAAC8E,KAAK,EAAE,KAAK,CAAC,CAAC,EAC/BnL,MAAM,gMAACiL,QAAQ,6MACbxK,OAAAA,AAAI,EACFT,MAAM,gMAACoL,mBAAmB,EAAEC,OAAO,+MACjC5K,OAAAA,AAAI,EACFT,MAAM,gMAACyC,IAAI,CAAC4I,OAAO,CAACtL,QAAQ,gMAAC0J,KAAK,CAACa,WAAW,CAAC,CAAC,CAAC,EACjDtK,MAAM,gMAACsL,SAAS,CAACtL,MAAM,gMAACyC,IAAI,CAAC4I,OAAO,CAACzI,CAAC,CAAC2D,OAAO,CAAC,CAAC,CAAC,CAAC,EAClD,eAAA;gCACAvG,MAAM,gMAACgC,OAAO,CAAES,IAAI,IAAKzC,MAAM,gMAACoD,OAAO,CAAC,IAAMX,IAAI,CAAC,CAAC,CACrD,CACF,EACDzC,MAAM,gMAACuL,aAAa,EAAE/G,KAAK,GAAKzE,QAAQ,gMAAC8E,SAAS,CAACyF,WAAW,EAAE9F,KAAK,CAAC,CAAC,EACvExE,MAAM,gMAACwL,YAAY,CAAChC,QAAQ,CAAC,CAC9B,CACF,EACDe,WAAW,CAAC,CAAC,CAAC,EACdvK,MAAM,gMAACyL,UAAU,CAClB;4BACD,OAAOvB,CAAC,CAACnK,QAAQ,gMAAC0J,KAAK,CAAC0B,KAAK,CAAC,CAAC;wBACjC,CAAC;iBACJ;SAEN,CAAC,EACFnL,MAAM,gMAAC0L,OAAO,EACd1L,MAAM,gMAACkL,aAAa,EACpBlL,MAAM,gMAACyL,UAAU,CAClB;QACD,OAAO/C,KAAK;IACd,CAAC,CAAC,EACF1I,MAAM,gMAACgD,GAAG,EAAE0F,KAAK,IAAI;QACnB,MAAMiD,QAAQ,GAA0FnI,MAAM,CAC5GxD,MAAM,gMAAC4L,UAAU,CAAC5L,MAAM,gMAACqH,OAAO,CAACvG,KAAK,gMAAC8H,IAAI,CAACF,KAAK,CAAC,CAAC,EAAE;YACnD3E,SAAS,EAAExC,IAAI,sNAACsD,SAAS;YACzB+C,SAAS,EAAE3H,MAAM,gMAACwE,KAAK,CAAC;gBACtBE,MAAM,EAAEpD,IAAI,sNAAC6C,UAAU;gBACvBQ,OAAO,GAAG2B,OAAO,GAAKhF,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACyC,OAAO,CAAC,EAAE,IAAMoF,QAAQ;aACvE;SACF,CAAC,CACH;QACD,OAAOA,QAAQ;IACjB,CAAC,CAAC,EACFxD,YAAY,CACb,CAAC;AAGG,MAAM0D,QAAQ,IACnB1I,OAIC,IACC;IACF,QAaE2I,QAQC,GASEC,YAAY,CAAC5I,OAAO,CAAC,CAAC2I,QAAQ,0MAAExL,YAAS,CAAC;AACjD,CAAC;AAGM,MAAM0L,iBAAiB,IAa5BF,QAQC,GASEC,YAAY,CAAC;QAAEE,WAAW,EAAE;IAAW,CAAE,CAAC,CAACH,QAAQ,0MAAExL,YAAS,CAAC;AAG7D,MAAM4L,qBAAqB,GAAGA,CAcnCJ,QAQC,EACDlJ,CAAwC,GASrCmJ,YAAY,CAAC;QAAEE,WAAW,EAAE;IAAW,CAAE,CAAC,CAACH,QAAQ,EAAElJ,CAAC,CAAC;AAGrD,MAAMmJ,YAAY,GAAGA,CAC1B,EACEI,UAAU,GAAG,EAAE,EACfF,WAAW,EACXG,aAAa,GAAGhL,cAAc,sNAACiL,YAAY,EAAA,EAK5C,GAEH,CACEP,QAQC,EACDlJ,CAAwC,+MAUxCnC,OAAAA,AAAI,EACFT,MAAM,gMAACiK,GAAG,CAAC,UAAUC,CAAC;YACpB,MAAMoC,YAAY,GAAGL,WAAW,KAAK,WAAW,GAAGzB,MAAM,CAAC+B,gBAAgB,GAAGN,WAAW;YACxF,MAAMpI,KAAK,GAAG,OAAOqG,CAAC,CAAC7I,wBAAwB,uNAACa,IAAI,EAIjD,CAAC;YACJ,MAAMsK,WAAW,GAAG1E,SAAS,CAACjE,KAAK,CAAC;YACpC,MAAM6E,KAAK,GAAG,OAAOwB,CAAC,CACpBlK,MAAM,gMAACmK,cAAc,CACnBrJ,KAAK,gMAACsJ,OAAO,CAAwE+B,UAAU,CAAC,GAC/FzD,KAAK,GAAK5H,KAAK,gMAACuJ,QAAQ,CAAC3B,KAAK,CAAC,CACjC,CACF;YACD,MAAM+D,SAAS,GAAG,OAAOvC,CAAC,CACxBlK,MAAM,gMAACmK,cAAc,CACnBrJ,KAAK,gMAAC4L,SAAS,EAA2B,GACzChE,KAAK,GAAK5H,KAAK,gMAACuJ,QAAQ,CAAC3B,KAAK,CAAC,CACjC,CACF;YACD,MAAMiE,QAAQ,GAAG,OAAOzC,CAAC,CAACnJ,GAAG,gMAACmB,IAAI,CAAyBvB,MAAM,gMAAC8H,IAAI,EAAE,CAAC,CAAC;YAC1E,MAAM6B,WAAW,GAAG,OAAOJ,CAAC,CAACnK,QAAQ,gMAACmC,IAAI,EAAQ,CAAC;YACnD,MAAMqI,WAAW,GAAG,CAAC,OAAOL,CAAC,CAAClK,MAAM,gMAAC2K,aAAa,CAAC2B,YAAY,CAAC,CAAC,EAC9D/B,WAAW;YACd,MAAMK,IAAI,GAAG,OAAOV,CAAC,CAACW,MAAM,CAACiB,QAAQ,CAAC,CAAC;YACvC,MAAMc,YAAY,IAChBhC,IAAkF,+MAElFnK,OAAAA,AAAI,EACFT,MAAM,gMAACgC,OAAO,CACZ4I,IAAI,EACJ3K,MAAM,gMAACwE,KAAK,CAAC;oBACXE,MAAM,GAAGR,IAAI,GAAKnE,MAAM,gMAACqG,OAAO,CAAC1F,MAAM,gMAACkM,IAAI,CAAC1I,IAAI,CAAC,CAAC;oBACnDS,OAAO,GAAG2B,OAAO,GACfvG,MAAM,gMAAC6C,EAAE,CACP/B,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAE1I,MAAM,gMAACqG,OAAO,CAACpG,MAAM,gMAAC0H,KAAK,CAACpB,OAAO,CAAC,CAAC,CAAC,EACzD5F,MAAM,gMAAC8H,IAAI,EAAE;iBAElB,CAAC,CACH,EACDzI,MAAM,gMAAC8M,MAAM,CAAC;oBAAEC,KAAK,GAAGrC,CAAC,GAAgC/J,MAAM,gMAACqM,MAAM,CAACtC,CAAC;gBAAC,CAAE,CAAC,EAC5E1K,MAAM,gMAACgC,OAAO,EAAEoE,OAAO,GACrBrF,GAAG,gMAACkM,MAAM,CACRN,QAAQ,EACRhM,MAAM,gMAAC8D,KAAK,CAAC;wBACXW,MAAM,EAAEA,CAAA,GAAMzE,MAAM,gMAACkM,IAAI,CAACzG,OAAO,CAACrD,KAAK,CAAC;wBACxCsC,MAAM,GAAGsH,QAAQ,GAAKhM,MAAM,gMAACkM,IAAI,CAACjK,CAAC,CAAC+J,QAAQ,EAAEvG,OAAO,CAACrD,KAAK,CAAC;qBAC7D,CAAC,CACH,CACF,EACD/C,MAAM,gMAACuE,aAAa,EAAEC,KAAK,GACzB5E,KAAK,gMAACsN,aAAa,CAAC1I,KAAK,CAAC,GACxBxE,MAAM,gMAAC6E,SAAS,CAACL,KAAK,CAAC,+MACvB/D,OAAAA,AAAI,EACFK,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAE1I,MAAM,gMAAC6E,SAAS,CAACL,KAAK,CAAC,CAAC,EAC3CxE,MAAM,gMAACiL,QAAQ,CAAClL,QAAQ,gMAACsG,OAAO,CAACiE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC,EACtDtK,MAAM,gMAACiD,MAAM,CACd,CACJ,CACF;YACH,OAAOiH,CAAC,CACNlK,MAAM,gMAAC8K,gBAAgB,CAACF,IAAI,EAAE;gBAC5B7G,SAAS,GAAGS,KAAK,+MACf/D,OAAAA,AAAI,EACFK,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAE1I,MAAM,gMAAC6E,SAAS,CAACL,KAAK,CAAC,CAAC,EAC3CxE,MAAM,gMAACiL,QAAQ,CAACjL,MAAM,gMAACqG,OAAO,CAAC,KAAK,CAAC,CAAC,CACvC;gBACHuB,SAAS,EAAE3H,MAAM,gMAACwE,KAAK,CAAC;oBACtBE,MAAM,GAAGyB,OAAO,GACdpG,MAAM,gMAACmN,QAAQ,CACbnN,MAAM,gMAACkL,aAAa,CAACnL,QAAQ,gMAAC0J,KAAK,CAACa,WAAW,CAAC,CAAC,EACjDtK,MAAM,gMAACkL,aAAa,CAACX,WAAW,CAAC+B,YAAY,CAAC,CAACtM,MAAM,gMAACmC,IAAI,CAAC,CAAC,EAC5D;4BACE+G,UAAU,EAAEA,CAACwB,CAAC,EAAE0C,iBAAiB,GAAKpN,MAAM,gMAAC6C,EAAE,CAACzC,KAAK,gMAACiN,SAAS,CAACD,iBAAiB,CAAC,EAAE,KAAK,CAAC;4BAC1F/D,WAAW,EAAEA,CAACqB,CAAC,EAAE4C,YAAY,GAC3BtN,MAAM,gMAACiL,QAAQ,CACb7K,KAAK,gMAACiN,SAAS,CAACC,YAAY,CAAC,8MAC7B7M,OAAAA,AAAI,EACFM,GAAG,gMAAC4B,GAAG,CAACgK,QAAQ,CAAC,EACjB3M,MAAM,gMAACgC,OAAO,CAACrB,MAAM,gMAAC8D,KAAK,CAAC;oCAC1BW,MAAM,EAAEA,CAAA,GAAMtE,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAE1I,MAAM,gMAACqG,OAAO,CAACpG,MAAM,gMAACyH,IAAI,CAACtB,OAAO,CAAC,CAAC,CAAC;oCACtEf,MAAM,GAAGsH,QAAQ,GAAK7L,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAE1I,MAAM,gMAACqG,OAAO,CAACpG,MAAM,gMAACyH,IAAI,CAAC9E,CAAC,CAAC+J,QAAQ,EAAEvG,OAAO,CAAC,CAAC,CAAC;iCAC3F,CAAC,CAAC,EACHpG,MAAM,gMAAC6C,EAAE,CAAC,KAAK,CAAC,CACjB;yBAEN,CACF;oBACH+B,OAAO,GAAG2I,OAAO,GACfnM,cAAc,sNAACqD,KAAK,CAAC2H,aAAa,EAAE;4BAClCoB,cAAc,EAAEA,CAAA,GACdxN,MAAM,gMAACiK,GAAG,CAAC,UAAUC,CAAC;oCACpB,MAAMiB,KAAK,GAAG,OAAOjB,CAAC,CAACnK,QAAQ,gMAACmC,IAAI,EAAQ,CAAC;oCAC7C,MAAMuL,WAAW,+MAAsDhN,OAAAA,AAAI,EACzE+L,WAAW,EACXjL,IAAI,sNAACgE,MAAM,CAACgI,OAAO,CAAC,EACpB1C,MAAM,EACN7K,MAAM,gMAACgC,OAAO,EAAE4I,IAAI,GAClB5K,MAAM,gMAAC0N,IAAI,CACTd,YAAY,CAAChC,IAAI,CAAC,EAClB5K,MAAM,gMAACkL,aAAa,CAACnL,QAAQ,gMAAC0J,KAAK,CAACa,WAAW,CAAC,CAAC,CAClD,CACF,EACDtK,MAAM,gMAAC2N,MAAM,CACd;oCACD,OAAOzD,CAAC,CACNnK,QAAQ,gMAACsG,OAAO,CAAC8E,KAAK,EAAE,KAAK,CAAC,CAAC,EAC/BnL,MAAM,gMAACiL,QAAQ,CAACwC,WAAW,CAAC,EAC5BlD,WAAW,CAAC,CAAC,CAAC,EACdvK,MAAM,gMAACyL,UAAU,CAClB;oCACD,OAAOvB,CAAC,CAACnK,QAAQ,gMAAC0J,KAAK,CAAC0B,KAAK,CAAC,CAAC;oCAC/B,MAAMyC,OAAO,GAAG,OAAO1D,CAAC,CAACnK,QAAQ,gMAAC8N,MAAM,CAACvD,WAAW,CAAC,CAAC;oCACtD,OAAO,CAACsD,OAAO;gCACjB,CAAC,CAAC;4BACJE,eAAe,EAAEA,CAAA,GACf9N,MAAM,gMAACiK,GAAG,CAAC,UAAUC,CAAC;oCACpB,MAAM6D,QAAQ,GAAG,OAAO7D,CAAC,CAACnK,QAAQ,gMAACmC,IAAI,EAAQ,CAAC;oCAChD,MAAMiJ,KAAK,GAAG,OAAOjB,CAAC,CAACnK,QAAQ,gMAACmC,IAAI,EAAQ,CAAC;oCAC7C,MAAM8L,IAAI,GAAG,OAAO9D,CAAC,CAACpJ,KAAK,gMAACkN,IAAI,CAACvB,SAAS,CAAC,CAAC;oCAC5C,OAAOvC,CAAC,CACNpJ,KAAK,gMAAC8H,IAAI,CAAC6D,SAAS,CAAC,EACrBzM,MAAM,gMAACgC,OAAO,EAAE0I,CAAC,GAAK3K,QAAQ,gMAACsG,OAAO,CAACqE,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAClD1K,MAAM,gMAACiO,IAAI,CAAC,IAAMD,IAAI,IAAI1B,YAAY,CAAC,CACxC;oCACD,OAAOpC,CAAC,CAACpJ,KAAK,gMAACiK,KAAK,CAAC0B,SAAS,EAAEsB,QAAQ,CAAC,CAAC;oCAC1C,MAAMN,WAAW,8MAAsDhN,QAAAA,AAAI,EACzE+L,WAAW,EACXjL,IAAI,sNAACgE,MAAM,CAACgI,OAAO,CAAC,EACpB1C,MAAM,EACN7K,MAAM,gMAACgC,OAAO,EAAE4I,IAAI,+MAClBnK,OAAAA,AAAI,EACFmM,YAAY,CAAChC,IAAI,CAAC,EAClB5K,MAAM,gMAAC0N,IAAI,CAAC1N,MAAM,gMAACkL,aAAa,CAACnL,QAAQ,gMAAC0J,KAAK,CAACa,WAAW,CAAC,CAAC,CAAC,EAC9DtK,MAAM,gMAAC0N,IAAI,CAAC1N,MAAM,gMAACkL,aAAa,CAACnL,QAAQ,gMAAC0J,KAAK,CAACsE,QAAQ,CAAC,CAAC,CAAC,CAC5D,CACF,EACD/N,MAAM,gMAAC2N,MAAM,CACd;oCACD,OAAOzD,CAAC,CACNnK,QAAQ,gMAACsG,OAAO,CAAC8E,KAAK,EAAE,KAAK,CAAC,CAAC,EAC/BnL,MAAM,gMAACiL,QAAQ,CAACwC,WAAW,CAAC,EAC5BlD,WAAW,CAAC,CAAC,CAAC,EACdvK,MAAM,gMAACyL,UAAU,CAClB;oCACD,OAAOvB,CAAC,CAACnK,QAAQ,gMAAC0J,KAAK,CAAC0B,KAAK,CAAC,CAAC;oCAC/B,MAAMyC,OAAO,GAAG,OAAO1D,CAAC,CAACnK,QAAQ,gMAAC8N,MAAM,CAACvD,WAAW,CAAC,CAAC;oCACtD,OAAO,CAACsD,OAAO;gCACjB,CAAC;yBACJ;iBACJ;aACF,CAAC,EACF5N,MAAM,gMAAC8M,MAAM,CAAC;gBAAEoB,KAAK,EAAGxD,CAAC,IAAKA;YAAC,CAAE,CAAC,EAClC1K,MAAM,gMAACyL,UAAU,CAClB;YACD,OAAO;gBAAC/C,KAAK;gBAAE7E,KAAK;aAAU;QAChC,CAAC,CAAC,EACF7D,MAAM,gMAACgD,GAAG,CAAC,CAAC,CAAC0F,KAAK,EAAE7E,KAAK,CAAC,KAAI;YAC5B,MAAM8H,QAAQ,+MAA+FlL,OAAAA,AAAI,EAC/GK,KAAK,gMAAC8H,IAAI,CAACF,KAAK,CAAC,EACjB1I,MAAM,gMAACqH,OAAO,EACdrH,MAAM,gMAAC4L,UAAU,CAAC;gBAChB7H,SAAS,EAAExC,IAAI,sNAACsD,SAAS;gBACzB+C,SAAS,EAAE3H,MAAM,gMAACwE,KAAK,CAAC;oBACtBE,MAAM,EAAEpD,IAAI,sNAAC6C,UAAU;oBACvBQ,OAAO,GAAG2B,OAAO,GAAKhF,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACyC,OAAO,CAAC,EAAE,IAAMoF,QAAQ;iBACvE;aACF,CAAC,EACFnI,MAAM,CACP;YACD,OAAOjC,IAAI,sNAAC4M,UAAU,CAACxC,QAAQ,EAAE9H,KAAK,CAAC;QACzC,CAAC,CAAC,EACFsE,YAAY,CACb;AAGI,MAAMiG,QAAQ,GAAA,WAAA,+MAAG7N,OAAAA,AAAI,EAoC1B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAA8F,EAC9FO,OAIC,GASE0I,QAAQ,CAAC1I,OAAO,CAAC,CAAC0G,MAAM,CAAC/G,IAAI,EAAEF,CAAC,CAAC,CAAC,CAAC;AAGjC,MAAMyL,QAAQ,GAAA,WAAA,+MAAG9N,OAAAA,AAAI,EA0C1B,CAAC,EAAE,CACHuC,IAQC,EACDkH,CAAS,GASN6B,QAAQ,CAAC;QAAEI,WAAW,EAAEjC;IAAC,CAAE,CAAC,CAACH,MAAM,CAAC/G,IAAI,0MAAEtC,WAAQ,CAAC,CAAC,CAAC;AAGnD,MAAM8N,YAAY,GAAA,WAAA,+MAAG/N,OAAI,AAAJA,EA4C1B,CAAC,EAAE,CACHuC,IAQC,EACDkH,CAAS,EACTpH,CAA2C,GASxCmJ,YAAY,CAAC;QAAEE,WAAW,EAAEjC;IAAC,CAAE,CAAC,CAACH,MAAM,CAAC/G,IAAI,0MAAEtC,WAAQ,CAAC,EAAEoC,CAAC,CAAC,CAAC;AAG1D,MAAMoG,SAAS,GAAA,WAAA,+MAAGzI,OAAAA,AAAI,EA6D3B,CAAC,EAAE,CAoBHuC,IAA2E,EAC3EK,OAQC,GAUDgF,YAAY,CACVnI,MAAM,gMAACgC,OAAO,CACZX,wBAAwB,uNAACa,IAAI,EAI1B,GACF2B,KAAK,IAAI;QACR,MAAM2I,WAAW,GAAG1E,SAAS,CAACjE,KAAK,CAAC;QACpC,OAAO7D,MAAM,gMAACgD,GAAG,CACfhD,MAAM,gMAACuO,GAAG,CAAC;YACT1D,MAAM,CAACtJ,IAAI,sNAACgE,MAAM,CAACiH,WAAW,EAAE1J,IAAI,CAAC,CAAC;YACtC+H,MAAM,CAACtJ,IAAI,sNAACgE,MAAM,CAACiH,WAAW,EAAErJ,OAAO,CAAC8F,KAAK,CAAC,CAAC;YAC/CjJ,MAAM,gMAACwO,KAAK;SACb,CAAC,EACF,CAAC,CAACC,KAAK,EAAEC,KAAK,EAAEF,KAAK,CAAC,KAAI;YAYxB,MAAMG,UAAU,GAAGA,CACjBlM,IAA6D,EAC7DmM,KAAkE,EAClEhE,IAA6E,GAE/E,CACEzG,IAQC,EACD0K,IAGU,EACVC,MAIU,KAaR;oBACF,MAAMC,UAAU,IACdC,QAMC,IAWC;wBACF,MAAMC,EAAE,GAAGD,QAAmC;wBAC9C,IAAIC,EAAE,CAACxH,IAAI,KAAKjG,oBAAoB,uNAAC0N,OAAO,EAAE;4BAC5C,OAAOlP,MAAM,gMAACqG,OAAO,CACnB9E,IAAI,sNAACU,UAAU,CACbjC,MAAM,gMAACiL,QAAQ,CACb7K,KAAK,gMAACiN,SAAS,CAACuB,KAAK,CAAC,EACtBK,EAAE,CAAClG,MAAM,CACV,CACF,CACF;wBACH;wBACA,OAAO/I,MAAM,gMAACgD,GAAG,CACf5C,KAAK,gMAACqJ,KAAK,CAACmF,KAAK,CAAC,EAClBzO,IAAI,gMAACsE,KAAK,CAAC;4BACTV,SAAS,GAAGS,KAAK,GAAKjD,IAAI,sNAACU,UAAU,CAACgN,EAAE,CAACrM,CAAC,CAACzC,IAAI,gMAAC0E,SAAS,CAACL,KAAK,CAAC,CAAC,CAAC;4BAClEoD,SAAS,EAAE3H,MAAM,gMAACwE,KAAK,CAAC;gCACtBE,MAAM,GAAGR,IAAI,GAAK5C,IAAI,sNAACU,UAAU,CAACgN,EAAE,CAACrM,CAAC,CAACzC,IAAI,gMAACkG,OAAO,CAAClC,IAAI,CAAC,CAAC,CAAC;gCAC3DS,OAAO,GAAGoD,IAAI,GAAKiD,QAAQ,CAAC1J,IAAI,sNAACuC,KAAK,CAACkE,IAAI,CAAC,EAAEmH,EAAE,CAACL,MAAM,CAACG,EAAE,CAACrM,CAAC,CAAC,CAAC;6BAC/D;yBACF,CAAC,CACH;oBACH,CAAC;oBAED,OAAOzC,IAAI,gMAACsE,KAAK,CAAChC,IAAI,EAAE;wBACtBsB,SAAS,GAAGS,KAAK,GAAKuK,UAAU,CAAC5K,IAAI,CAAChE,IAAI,gMAAC0E,SAAS,CAACL,KAAK,CAAC,CAAC,CAAC;wBAC7DoD,SAAS,EAAE3H,MAAM,gMAACwE,KAAK,CAAC;4BACtBE,MAAM,GAAG+E,CAAC,GAAKqF,UAAU,CAAC5K,IAAI,CAAChE,IAAI,gMAACkG,OAAO,CAACqD,CAAC,CAAC,CAAC,CAAC;4BAChD9E,OAAO,GAAGoD,IAAI,GACZhI,MAAM,gMAACqG,OAAO,CACZ9E,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACkE,IAAI,CAAC,EAAE,IAC7BzG,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACU,UAAU,CAACjC,MAAM,gMAACoP,UAAU,CAACxE,IAAI,CAAC,CAAC,GACvCyE,SAAS,GAAKF,EAAE,CAACN,IAAI,CAACQ,SAAS,EAAET,KAAK,CAAC,CAAC,CAC1C,CAAC;yBAET;qBACF,CAAC;gBACJ,CAAC;YAED,MAAMO,EAAE,GACNG,KAAY,IASV;gBACF,OAAQA,KAAK,CAAC7H,IAAI;oBAChB,KAAKhG,iBAAiB,uNAAC8N,eAAe;wBAAE;4BACtC,MAAMC,QAAQ,GAAGxP,MAAM,gMAACkL,aAAa,CAAC9K,KAAK,gMAACqP,IAAI,CAACH,KAAK,CAAC5H,IAAI,CAAC,CAAC;4BAC7D,MAAMgI,SAAS,GAAG1P,MAAM,gMAACkL,aAAa,CAAC9K,KAAK,gMAACqP,IAAI,CAACH,KAAK,CAAC3H,KAAK,CAAC,CAAC;4BAC/D,OAAOnE,MAAM,CACXxD,MAAM,gMAACmN,QAAQ,CAACqC,QAAQ,EAAEE,SAAS,EAAE;gCACnCxG,UAAU,EAAEA,CAACyG,QAAQ,EAAEC,EAAE,GACvB5P,MAAM,gMAACiL,QAAQ,CACb7K,KAAK,gMAACiN,SAAS,CAACuC,EAAE,CAAC,EACnBjB,UAAU,CAACgB,QAAQ,EAAEL,KAAK,CAAC3H,KAAK,EAAE8G,KAAK,CAAC,CACtCtL,OAAO,CAAC+F,UAAU,EAClB/H,UAAU,uNAAC0O,WAAW,GACrBjN,CAAC,GAAKzB,UAAU,uNAAC2O,QAAQ,CAAClN,CAAC,CAAC,CAC9B,CACF;gCACHyG,WAAW,EAAEA,CAAC0G,SAAS,EAAEC,EAAE,GACzBhQ,MAAM,gMAACiL,QAAQ,CACb7K,KAAK,gMAACiN,SAAS,CAAC2C,EAAE,CAAC,EACnBrB,UAAU,CAACoB,SAAS,EAAET,KAAK,CAAC5H,IAAI,EAAEgH,KAAK,CAAC,CACtCvL,OAAO,CAACkG,WAQP,EACD,CAAC3B,IAAI,EAAEC,KAAK,GAAKxG,UAAU,uNAAC0O,WAAW,CAAClI,KAAK,EAAED,IAAI,CAAC,GACnD9E,CAAC,GAAKzB,UAAU,uNAAC8O,SAAS,CAACrN,CAAC,CAAC,CAC/B;6BAEN,CAAC,CACH;wBACH;oBACA,KAAKnB,iBAAiB,uNAACyO,YAAY;wBAAE;4BACnC,OAAO1M,MAAM,CACXxD,MAAM,gMAACgD,GAAG,CACRhD,MAAM,gMAACyC,IAAI,CAACiM,KAAK,CAAC,EAClBvO,IAAI,gMAACsE,KAAK,CAAC;gCACTV,SAAS,EAAGS,KAAK,IAAKjD,IAAI,sNAACU,UAAU,CAACqN,KAAK,CAAC1M,CAAC,CAACzC,IAAI,gMAAC0E,SAAS,CAACL,KAAK,CAAC,CAAC,CAAC;gCACrEoD,SAAS,EAAE3H,MAAM,gMAACwE,KAAK,CAAC;oCACtBE,MAAM,GAAGR,IAAI,GAAK5C,IAAI,sNAACU,UAAU,CAACqN,KAAK,CAAC1M,CAAC,CAACzC,IAAI,gMAACkG,OAAO,CAAClC,IAAI,CAAC,CAAC,CAAC;oCAC9DS,OAAO,GAAGoD,IAAI,GACZzG,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACuC,KAAK,CAACkE,IAAI,CAAC,EAChB,IAAMmH,EAAE,CAAChO,UAAU,uNAAC2O,QAAQ,CAACR,KAAK,CAAC1M,CAAC,CAAC,CAAC;iCAE3C;6BACF,CAAC,CACH,CACF;wBACH;oBACA,KAAKnB,iBAAiB,uNAAC0O,aAAa;wBAAE;4BACpC,OAAO3M,MAAM,CACXxD,MAAM,gMAACgD,GAAG,CACRhD,MAAM,gMAACyC,IAAI,CAACgM,KAAK,CAAC,EAClBtO,IAAI,gMAACsE,KAAK,CAAC;gCACTV,SAAS,EAAGS,KAAK,IAAKjD,IAAI,sNAACU,UAAU,CAACqN,KAAK,CAAC1M,CAAC,CAACzC,IAAI,gMAAC0E,SAAS,CAACL,KAAK,CAAC,CAAC,CAAC;gCACrEoD,SAAS,EAAE3H,MAAM,gMAACwE,KAAK,CAAC;oCACtBE,MAAM,GAAGR,IAAI,GAAK5C,IAAI,sNAACU,UAAU,CAACqN,KAAK,CAAC1M,CAAC,CAACzC,IAAI,gMAACkG,OAAO,CAAClC,IAAI,CAAC,CAAC,CAAC;oCAC9DS,OAAO,GAAGoD,IAAI,GACZzG,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACuC,KAAK,CAACkE,IAAI,CAAC,EAChB,IAAMmH,EAAE,CAAChO,UAAU,uNAAC8O,SAAS,CAACX,KAAK,CAAC1M,CAAC,CAAC,CAAC;iCAE5C;6BACF,CAAC,CACH,CACF;wBACH;gBACF;YACF,CAAC;YAED,mNAAOnC,OAAAA,AAAI,EACTc,IAAI,sNAACU,UAAU,CACbjC,MAAM,gMAACoQ,OAAO,CACZpQ,MAAM,gMAACqQ,MAAM,CAAC5B,KAAK,EAAED,KAAK,CAAC,EAC3BxO,MAAM,gMAACqQ,MAAM,CAAC3B,KAAK,EAAEF,KAAK,CAAC,EAC3B,CAAC9G,IAAI,EAAEC,KAAK,GACVxG,UAAU,uNAAC0O,WAAW,CASpBnI,IAAI,EAAEC,KAAK,CAAC,CACjB,CACF,EACDpG,IAAI,sNAACS,OAAO,CAACmN,EAAE,CAAC,EAChB5N,IAAI,sNAAC4M,UAAU,CAACtK,KAAK,CAAC,CACvB;QACH,CAAC,CACF;IACH,CAAC,CACF,CACF,CAAC;AAGG,MAAMyM,KAAK,GAAA,WAAA,GAAoE/O,IAAI,sNAACU,UAAU,CACnGjC,MAAM,gMAACsQ,KAAK,CACb;AAGM,MAAMC,KAAK,GAAA,WAAA,IAAGhQ,kNAAAA,AAAI,EAUvB,CAAC,EAAE,CACHuC,IAA2E,EAC3EkB,KAAiB,GACwDwM,SAAS,CAAC1N,IAAI,EAAEkB,KAAK,CAAC,CAAC;AAG3F,MAAMwM,SAAS,GAAA,WAAA,IAAGjQ,kNAAAA,AAAI,EAU3B,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAyB,GAEzB0B,QAAQ,CAACxB,IAAI,GAAG2N,CAAC,IAAI;QACnB,MAAM7N,CAAC,CAAC6N,CAAC,CAAC;IACZ,CAAC,CAAyE,CAAC;AAGtE,MAAMC,MAAM,GAAA,WAAA,GAAGnQ,mNAAAA,AAAI,EA2BxB,CAAC,EACD,CACEuC,IAA2E,EAC3E6N,IAA2F,GASxFrM,QAAQ,CAACxB,IAAI,EAAE6N,IAAI,CAAC,CAC1B;AAGM,MAAMC,YAAY,GAAA,WAAA,+MAAGrQ,OAAAA,AAAI,EAU9B,CAAC,EAAE,CACHuC,IAA2E,EAC3E6N,IAAiF,GAEjFpP,IAAI,sNAAC6B,OAAO,CAAC,MAAK;QAChB,IAAIyN,gBAAgB,GAA2DC,SAAS;QAExF,MAAMnL,MAAM,GAA4EpE,IAAI,sNACzFoC,QAAQ,CAAC;YACRC,OAAO,EAAG2C,OAAO,IAAKhF,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACyC,OAAO,CAAC,EAAE,IAAMZ,MAAM,CAAC;YACrE5B,SAAS,GAAGgN,MAAM,IAAI;gBACpBF,gBAAgB,GAAGG,gBAAgB,CAACD,MAAM,CAAC;gBAC3C,OAAOxP,IAAI,sNAACsD,SAAS,CAACjF,KAAK,gMAACqR,GAAG,CAACJ,gBAAgB,CAAC,CAAC;YACpD,CAAC;YACD3M,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;SACd,CAAC;QAEJ,MAAM8M,MAAM,GAQR3P,IAAI,sNAACqF,aAAa,CAAC;YACrBhD,OAAO,GAAG2C,OAAO,+MAAK9F,OAAAA,AAAI,EAACc,IAAI,sNAACuC,KAAK,CAACyC,OAAO,CAAC,EAAEhF,IAAI,sNAACS,OAAO,CAAC,IAAMkP,MAAM,CAAC,CAAC;YAC3EnN,SAAS,EAAGS,KAAK,IACf5E,KAAK,gMAACuR,SAAS,CAAC3M,KAAK,CAAC,IACpB4M,kBAAkB,CAAC5M,KAAK,CAAC6M,MAAM,CAAC,IAChCnR,KAAK,gMAACoR,MAAM,CAAC9M,KAAK,CAAC6M,MAAM,EAAER,gBAAgB,CAAC,GAC1CtP,IAAI,sNAAC0C,IAAI,CAACO,KAAK,CAAC6M,MAAM,CAACrN,KAAgB,CAAC,GACxCzC,IAAI,sNAACsD,SAAS,CAACL,KAAK,CAAC;YAC3BN,MAAM,EAAE3C,IAAI,sNAAC6C,UAAAA;SACd,CAAC;QAEF,OAAO7C,IAAI,sNAACgE,MAAM,CAAChE,IAAI,sNAACgE,MAAM,CAAChE,IAAI,sNAACgE,MAAM,CAACzC,IAAI,EAAE6C,MAAM,CAAC,EAAEgL,IAAI,CAAC,EAAEO,MAAM,CAAC;IAC1E,CAAC,CAAC,CAAC;AAGE,MAAMK,cAAc,GAAA,WAAA,+MAAGhR,OAAAA,AAAI,EAYhC,CAAC,EAAE,CACHuC,IAA2E,EAC3E0O,GAAM,EACNC,OAA+B,KAC8E;IAC7G,OAAOlQ,IAAI,sNAACS,OAAO,CACjBgF,OAAO,EAAO,GACbA,OAAO,GAAKzF,IAAI,sNAACmQ,cAAc,CAAC5O,IAAI,EAAEhD,OAAO,gMAAC6R,GAAG,CAAC3K,OAAO,EAAEwK,GAAG,EAAEC,OAAO,CAAC,CAAC,CAC3E;AACH,CAAC,CAAC;AAGK,MAAMG,YAAY,GAAA,WAAA,+MAAGrR,OAAAA,AAAI,EAU9B,CAAC,EAAE,CACHuC,IAA2E,EAC3E+O,KAAsC,GAEtC1J,YAAY,CAACnI,MAAM,gMAACgD,GAAG,CAACtC,KAAK,gMAACoR,KAAK,CAACD,KAAK,CAAC,GAAGE,GAAG,GAAKxQ,IAAI,sNAACmQ,cAAc,CAAC5O,IAAI,EAAEiP,GAAG,CAAC,CAAC,CAAC,CAAC;AAGjF,MAAMC,eAAe,GAAA,WAAA,+MAAGzR,OAAAA,AAAI,EAUjC,CAAC,EAAE,CACHuC,IAA2E,EAC3EF,CAAuD,GAEvDsE,kBAAkB,EAAEF,OAA8B,GAAKzF,IAAI,sNAACmQ,cAAc,CAAC5O,IAAI,EAAEF,CAAC,CAACoE,OAAO,CAAC,CAAC,CAAC,CAAC;AAGzF,MAAMiL,gBAAgB,GAAA,WAAA,+MAAG1R,OAAAA,AAAI,EAUlC,CAAC,EAAE,CACHuC,IAAyE,EACzE+O,KAAqC,GAErC,mBAAA;IACAD,YAAY,CAAC9O,IAAI,EAAEpC,KAAK,gMAACwR,KAAK,CAACxR,KAAK,gMAACsG,OAAO,EAAkB,EAAE6K,KAAK,CAAC,CAAC,CAAC;AAGnE,MAAMM,IAAI,GAAGA,CAAA,GAClB5Q,IAAI,sNAAC6Q,UAAU,CAA2BzR,MAAM,gMAAC8H,IAAI,EAAE,CAAC;AAGnD,MAAM4J,QAAQ,IACnBvP,IAA2E,GACDvB,IAAI,sNAACS,OAAO,CAACc,IAAI,EAAE,IAAMuP,QAAQ,CAACvP,IAAI,CAAC,CAAC;AAG7G,MAAMwP,GAAG,IACdxP,IAA0E,GACZ9C,MAAM,gMAAC2N,MAAM,CAAC1M,QAAQ,8NAACsR,SAAS,CAACzP,IAAI,CAAC,CAAC;AAGhG,MAAM0P,UAAU,IACrB1P,IAA4E,GAE5E7B,QAAQ,8NAACqR,GAAG,CAAC/Q,IAAI,sNAACkR,eAAe,CAAC3P,IAAI,CAAC,CAAC;AAGnC,MAAM4P,QAAQ,IACnB5P,IAA4E,GACd7B,QAAQ,8NAACqR,GAAG,CAAC5L,KAAK,CAAC5D,IAAI,CAAC,CAAC;AAGlF,MAAM6K,MAAM,IACjB5E,MAA8B,GAE9BvF,MAAM,CACJxD,MAAM,gMAACoL,mBAAmB,EAAEC,OAAO,GACjCrL,MAAM,gMAACgD,GAAG,CAAChC,KAAK,gMAACkB,IAAI,EAAE,GAAGsM,KAAK,GAC7BjN,IAAI,sNAACoR,iBAAiB,CACpB3S,MAAM,gMAACuL,aAAa,CAClBF,OAAO,CAACrK,KAAK,gMAAC4R,MAAM,CAAC7J,MAAM,EAAEyF,KAAK,CAAC,CAAC,GACnChK,KAAK,GAAKxD,KAAK,gMAAC6R,KAAK,CAACrE,KAAK,EAAErO,IAAI,gMAAC0E,SAAS,CAACL,KAAK,CAAC,CAAC,CACrD,EACD,CAACkG,CAAC,EAAEjI,IAAI,GAAKzB,KAAK,gMAAC6R,KAAK,CAACrE,KAAK,EAAE/L,IAAI,CAAC,CACtC,CAAC,CACL,CACF;AAGI,MAAMgP,OAAO,IAClBD,GAAM,GAENjQ,IAAI,sNAACU,UAAU,CAACuP,GAAG,CAAC;AAGf,MAAMsB,WAAW,IAAqCtB,GAAM,IAEjE5O,CAAgD,GACiDI,GAAG,CAACyO,OAAO,CAACD,GAAG,CAAC,EAAE5O,CAAC,CAAC;AAGhH,MAAMmQ,kBAAkB,IACKvB,GAAM,IAEtC5O,CAA8G,GAE9GrB,IAAI,sNAACS,OAAO,CAACyP,OAAO,CAACD,GAAG,CAAC,EAAE5O,CAAC,CAAC;AAG1B,MAAMoQ,iBAAiB,IAAqCxB,GAAM,IAEvE5O,CAA4E,GAE5EwE,SAAS,CAACqK,OAAO,CAACD,GAAG,CAAC,EAAE5O,CAAC,CAAC;AAGrB,MAAMqQ,UAAU,GAAGA,CAAA,GASxB1R,IAAI,sNAAC6B,OAAO,CAAC,MAAK;QAChB,IAAI8P,aAAa,GAAG,EAAE;QACtB,IAAIC,OAAO,GAAG,KAAK;QACnB,MAAMC,eAAe,IAAIC,KAA0B,IAAyB;YAC1E,MAAMC,YAAY,GAAkB,EAAE;YACtCzT,KAAK,gMAACmD,GAAG,CAACqQ,KAAK,EAAGE,GAAG,IAAI;gBACvB,IAAIA,GAAG,CAACC,MAAM,KAAK,CAAC,EAAE;oBACpB,IAAIC,IAAI,GAAG,CAAC;oBACZ,IAAIC,SAAS,GAAGH,GAAG,CAACI,OAAO,CAAC,IAAI,CAAC;oBACjC,IAAIC,SAAS,GAAGL,GAAG,CAACI,OAAO,CAAC,IAAI,CAAC;oBACjC,IAAIR,OAAO,EAAE;wBACX,IAAIS,SAAS,KAAK,CAAC,EAAE;4BACnBN,YAAY,CAAC7M,IAAI,CAACyM,aAAa,CAAC;4BAChCA,aAAa,GAAG,EAAE;4BAClBO,IAAI,GAAG,CAAC;4BACRG,SAAS,GAAGL,GAAG,CAACI,OAAO,CAAC,IAAI,EAAEF,IAAI,CAAC;wBACrC,CAAC,MAAM;4BACLP,aAAa,GAAGA,aAAa,GAAG,IAAI;wBACtC;wBACAC,OAAO,GAAG,KAAK;oBACjB;oBACA,MAAOO,SAAS,KAAK,CAAC,CAAC,IAAIE,SAAS,KAAK,CAAC,CAAC,CAAE;wBAC3C,IAAIF,SAAS,KAAK,CAAC,CAAC,IAAKE,SAAS,KAAK,CAAC,CAAC,IAAIA,SAAS,GAAGF,SAAU,EAAE;4BACnE,IAAIR,aAAa,CAACM,MAAM,KAAK,CAAC,EAAE;gCAC9BF,YAAY,CAAC7M,IAAI,CAAC8M,GAAG,CAACM,SAAS,CAACJ,IAAI,EAAEG,SAAS,CAAC,CAAC;4BACnD,CAAC,MAAM;gCACLN,YAAY,CAAC7M,IAAI,CAACyM,aAAa,GAAGK,GAAG,CAACM,SAAS,CAACJ,IAAI,EAAEG,SAAS,CAAC,CAAC;gCACjEV,aAAa,GAAG,EAAE;4BACpB;4BACAO,IAAI,GAAGG,SAAS,GAAG,CAAC;4BACpBA,SAAS,GAAGL,GAAG,CAACI,OAAO,CAAC,IAAI,EAAEF,IAAI,CAAC;wBACrC,CAAC,MAAM;4BACL,IAAIF,GAAG,CAACC,MAAM,KAAKE,SAAS,GAAG,CAAC,EAAE;gCAChCP,OAAO,GAAG,IAAI;gCACdO,SAAS,GAAG,CAAC,CAAC;4BAChB,CAAC,MAAM;gCACL,IAAIE,SAAS,KAAKF,SAAS,GAAG,CAAC,EAAE;oCAC/B,IAAIR,aAAa,CAACM,MAAM,KAAK,CAAC,EAAE;wCAC9BF,YAAY,CAAC7M,IAAI,CAAC8M,GAAG,CAACM,SAAS,CAACJ,IAAI,EAAEC,SAAS,CAAC,CAAC;oCACnD,CAAC,MAAM;wCACLR,aAAa,GAAGA,aAAa,GAAGK,GAAG,CAACM,SAAS,CAACJ,IAAI,EAAEC,SAAS,CAAC;wCAC9DJ,YAAY,CAAC7M,IAAI,CAACyM,aAAa,CAAC;wCAChCA,aAAa,GAAG,EAAE;oCACpB;oCACAO,IAAI,GAAGC,SAAS,GAAG,CAAC;oCACpBA,SAAS,GAAGH,GAAG,CAACI,OAAO,CAAC,IAAI,EAAEF,IAAI,CAAC;oCACnCG,SAAS,GAAGL,GAAG,CAACI,OAAO,CAAC,IAAI,EAAEF,IAAI,CAAC;gCACrC,CAAC,MAAM;oCACLC,SAAS,GAAGH,GAAG,CAACI,OAAO,CAAC,IAAI,EAAED,SAAS,GAAG,CAAC,CAAC;gCAC9C;4BACF;wBACF;oBACF;oBACA,IAAIP,OAAO,EAAE;wBACXD,aAAa,GAAGA,aAAa,GAAGK,GAAG,CAACM,SAAS,CAACJ,IAAI,EAAEF,GAAG,CAACC,MAAM,GAAG,CAAC,CAAC;oBACrE,CAAC,MAAM;wBACLN,aAAa,GAAGA,aAAa,GAAGK,GAAG,CAACM,SAAS,CAACJ,IAAI,EAAEF,GAAG,CAACC,MAAM,CAAC;oBACjE;gBACF;YACF,CAAC,CAAC;YACF,OAAO3T,KAAK,gMAACyG,eAAe,CAACgN,YAAY,CAAC;QAC5C,CAAC;QACD,MAAMQ,IAAI,GAA2FvS,IAAI,sNACtGqF,aAAa,CAAC;YACbhD,OAAO,GAAGC,KAA0B,IAAI;gBACtC,MAAMsB,GAAG,GAAGiO,eAAe,CAACvP,KAAK,CAAC;gBAClC,OAAOhE,KAAK,gMAAC0D,OAAO,CAAC4B,GAAG,CAAC,GACrB2O,IAAI,GACJvS,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACqB,GAAG,CAAC,EAAE,IAAM2O,IAAI,CAAC;YAC/C,CAAC;YACD/P,SAAS,GAAGS,KAAK,GACf0O,aAAa,CAACM,MAAM,KAAK,CAAC,GACtBjS,IAAI,sNAACsD,SAAS,CAACL,KAAK,CAAC,GACrBjD,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACjE,KAAK,gMAACkU,EAAE,CAACb,aAAa,CAAC,CAAC,EAAE,IAAM3R,IAAI,sNAACsD,SAAS,CAACL,KAAK,CAAC,CAAC;YACpFN,MAAM,GAAGC,IAAI,GACX+O,aAAa,CAACM,MAAM,KAAK,CAAC,GACtBjS,IAAI,sNAAC8E,OAAO,CAAClC,IAAI,CAAC,GAClB5C,IAAI,sNAACS,OAAO,CAACT,IAAI,sNAACuC,KAAK,CAACjE,KAAK,gMAACkU,EAAE,CAACb,aAAa,CAAC,CAAC,EAAE,IAAM3R,IAAI,sNAAC8E,OAAO,CAAClC,IAAI,CAAC;SACjF,CAAC;QACJ,OAAO2P,IAAI;IACb,CAAC,CAAC;AAGG,MAAME,QAAQ,IACnB9L,MAAgE,GACJ+L,OAAO,CAAC/L,MAAM,CAAC;AAGtE,MAAM2C,MAAM,IACjB/H,IAA2E,GAE3E9C,MAAM,gMAACgD,GAAG,CACRhD,MAAM,gMAACmK,cAAc,CACnBnK,MAAM,gMAACwG,IAAI,CAAC,IAAM,IAAIvF,QAAQ,8NAACiT,eAAe,CAACpR,IAAI,EAAE,KAAK,CAAC,0MAAEtC,WAAQ,CAAC,CAAC,EACvE,CAAC2T,IAAI,EAAE1R,IAAI,KAAI;QACb,MAAM2R,QAAQ,GAAGD,IAAI,CAACtB,KAAK,CAACpQ,IAAI,CAAC;QACjC,OAAO2R,QAAQ,KAAKtD,SAAS,GAAG9Q,MAAM,gMAACmC,IAAI,GAAGiS,QAAQ;IACxD,CAAC,CACF,GACAD,IAAI,GAAKnU,MAAM,gMAACoD,OAAO,CAAC,IAAMiR,eAAe,CAACF,IAAI,CAAC7B,GAAG,EAA4C,EAAE6B,IAAI,CAAC,CAAC,CAC5G;AAEH,cAAA,GACA,MAAME,eAAe,GAAGA,CACtBC,YAAoD,EACpDH,IAAoF,KACrB;IAC/D,MAAM7E,KAAK,GAAGgF,YAAsC;IACpD,OAAQhF,KAAK,CAAC7H,IAAI;QAChB,KAAK/F,mBAAmB,gNAACwN,OAAO;YAAE;gBAChC,OAAO/O,IAAI,gMAACsE,KAAK,CAAC0P,IAAI,CAACI,OAAO,EAAE,EAAE;oBAChCxQ,SAAS,EAAE/D,MAAM,gMAAC6E,SAAS;oBAC3B+C,SAAS,GAAGzD,IAAI,GACdnE,MAAM,gMAACqG,OAAO,CAACpG,MAAM,gMAACyH,IAAI,CAACvD,IAAI,CAAC;iBACnC,CAAC;YACJ;QACA,KAAKzC,mBAAmB,gNAAC8S,OAAO;YAAE;gBAChC,OAAOxU,MAAM,gMAACqG,OAAO,CAACpG,MAAM,gMAAC0H,KAAK,CAACwM,IAAI,CAACM,OAAO,EAAE,CAAC,CAAC;YACrD;QACA,KAAK/S,mBAAmB,gNAACgT,cAAc;YAAE;gBACvC,mNAAOjU,OAAAA,AAAI,EACT6O,KAAK,CAACvG,MAAqE,EAC3E/I,MAAM,gMAACgC,OAAO,CAAC,IAAMqS,eAAe,CAACF,IAAI,CAAC7B,GAAG,EAA4C,EAAE6B,IAAI,CAAC,CAAC,CAClG;YACH;QACA,KAAKzS,mBAAmB,gNAACiT,OAAO;YAAE;gBAChC,OAAO1T,QAAQ,8NAAC2T,YAAY,CAC1BtF,KAAK,EACL,IAAM+E,eAAe,CAACF,IAAI,CAAC7B,GAAG,EAA4C,EAAE6B,IAAI,CAAC,GAChF3P,KAAK,GAAKxE,MAAM,gMAAC6E,SAAS,CAACL,KAAK,CAAgE,CAClG;YACH;IACF;AACF,CAAC;AAGM,MAAMyP,OAAO,IAClBvL,KAA+D,GACHnH,IAAI,sNAAC6B,OAAO,CAAC,IAAMyR,eAAe,CAACnM,KAAK,CAAC,CAAC;AAExG,cAAA,GACA,MAAMmM,eAAe,IACnBnM,KAA+D,IACJ;IAC3D,OAAOnH,IAAI,sNAACqF,aAAa,CAAC;QACxBhD,OAAO,GAAGoE,IAAI,GACZzG,IAAI,sNAACS,OAAO,CACVT,IAAI,sNAACU,UAAU,CAACnB,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAEzI,MAAM,gMAAC0H,KAAK,CAACK,IAAI,CAAC,CAAC,CAAC,EACvD,IAAM6M,eAAe,CAACnM,KAAK,CAAC,CAC7B;QACH3E,SAAS,GAAGS,KAAK,GAAKjD,IAAI,sNAACU,UAAU,6MAACxB,OAAAA,AAAI,EAACK,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAEzI,MAAM,gMAACyH,IAAI,CAACvH,IAAI,gMAAC0E,SAAS,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACnGN,MAAM,GAAGC,IAAI,GAAK5C,IAAI,sNAACU,UAAU,6MAACxB,OAAAA,AAAI,EAACK,KAAK,gMAACiK,KAAK,CAACrC,KAAK,EAAEzI,MAAM,gMAACyH,IAAI,CAACvH,IAAI,gMAACkG,OAAO,CAAClC,IAAI,CAAC,CAAC,CAAC,CAAC;KAC5F,CAAC;AACJ,CAAC;AAGM,MAAMX,MAAM,IACjB+J,OAAkG,GACjBlG,OAAO,CAAC9F,IAAI,sNAACU,UAAU,CAACsL,OAAO,CAAC,CAAC;AAG7G,MAAMpF,YAAY,IACvBrF,IAAgG,GAEhGvB,IAAI,sNAACuT,aAAa,CAChBnH,MAAM,CAAC7K,IAAI,CAAC,EACZ,CAACiS,CAAC,EAAErK,CAAC,GAAKqK,CAAC,EACX,CAACA,CAAC,EAAErK,CAAC,GAAKqK,CAAC,CACZ;AAGI,MAAMC,aAAa,GAAA,WAAA,GAAGzU,mNAAAA,AAAI,EAY/B,CAAC,EAAE,CACHuC,IAA0E,EAC1E0O,GAAM,EACN5O,CAA+D,GAE/DoP,eAAe,CAAClP,IAAI,GAAGkE,OAA2B,GAChDlH,OAAO,gMAACoS,KAAK,CACXlL,OAAO,EACPlH,OAAO,gMAACoC,IAAI,CAACsP,GAAG,EAAE5O,CAAC,CAAC9C,OAAO,gMAACmV,SAAS,CAACjO,OAAO,EAAEwK,GAAG,CAAC,CAAC,CAAC,CACtD,CAAC,CAAC;AAGA,MAAM0D,QAAQ,GAYjB,SAAAA,CAAA;IACF,MAAMC,SAAS,GAAG,OAAOC,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ;IAClD,MAAMC,IAAI,GAAGF,SAAS,GAAGC,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC;IACpD,MAAMjS,OAAO,GAAGxB,MAAM,4MAAC2T,iBAAiB,CAACH,SAAS,GAAGC,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC,CAAC;IACjF,MAAMvT,OAAO,GAAG7B,MAAM,gMAACuO,GAAG,CAAC;QACzBvO,MAAM,gMAACuV,QAAQ,CAACF,IAAI,EAAElS,OAAO,CAAC;QAC9BnD,MAAM,gMAACgH,OAAO,EAAE;QAChBhH,MAAM,gMAACwV,KAAK;QACZnV,QAAQ,gMAACsC,GAAG,CAACtC,QAAQ,gMAACoV,0BAA0B,CAAC;KAClD,CAAC;IACF,IAAIN,SAAS,EAAE;QACb,MAAMrS,IAAI,GAAGsS,SAAS,CAAC,CAAC,CAAC;QACzB,OAAOxT,iBAAiB,CACtBC,OAAO,EACP,CAAC,CAAC6T,IAAI,EAAE1O,OAAO,CAAC,GAAKzF,IAAI,sNAACmQ,cAAc,CAAC5O,IAAI,EAAEhD,OAAO,gMAAC6R,GAAG,CAAC3K,OAAO,EAAErF,MAAM,4MAACgU,OAAO,EAAED,IAAI,CAAC,CAAC,EAC1F,CAAC,CAACA,IAAI,IAAIF,KAAK,EAAEI,aAAa,CAAC,EAAEnT,IAAI,GAAKnB,UAAU,gNAACuU,OAAO,CAACH,IAAI,EAAEjT,IAAI,EAAE+S,KAAK,EAAEI,aAAa,CAAC,CAC/F;IACH;IACA,QAAQ9S,IAA0B,GAChClB,iBAAiB,CACfC,OAAO,EACP,CAAC,CAAC6T,IAAI,EAAE1O,OAAO,CAAC,GAAKzF,IAAI,sNAACmQ,cAAc,CAAC5O,IAAI,EAAEhD,OAAO,gMAAC6R,GAAG,CAAC3K,OAAO,EAAErF,MAAM,4MAACgU,OAAO,EAAED,IAAI,CAAC,CAAC,EAC1F,CAAC,CAACA,IAAI,IAAIF,KAAK,EAAEI,aAAa,CAAC,EAAEnT,IAAI,GAAKnB,UAAU,gNAACuU,OAAO,CAACH,IAAI,EAAEjT,IAAI,EAAE+S,KAAK,EAAEI,aAAa,CAAC,CAC/F;AACL,CAAQ;AAGD,MAAME,QAAQ,GAAGA,CACtB,GAAGC,IAAoB,GACMC,UAAU,CAACnW,KAAK,gMAACoW,YAAY,CAACF,IAAI,CAAC,CAAC;AAG5D,MAAMC,UAAU,IACrBD,IAA0B,GACGG,gBAAgB,CAAC,CAAC,EAAEH,IAAI,CAACvC,MAAM,EAAEuC,IAAI,CAAC;AAErE,cAAA,GACA,MAAMG,gBAAgB,GAAGA,CACvBC,GAAW,EACXC,GAAW,EACX/C,KAA2B,KACC;IAC5B,OAAO8C,GAAG,KAAKC,GAAG,GACd7U,IAAI,sNAACY,IAAI,+MACT1B,OAAAA,AAAI,EACJc,IAAI,sNAACuC,KAAK,CAACrD,mNAAAA,AAAI,EAAC4S,KAAK,EAAExT,KAAK,gMAACoV,SAAS,CAACkB,GAAG,CAAC,CAAC,CAAC,EAC7C5U,IAAI,sNAACS,OAAO,CAAC,IAAMkU,gBAAgB,CAACC,GAAG,GAAG,CAAC,EAAEC,GAAG,EAAE/C,KAAK,CAAC,CAAC,CAC1D;AACL,CAAC;AAGM,MAAMgD,GAAG,GAAA,WAAA,GAAG9V,mNAAAA,AAAI,GAiCpB+V,IAAI,GAAK/U,IAAI,sNAACgV,SAAS,CAACD,IAAI,CAAC,CAAC,CAAC,CAAC,EACjC,CACExT,IAA2E,EAC3E6N,IAAkF,EAClFxN,OAEC,GAUDA,OAAO,EAAEqT,UAAU,GACjBxN,SAAS,CAAClG,IAAI,EAAE;QACdmG,KAAK,EAAE0H,IAAI;QACXzH,UAAU,GAAGuN,KAAK,GAAKvV,aAAa,uNAACwV,KAAK,EAAEC,KAAK,GAAK3W,MAAM,gMAACoD,OAAO,CAAC,IAAMjD,IAAI,gMAACkW,GAAG,CAACI,KAAK,EAAEE,KAAK,CAAC,CAAC,CAAC;QACnGtN,WAAW,GAAGsN,KAAK,GAAKzV,aAAa,uNAACwV,KAAK,EAAED,KAAK,GAAKzW,MAAM,gMAACoD,OAAO,CAAC,IAAMjD,IAAI,gMAACkW,GAAG,CAACI,KAAK,EAAEE,KAAK,CAAC,CAAC;KACpG,CAAC,GACFpV,IAAI,sNAACS,OAAO,CAACc,IAAI,EAAGP,CAAC,IAAKS,GAAG,CAAC2N,IAAI,GAAGiG,CAAC,GAAK;gBAACrU,CAAC;gBAAEqU,CAAC;aAAU,CAAC,CAAC,CACjE;AAGM,MAAMC,OAAO,GAAA,WAAA,+MAAGtW,OAAAA,AAAI,GAiCxB+V,IAAI,GAAK/U,IAAI,sNAACgV,SAAS,CAACD,IAAI,CAAC,CAAC,CAAC,CAAC,EACjC,CACExT,IAA2E,EAC3E6N,IAAkF,EAClFxN,OAEC,GAUDA,OAAO,EAAEqT,UAAU,GACjBxT,GAAG,CAACqT,GAAG,CAACvT,IAAI,EAAE6N,IAAI,EAAE;QAAE6F,UAAU,EAAE;IAAI,CAAE,CAAC,GAAGM,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,GAC/DvV,IAAI,sNAACS,OAAO,CAACc,IAAI,GAAG4G,CAAC,GAAK7G,EAAE,CAAC8N,IAAI,EAAEjH,CAAC,CAAC,CAAC,CAC3C;AAGM,MAAMuB,QAAQ,GAAA,WAAA,IAAG1K,kNAAAA,AAAI,GAiCzB+V,IAAI,GAAK/U,IAAI,sNAACgV,SAAS,CAACD,IAAI,CAAC,CAAC,CAAC,CAAC,EACjC,CACExT,IAA2E,EAC3E6N,IAAkF,EAClFxN,OAEC,GAUDA,OAAO,EAAEqT,UAAU,GACjBxT,GAAG,CAACqT,GAAG,CAACvT,IAAI,EAAE6N,IAAI,EAAE;QAAE6F,UAAU,EAAE;IAAI,CAAE,CAAC,GAAGM,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,GAC/DvV,IAAI,sNAACS,OAAO,CAACc,IAAI,EAAE,IAAM6N,IAAI,CAAC,CACnC;AAGM,MAAMoG,sBAAsB,GAAA,WAAA,GAAmCC,MAAM,CAACC,GAAG,CAC9E,iCAAiC,CACA;AAG5B,MAAMjG,gBAAgB,IAAOhN,KAAQ,GAAA,CAAmC;QAC7EyD,IAAI,EAAE,kBAAkB;QACxB,CAACsP,sBAAsB,CAAA,EAAGA,sBAAsB;QAChD/S;KACD,CAAC;AAGK,MAAMoN,kBAAkB,IAAI8F,CAAU,gNAC3CtW,cAAAA,AAAW,EAACsW,CAAC,EAAEH,sBAAsB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 712, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}