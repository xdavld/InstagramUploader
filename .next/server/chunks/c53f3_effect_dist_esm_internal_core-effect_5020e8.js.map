{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"core-effect.js","sources":["file:///Users/david/src/5.%20Semester/SoftwareEngineering-Project/node_modules/.pnpm/effect%403.10.3/node_modules/effect/src/internal/core-effect.ts"],"sourcesContent":["import type { Exit } from \"effect/Exit\"\nimport { internalCall } from \"effect/Utils\"\nimport * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport * as FiberRefs from \"../FiberRefs.js\"\nimport type * as FiberRefsPatch from \"../FiberRefsPatch.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constFalse, constTrue, constVoid, dual, identity, pipe } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as List from \"../List.js\"\nimport * as LogLevel from \"../LogLevel.js\"\nimport * as LogSpan from \"../LogSpan.js\"\nimport type * as Metric from \"../Metric.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as Option from \"../Option.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport type * as Random from \"../Random.js\"\nimport * as Ref from \"../Ref.js\"\nimport type * as runtimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport * as Tracer from \"../Tracer.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport type { Unify } from \"../Unify.js\"\nimport { yieldWrapGet } from \"../Utils.js\"\nimport * as internalCause from \"./cause.js\"\nimport { clockTag } from \"./clock.js\"\nimport * as core from \"./core.js\"\nimport * as defaultServices from \"./defaultServices.js\"\nimport * as doNotation from \"./doNotation.js\"\nimport * as fiberRefsPatch from \"./fiberRefs/patch.js\"\nimport type { FiberRuntime } from \"./fiberRuntime.js\"\nimport * as metricLabel from \"./metric/label.js\"\nimport * as runtimeFlags from \"./runtimeFlags.js\"\nimport * as internalTracer from \"./tracer.js\"\n\n/* @internal */\nexport const annotateLogs = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: unknown): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, unknown>): Effect.Effect<A, E, R>\n  }\n>(\n  (args) => core.isEffect(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return core.fiberRefLocallyWith(\n      args[0] as Effect.Effect<A, E, R>,\n      core.currentLogAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n/* @internal */\nexport const asSome = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Option.Option<A>, E, R> =>\n  core.map(self, Option.some)\n\n/* @internal */\nexport const asSomeError = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Option.Option<E>, R> =>\n  core.mapError(self, Option.some)\n\n/* @internal */\nexport const try_: {\n  <A, E>(options: {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }): Effect.Effect<A, E>\n  <A>(thunk: LazyArg<A>): Effect.Effect<A, Cause.UnknownException>\n} = <A, E>(\n  arg: LazyArg<A> | {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }\n) => {\n  let evaluate: LazyArg<A>\n  let onFailure: ((error: unknown) => E) | undefined = undefined\n  if (typeof arg === \"function\") {\n    evaluate = arg\n  } else {\n    evaluate = arg.try\n    onFailure = arg.catch\n  }\n  return core.sync(() => {\n    try {\n      return evaluate()\n    } catch (error) {\n      throw core.makeEffectError(internalCause.fail(\n        onFailure ? onFailure(error) : new core.UnknownException(error)\n      ))\n    }\n  })\n}\n\n/* @internal */\nexport const _catch: {\n  <N extends keyof E, K extends E[N] & string, E, A1, E1, R1>(\n    discriminator: N,\n    options: {\n      readonly failure: K\n      readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect.Effect<A1, E1, R1>\n    }\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<\n    A | A1,\n    Exclude<E, { [n in N]: K }> | E1,\n    R | R1\n  >\n  <A, E, R, N extends keyof E, K extends E[N] & string, A1, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    discriminator: N,\n    options: {\n      readonly failure: K\n      readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect.Effect<A1, E1, R1>\n    }\n  ): Effect.Effect<A | A1, Exclude<E, { [n in N]: K }> | E1, R | R1>\n} = dual(\n  3,\n  (self, tag, options) =>\n    core.catchAll(self, (e) => {\n      if (Predicate.hasProperty(e, tag) && e[tag] === options.failure) {\n        return options.onFailure(e)\n      }\n      return core.fail(e)\n    })\n)\n\n/* @internal */\nexport const catchAllDefect = dual<\n  <A2, E2, R2>(\n    f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  core.catchAllCause(\n    self,\n    (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n      const option = internalCause.find(cause, (_) => internalCause.isDieType(_) ? Option.some(_) : Option.none())\n      switch (option._tag) {\n        case \"None\": {\n          return core.failCause(cause)\n        }\n        case \"Some\": {\n          return f(option.value.defect)\n        }\n      }\n    }\n  ))\n\n/* @internal */\nexport const catchSomeCause: {\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E | E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E | E2, R2 | R> =>\n    core.matchCauseEffect(self, {\n      onFailure: (cause): Effect.Effect<A2, E | E2, R2> => {\n        const option = f(cause)\n        switch (option._tag) {\n          case \"None\": {\n            return core.failCause(cause)\n          }\n          case \"Some\": {\n            return option.value\n          }\n        }\n      },\n      onSuccess: core.succeed\n    })\n)\n\n/* @internal */\nexport const catchSomeDefect = dual<\n  <A2, E2, R2>(\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A | A2, E | E2, R | R2> =>\n    core.catchAllCause(\n      self,\n      (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n        const option = internalCause.find(cause, (_) => internalCause.isDieType(_) ? Option.some(_) : Option.none())\n        switch (option._tag) {\n          case \"None\": {\n            return core.failCause(cause)\n          }\n          case \"Some\": {\n            const optionEffect = pf(option.value.defect)\n            return optionEffect._tag === \"Some\" ? optionEffect.value : core.failCause(cause)\n          }\n        }\n      }\n    )\n)\n\n/* @internal */\nexport const catchTag = dual<\n  <K extends (E extends { _tag: string } ? E[\"_tag\"] : never), E, A1, E1, R1>(\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A1, Exclude<E, { _tag: K }> | E1, R | R1>,\n  <A, E, R, K extends (E extends { _tag: string } ? E[\"_tag\"] : never), R1, E1, A1>(\n    self: Effect.Effect<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => Effect.Effect<A | A1, Exclude<E, { _tag: K }> | E1, R | R1>\n>(3, <A, E, R, K extends (E extends { _tag: string } ? E[\"_tag\"] : never), R1, E1, A1>(\n  self: Effect.Effect<A, E, R>,\n  k: K,\n  f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n): Effect.Effect<A | A1, Exclude<E, { _tag: K }> | E1, R | R1> =>\n  core.catchIf(self, Predicate.isTagged(k) as Predicate.Refinement<E, Extract<E, { _tag: K }>>, f) as any)\n\n/** @internal */\nexport const catchTags: {\n  <\n    E,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Effect.Effect<any, any, any>\n      } :\n      {})\n  >(\n    cases: Cases\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<infer A, any, any>) ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n    }[keyof Cases]\n  >\n  <\n    R,\n    E,\n    A,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Effect.Effect<any, any, any>\n      } :\n      {})\n  >(\n    self: Effect.Effect<A, E, R>,\n    cases: Cases\n  ): Effect.Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<infer A, any, any>) ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n    }[keyof Cases]\n  >\n} = dual(2, (self, cases) => {\n  let keys: Array<string>\n  return core.catchIf(\n    self,\n    (e): e is { readonly _tag: string } => {\n      keys ??= Object.keys(cases)\n      return Predicate.hasProperty(e, \"_tag\") && Predicate.isString(e[\"_tag\"]) && keys.includes(e[\"_tag\"])\n    },\n    (e) => cases[e[\"_tag\"]](e)\n  )\n})\n\n/* @internal */\nexport const cause = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Cause.Cause<E>, never, R> =>\n  core.matchCause(self, { onFailure: identity, onSuccess: () => internalCause.empty })\n\n/* @internal */\nexport const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  Clock.clockWith\n\n/* @internal */\nexport const clock: Effect.Effect<Clock.Clock> = clockWith(core.succeed)\n\n/* @internal */\nexport const delay = dual<\n  (duration: Duration.DurationInput) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, duration: Duration.DurationInput) => Effect.Effect<A, E, R>\n>(2, (self, duration) => core.zipRight(Clock.sleep(duration), self))\n\n/* @internal */\nexport const descriptorWith = <A, E, R>(\n  f: (descriptor: Fiber.Fiber.Descriptor) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  core.withFiberRuntime((state, status) =>\n    f({\n      id: state.id(),\n      status,\n      interruptors: internalCause.interruptors(state.getFiberRef(core.currentInterruptedCause))\n    })\n  ) as Effect.Effect<A, E, R>\n\n/* @internal */\nexport const allowInterrupt: Effect.Effect<void> = descriptorWith(\n  (descriptor) =>\n    HashSet.size(descriptor.interruptors) > 0\n      ? core.interrupt\n      : core.void\n)\n\n/* @internal */\nexport const descriptor: Effect.Effect<Fiber.Fiber.Descriptor> = descriptorWith(core.succeed)\n\n/* @internal */\nexport const diffFiberRefs = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R> => summarized(self, fiberRefs, fiberRefsPatch.diff)\n\n/* @internal */\nexport const diffFiberRefsAndRuntimeFlags = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[[FiberRefsPatch.FiberRefsPatch, runtimeFlagsPatch.RuntimeFlagsPatch], A], E, R> =>\n  summarized(\n    self,\n    core.zip(fiberRefs, core.runtimeFlags),\n    ([refs, flags], [refsNew, flagsNew]) => [fiberRefsPatch.diff(refs, refsNew), runtimeFlags.diff(flags, flagsNew)]\n  )\n\n/* @internal */\nexport const Do: Effect.Effect<{}> = core.succeed({})\n\n/* @internal */\nexport const bind: {\n  <N extends string, A extends object, B, E2, R2>(\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): <E1, R1>(\n    self: Effect.Effect<A, E1, R1>\n  ) => Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E2 | E1, R2 | R1>\n  <A extends object, N extends string, E1, R1, B, E2, R2>(\n    self: Effect.Effect<A, E1, R1>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E1 | E2, R1 | R2>\n} = doNotation.bind<Effect.EffectTypeLambda>(core.map, core.flatMap)\n\n/* @internal */\nexport const bindTo: {\n  <N extends string>(name: N): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<{ [K in N]: A }, E, R>\n  <A, E, R, N extends string>(self: Effect.Effect<A, E, R>, name: N): Effect.Effect<{ [K in N]: A }, E, R>\n} = doNotation.bindTo<Effect.EffectTypeLambda>(core.map)\n\n/* @internal */\nexport const let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n  <A extends object, N extends string, E, R, B>(\n    self: Effect.Effect<A, E, R>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n} = doNotation.let_<Effect.EffectTypeLambda>(core.map)\n\n/* @internal */\nexport const dropUntil: {\n  <A, E, R>(\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let dropping: Effect.Effect<boolean, E, R> = core.succeed(false)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        dropping = core.flatMap(dropping, (bool) => {\n          if (bool) {\n            builder.push(a)\n            return core.succeed(true)\n          }\n          return predicate(a, index)\n        })\n      }\n      return core.map(dropping, () => builder)\n    })\n)\n\n/* @internal */\nexport const dropWhile: {\n  <A, E, R>(\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next\n      let dropping: Effect.Effect<boolean, E, R> = core.succeed(true)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        dropping = core.flatMap(dropping, (d) =>\n          core.map(d ? predicate(a, index) : core.succeed(false), (b) => {\n            if (!b) {\n              builder.push(a)\n            }\n            return b\n          }))\n      }\n      return core.map(dropping, () => builder)\n    })\n)\n\n/* @internal */\nexport const contextWith = <R, A>(f: (context: Context.Context<R>) => A): Effect.Effect<A, never, R> =>\n  core.map(core.context<R>(), f)\n\n/* @internal */\nexport const eventually = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> =>\n  core.orElse(self, () => core.flatMap(core.yieldNow(), () => eventually(self)))\n\n/* @internal */\nexport const filterMap = dual<\n  <Eff extends Effect.Effect<any, any, any>, B>(\n    pf: (a: Effect.Effect.Success<Eff>) => Option.Option<B>\n  ) => (elements: Iterable<Eff>) => Effect.Effect<Array<B>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>,\n  <Eff extends Effect.Effect<any, any, any>, B>(\n    elements: Iterable<Eff>,\n    pf: (a: Effect.Effect.Success<Eff>) => Option.Option<B>\n  ) => Effect.Effect<Array<B>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>\n>(2, (elements, pf) =>\n  core.map(\n    core.forEachSequential(elements, identity),\n    Arr.filterMap(pf)\n  ))\n\n/* @internal */\nexport const filterOrDie: {\n  <A, B extends A>(\n    refinement: Predicate.Refinement<NoInfer<A>, B>,\n    orDieWith: (a: NoInfer<A>) => unknown\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A>(\n    predicate: Predicate.Predicate<NoInfer<A>>,\n    orDieWith: (a: NoInfer<A>) => unknown\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orDieWith: (a: A) => unknown\n  ): Effect.Effect<B, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orDieWith: (a: A) => unknown\n  ): Effect.Effect<A, E, R>\n} = dual(\n  3,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orDieWith: (a: A) => unknown\n  ): Effect.Effect<A, E, R> => filterOrElse(self, predicate, (a) => core.dieSync(() => orDieWith(a)))\n)\n\n/* @internal */\nexport const filterOrDieMessage: {\n  <A, B extends A>(\n    refinement: Predicate.Refinement<NoInfer<A>, B>,\n    message: string\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A>(\n    predicate: Predicate.Predicate<NoInfer<A>>,\n    message: string\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    message: string\n  ): Effect.Effect<B, E, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, predicate: Predicate.Predicate<A>, message: string): Effect.Effect<A, E, R>\n} = dual(\n  3,\n  <A, E, R>(self: Effect.Effect<A, E, R>, predicate: Predicate.Predicate<A>, message: string): Effect.Effect<A, E, R> =>\n    filterOrElse(self, predicate, () => core.dieMessage(message))\n)\n\n/* @internal */\nexport const filterOrElse: {\n  <A, B extends A, C, E2, R2>(\n    refinement: Predicate.Refinement<NoInfer<A>, B>,\n    orElse: (a: NoInfer<A>) => Effect.Effect<C, E2, R2>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B | C, E2 | E, R2 | R>\n  <A, B, E2, R2>(\n    predicate: Predicate.Predicate<NoInfer<A>>,\n    orElse: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | B, E2 | E, R2 | R>\n  <A, E, R, B extends A, C, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orElse: (a: A) => Effect.Effect<C, E2, R2>\n  ): Effect.Effect<B | C, E | E2, R | R2>\n  <A, E, R, B, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orElse: (a: A) => Effect.Effect<B, E2, R2>\n  ): Effect.Effect<A | B, E | E2, R | R2>\n} = dual(3, <A, E, R, B, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate.Predicate<A>,\n  orElse: (a: A) => Effect.Effect<B, E2, R2>\n): Effect.Effect<A | B, E | E2, R | R2> =>\n  core.flatMap(\n    self,\n    (a) => predicate(a) ? core.succeed<A | B>(a) : orElse(a)\n  ))\n\n/** @internal */\nexport const liftPredicate = dual<\n  {\n    <A, B extends A, E>(\n      refinement: Predicate.Refinement<NoInfer<A>, B>,\n      orFailWith: (a: NoInfer<A>) => E\n    ): (a: A) => Effect.Effect<B, E>\n    <A, E>(\n      predicate: Predicate.Predicate<NoInfer<A>>,\n      orFailWith: (a: NoInfer<A>) => E\n    ): (a: A) => Effect.Effect<A, E>\n  },\n  {\n    <A, E, B extends A>(\n      self: A,\n      refinement: Predicate.Refinement<A, B>,\n      orFailWith: (a: A) => E\n    ): Effect.Effect<B, E>\n    <A, E>(\n      self: A,\n      predicate: Predicate.Predicate<NoInfer<A>>,\n      orFailWith: (a: NoInfer<A>) => E\n    ): Effect.Effect<A, E>\n  }\n>(\n  3,\n  <A, E>(\n    self: A,\n    predicate: Predicate.Predicate<NoInfer<A>>,\n    orFailWith: (a: NoInfer<A>) => E\n  ): Effect.Effect<A, E> => core.suspend(() => predicate(self) ? core.succeed(self) : core.fail(orFailWith(self)))\n)\n\n/* @internal */\nexport const filterOrFail: {\n  <A, B extends A, E2>(\n    refinement: Predicate.Refinement<NoInfer<A>, B>,\n    orFailWith: (a: NoInfer<A>) => E2\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E2 | E, R>\n  <A, E2>(\n    predicate: Predicate.Predicate<NoInfer<A>>,\n    orFailWith: (a: NoInfer<A>) => E2\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2 | E, R>\n  <A, B extends A>(\n    refinement: Predicate.Refinement<NoInfer<A>, B>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, Cause.NoSuchElementException | E, R>\n  <A>(\n    predicate: Predicate.Predicate<NoInfer<A>>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, Cause.NoSuchElementException | E, R>\n  <A, E, R, B extends A, E2>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orFailWith: (a: A) => E2\n  ): Effect.Effect<B, E | E2, R>\n  <A, E, R, E2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orFailWith: (a: A) => E2\n  ): Effect.Effect<A, E | E2, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>\n  ): Effect.Effect<B, E | Cause.NoSuchElementException, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>\n  ): Effect.Effect<A, E | Cause.NoSuchElementException, R>\n} = dual((args) => core.isEffect(args[0]), <A, E, R, E2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate.Predicate<A>,\n  orFailWith?: (a: A) => E2\n): Effect.Effect<A, E | E2 | Cause.NoSuchElementException, R> =>\n  filterOrElse(\n    self,\n    predicate,\n    (a): Effect.Effect<never, E2 | Cause.NoSuchElementException, never> =>\n      orFailWith === undefined ? core.fail(new core.NoSuchElementException()) : core.failSync(() => orFailWith(a))\n  ))\n\n/* @internal */\nexport const findFirst: {\n  <A, E, R>(\n    f: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Option.Option<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    f: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    f: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const next = iterator.next()\n      if (!next.done) {\n        return findLoop(iterator, 0, f, next.value)\n      }\n      return core.succeed(Option.none())\n    })\n)\n\nconst findLoop = <A, E, R>(\n  iterator: Iterator<A>,\n  index: number,\n  f: (a: A, i: number) => Effect.Effect<boolean, E, R>,\n  value: A\n): Effect.Effect<Option.Option<A>, E, R> =>\n  core.flatMap(f(value, index), (result) => {\n    if (result) {\n      return core.succeed(Option.some(value))\n    }\n    const next = iterator.next()\n    if (!next.done) {\n      return findLoop(iterator, index + 1, f, next.value)\n    }\n    return core.succeed(Option.none())\n  })\n\n/* @internal */\nexport const firstSuccessOf = <Eff extends Effect.Effect<any, any, any>>(\n  effects: Iterable<Eff>\n): Effect.Effect<Effect.Effect.Success<Eff>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>> =>\n  core.suspend(() => {\n    const list = Chunk.fromIterable(effects)\n    if (!Chunk.isNonEmpty(list)) {\n      return core.dieSync(() => new core.IllegalArgumentException(`Received an empty collection of effects`))\n    }\n    return pipe(\n      Chunk.tailNonEmpty(list),\n      Arr.reduce(Chunk.headNonEmpty(list), (left, right) => core.orElse(left, () => right) as Eff)\n    )\n  })\n\n/* @internal */\nexport const flipWith: {\n  <E, A, R, E2, A2, R2>(\n    f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n  ): (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>\n  <A, E, R, E2, A2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n  ): Effect.Effect<A2, E2, R2>\n} = dual(2, <A, E, R, E2, A2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n): Effect.Effect<A2, E2, R2> => core.flip(f(core.flip(self))))\n\n/* @internal */\nexport const match: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (error: E) => A2\n    readonly onSuccess: (value: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  core.matchEffect(self, {\n    onFailure: (e) => core.succeed(options.onFailure(e)),\n    onSuccess: (a) => core.succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const every: {\n  <A, E, R>(\n    f: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<boolean, E, R>\n  <A, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect.Effect<boolean, E, R>): Effect.Effect<boolean, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    f: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<boolean, E, R> => core.suspend(() => forAllLoop(elements[Symbol.iterator](), 0, f))\n)\n\nconst forAllLoop = <A, E, R>(\n  iterator: Iterator<A>,\n  index: number,\n  f: (a: A, i: number) => Effect.Effect<boolean, E, R>\n): Effect.Effect<boolean, E, R> => {\n  const next = iterator.next()\n  return next.done\n    ? core.succeed(true)\n    : core.flatMap(\n      f(next.value, index),\n      (b) => b ? forAllLoop(iterator, index + 1, f) : core.succeed(b)\n    )\n}\n\n/* @internal */\nexport const forever = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<never, E, R> => {\n  const loop: Effect.Effect<never, E, R> = core.flatMap(core.flatMap(self, () => core.yieldNow()), () => loop)\n  return loop\n}\n\n/**\n * Inspired by https://github.com/tusharmath/qio/pull/22 (revised)\n  @internal */\nexport const gen: typeof Effect.gen = function() {\n  let f: any\n  if (arguments.length === 1) {\n    f = arguments[0]\n  } else {\n    f = arguments[1].bind(arguments[0])\n  }\n  return core.suspend(() => {\n    const iterator = f(pipe)\n    const state = internalCall(() => iterator.next())\n    const run = (\n      state: IteratorYieldResult<any> | IteratorReturnResult<any>\n    ): Effect.Effect<any, any, any> => {\n      return (state.done\n        ? core.succeed(state.value)\n        : core.flatMap(\n          yieldWrapGet(state.value) as any,\n          (val: any) => run(internalCall(() => iterator.next(val)))\n        ))\n    }\n    return run(state)\n  })\n}\n\n/* @internal */\nexport const fiberRefs: Effect.Effect<FiberRefs.FiberRefs> = core.withFiberRuntime((state) =>\n  core.succeed(state.getFiberRefs())\n)\n\n/* @internal */\nexport const head = <A, E, R>(\n  self: Effect.Effect<Iterable<A>, E, R>\n): Effect.Effect<A, E | Cause.NoSuchElementException, R> =>\n  core.flatMap(self, (as) => {\n    const iterator = as[Symbol.iterator]()\n    const next = iterator.next()\n    if (next.done) {\n      return core.fail(new core.NoSuchElementException())\n    }\n    return core.succeed(next.value)\n  })\n\n/* @internal */\nexport const ignore = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, never, R> =>\n  match(self, { onFailure: constVoid, onSuccess: constVoid })\n\n/* @internal */\nexport const ignoreLogged = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, never, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => logDebug(cause, \"An error was silently ignored because it is not anticipated to be useful\"),\n    onSuccess: () => core.void\n  })\n\n/* @internal */\nexport const inheritFiberRefs = (childFiberRefs: FiberRefs.FiberRefs) =>\n  updateFiberRefs((parentFiberId, parentFiberRefs) => FiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs))\n\n/* @internal */\nexport const isFailure = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<boolean, never, R> =>\n  match(self, { onFailure: constTrue, onSuccess: constFalse })\n\n/* @internal */\nexport const isSuccess = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<boolean, never, R> =>\n  match(self, { onFailure: constFalse, onSuccess: constTrue })\n\n/* @internal */\nexport const iterate: {\n  <A, B extends A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly body: (b: B) => Effect.Effect<A, E, R>\n    }\n  ): Effect.Effect<A, E, R>\n  <A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Predicate<A>\n      readonly body: (a: A) => Effect.Effect<A, E, R>\n    }\n  ): Effect.Effect<A, E, R>\n} = <A, E, R>(\n  initial: A,\n  options: {\n    readonly while: Predicate.Predicate<A>\n    readonly body: (z: A) => Effect.Effect<A, E, R>\n  }\n): Effect.Effect<A, E, R> =>\n  core.suspend<A, E, R>(() => {\n    if (options.while(initial)) {\n      return core.flatMap(options.body(initial), (z2) => iterate(z2, options))\n    }\n    return core.succeed(initial)\n  })\n\n/** @internal */\nexport const logWithLevel = (level?: LogLevel.LogLevel) =>\n(\n  ...message: ReadonlyArray<any>\n): Effect.Effect<void> => {\n  const levelOption = Option.fromNullable(level)\n  let cause: Cause.Cause<unknown> | undefined = undefined\n  for (let i = 0, len = message.length; i < len; i++) {\n    const msg = message[i]\n    if (internalCause.isCause(msg)) {\n      if (cause !== undefined) {\n        cause = internalCause.sequential(cause, msg)\n      } else {\n        cause = msg\n      }\n      message = [...message.slice(0, i), ...message.slice(i + 1)]\n      i--\n    }\n  }\n  if (cause === undefined) {\n    cause = internalCause.empty\n  }\n  return core.withFiberRuntime((fiberState) => {\n    fiberState.log(message, cause, levelOption)\n    return core.void\n  })\n}\n\n/** @internal */\nexport const log: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel()\n\n/** @internal */\nexport const logTrace: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Trace\n)\n\n/** @internal */\nexport const logDebug: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Debug\n)\n\n/** @internal */\nexport const logInfo: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Info\n)\n\n/** @internal */\nexport const logWarning: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Warning\n)\n\n/** @internal */\nexport const logError: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Error\n)\n\n/** @internal */\nexport const logFatal: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Fatal\n)\n\n/* @internal */\nexport const withLogSpan = dual<\n  (label: string) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, label: string) => Effect.Effect<A, E, R>\n>(2, (effect, label) =>\n  core.flatMap(Clock.currentTimeMillis, (now) =>\n    core.fiberRefLocallyWith(\n      effect,\n      core.currentLogSpan,\n      List.prepend(LogSpan.make(label, now))\n    )))\n\n/* @internal */\nexport const logAnnotations: Effect.Effect<HashMap.HashMap<string, unknown>> = core\n  .fiberRefGet(\n    core.currentLogAnnotations\n  )\n\n/* @internal */\nexport const loop: {\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect.Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect.Effect<Array<C>, E, R>\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect.Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect.Effect<Array<C>, E, R>\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect.Effect<R, E, C>\n      readonly discard: true\n    }\n  ): Effect.Effect<void, E, R>\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect.Effect<C, E, R>\n      readonly discard: true\n    }\n  ): Effect.Effect<void, E, R>\n} = <A, C, E, R>(\n  initial: A,\n  options: {\n    readonly while: Predicate.Predicate<A>\n    readonly step: (a: A) => A\n    readonly body: (a: A) => Effect.Effect<C, E, R>\n    readonly discard?: boolean | undefined\n  }\n): any =>\n  options.discard\n    ? loopDiscard(initial, options.while, options.step, options.body)\n    : core.map(loopInternal(initial, options.while, options.step, options.body), Arr.fromIterable)\n\nconst loopInternal = <Z, A, E, R>(\n  initial: Z,\n  cont: Predicate.Predicate<Z>,\n  inc: (z: Z) => Z,\n  body: (z: Z) => Effect.Effect<A, E, R>\n): Effect.Effect<List.List<A>, E, R> =>\n  core.suspend(() =>\n    cont(initial)\n      ? core.flatMap(body(initial), (a) =>\n        core.map(\n          loopInternal(inc(initial), cont, inc, body),\n          List.prepend(a)\n        ))\n      : core.sync(() => List.empty())\n  )\n\nconst loopDiscard = <S, X, E, R>(\n  initial: S,\n  cont: Predicate.Predicate<S>,\n  inc: (s: S) => S,\n  body: (s: S) => Effect.Effect<X, E, R>\n): Effect.Effect<void, E, R> =>\n  core.suspend(() =>\n    cont(initial)\n      ? core.flatMap(\n        body(initial),\n        () => loopDiscard(inc(initial), cont, inc, body)\n      )\n      : core.void\n  )\n\n/* @internal */\nexport const mapAccum: {\n  <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    zero: S,\n    f: (s: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n  ): (elements: I) => Effect.Effect<[S, Arr.ReadonlyArray.With<I, B>], E, R>\n  <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    elements: I,\n    zero: S,\n    f: (s: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n  ): Effect.Effect<[S, Arr.ReadonlyArray.With<I, B>], E, R>\n} = dual(3, <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(\n  elements: I,\n  zero: S,\n  f: (s: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n): Effect.Effect<[S, Array<B>], E, R> =>\n  core.suspend(() => {\n    const iterator = elements[Symbol.iterator]()\n    const builder: Array<B> = []\n    let result: Effect.Effect<S, E, R> = core.succeed(zero)\n    let next: IteratorResult<A, any>\n    let i = 0\n    while (!(next = iterator.next()).done) {\n      const index = i++\n      const value = next.value\n      result = core.flatMap(result, (state) =>\n        core.map(f(state, value, index), ([z, b]) => {\n          builder.push(b)\n          return z\n        }))\n    }\n    return core.map(result, (z) => [z, builder])\n  }))\n\n/* @internal */\nexport const mapErrorCause: {\n  <E, E2>(\n    f: (cause: Cause.Cause<E>) => Cause.Cause<E2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect.Effect<A, E2, R> =>\n    core.matchCauseEffect(self, {\n      onFailure: (c) => core.failCauseSync(() => f(c)),\n      onSuccess: core.succeed\n    })\n)\n\n/* @internal */\nexport const memoize = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Effect.Effect<A, E, R>> =>\n  pipe(\n    core.deferredMake<[[FiberRefsPatch.FiberRefsPatch, runtimeFlagsPatch.RuntimeFlagsPatch], A], E>(),\n    core.flatMap((deferred) =>\n      pipe(\n        diffFiberRefsAndRuntimeFlags(self),\n        core.intoDeferred(deferred),\n        once,\n        core.map((complete) =>\n          core.zipRight(\n            complete,\n            pipe(\n              core.deferredAwait(deferred),\n              core.flatMap(([patch, a]) =>\n                core.as(core.zip(patchFiberRefs(patch[0]), core.updateRuntimeFlags(patch[1])), a)\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n\n/* @internal */\nexport const merge = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E | A, never, R> =>\n  core.matchEffect(self, {\n    onFailure: (e) => core.succeed(e),\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const negate = <E, R>(self: Effect.Effect<boolean, E, R>): Effect.Effect<boolean, E, R> =>\n  core.map(self, (b) => !b)\n\n/* @internal */\nexport const none = <A, E, R>(\n  self: Effect.Effect<Option.Option<A>, E, R>\n): Effect.Effect<void, E | Cause.NoSuchElementException, R> =>\n  core.flatMap(self, (option) => {\n    switch (option._tag) {\n      case \"None\":\n        return core.void\n      case \"Some\":\n        return core.fail(new core.NoSuchElementException())\n    }\n  })\n\n/* @internal */\nexport const once = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Effect.Effect<void, E, R>> =>\n  core.map(\n    Ref.make(true),\n    (ref) => core.asVoid(core.whenEffect(self, Ref.getAndSet(ref, false)))\n  )\n\n/* @internal */\nexport const option = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Option.Option<A>, never, R> =>\n  core.matchEffect(self, {\n    onFailure: () => core.succeed(Option.none()),\n    onSuccess: (a) => core.succeed(Option.some(a))\n  })\n\n/* @internal */\nexport const orElseFail = dual<\n  <E2>(evaluate: LazyArg<E2>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, evaluate: LazyArg<E2>) => Effect.Effect<A, E2, R>\n>(2, (self, evaluate) => core.orElse(self, () => core.failSync(evaluate)))\n\n/* @internal */\nexport const orElseSucceed = dual<\n  <A2>(evaluate: LazyArg<A2>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, never, R>,\n  <A, E, R, A2>(self: Effect.Effect<A, E, R>, evaluate: LazyArg<A2>) => Effect.Effect<A | A2, never, R>\n>(2, (self, evaluate) => core.orElse(self, () => core.sync(evaluate)))\n\n/* @internal */\nexport const parallelErrors = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Array<E>, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const errors = Arr.fromIterable(internalCause.failures(cause))\n      return errors.length === 0\n        ? core.failCause(cause as Cause.Cause<never>)\n        : core.fail(errors)\n    },\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const patchFiberRefs = (patch: FiberRefsPatch.FiberRefsPatch): Effect.Effect<void> =>\n  updateFiberRefs((fiberId, fiberRefs) => pipe(patch, fiberRefsPatch.patch(fiberId, fiberRefs)))\n\n/* @internal */\nexport const promise = <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect.Effect<A> =>\n  evaluate.length >= 1\n    ? core.async((resolve, signal) => {\n      try {\n        evaluate(signal)\n          .then((a) => resolve(core.exitSucceed(a)), (e) => resolve(core.exitDie(e)))\n      } catch (e) {\n        resolve(core.exitDie(e))\n      }\n    })\n    : core.async((resolve) => {\n      try {\n        ;(evaluate as LazyArg<PromiseLike<A>>)()\n          .then((a) => resolve(core.exitSucceed(a)), (e) => resolve(core.exitDie(e)))\n      } catch (e) {\n        resolve(core.exitDie(e))\n      }\n    })\n\n/* @internal */\nexport const provideService = dual<\n  <T extends Context.Tag<any, any>>(\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Context.Tag.Identifier<T>>>,\n  <A, E, R, T extends Context.Tag<any, any>>(\n    self: Effect.Effect<A, E, R>,\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => Effect.Effect<A, E, Exclude<R, Context.Tag.Identifier<T>>>\n>(\n  3,\n  <A, E, R, T extends Context.Tag<any, any>>(\n    self: Effect.Effect<A, E, R>,\n    tag: T,\n    service: Context.Tag.Service<T>\n  ): Effect.Effect<A, E, Exclude<R, Context.Tag.Identifier<T>>> =>\n    core.contextWithEffect((env) =>\n      core.provideContext(\n        self as Effect.Effect<A, E, Context.Tag.Identifier<T> | Exclude<R, Context.Tag.Identifier<T>>>,\n        Context.add(env, tag, service)\n      )\n    )\n)\n\n/* @internal */\nexport const provideServiceEffect = dual<\n  <T extends Context.Tag<any, any>, E1, R1>(\n    tag: T,\n    effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R1 | Exclude<R, Context.Tag.Identifier<T>>>,\n  <A, E, R, T extends Context.Tag<any, any>, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    tag: T,\n    effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>\n  ) => Effect.Effect<A, E | E1, R1 | Exclude<R, Context.Tag.Identifier<T>>>\n>(3, <A, E, R, T extends Context.Tag<any, any>, E1, R1>(\n  self: Effect.Effect<A, E, R>,\n  tag: T,\n  effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>\n) =>\n  core.contextWithEffect((env: Context.Context<R1 | Exclude<R, Context.Tag.Identifier<T>>>) =>\n    core.flatMap(\n      effect,\n      (service) => core.provideContext(self, pipe(env, Context.add(tag, service)) as Context.Context<R | R1>)\n    )\n  ))\n\n/* @internal */\nexport const random: Effect.Effect<Random.Random> = defaultServices.randomWith(core.succeed)\n\n/* @internal */\nexport const reduce = dual<\n  <Z, A, E, R>(\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) => Effect.Effect<Z, E, R>\n>(\n  3,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) =>\n    Arr.fromIterable(elements).reduce(\n      (acc, el, i) => core.flatMap(acc, (a) => f(a, el, i)),\n      core.succeed(zero) as Effect.Effect<Z, E, R>\n    )\n)\n\n/* @internal */\nexport const reduceRight = dual<\n  <A, Z, R, E>(\n    zero: Z,\n    f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, R, E>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>\n  ) => Effect.Effect<Z, E, R>\n>(\n  3,\n  <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>) =>\n    Arr.fromIterable(elements).reduceRight(\n      (acc, el, i) => core.flatMap(acc, (a) => f(el, a, i)),\n      core.succeed(zero) as Effect.Effect<Z, E, R>\n    )\n)\n\n/* @internal */\nexport const reduceWhile = dual<\n  <Z, A, E, R>(\n    zero: Z,\n    options: {\n      readonly while: Predicate.Predicate<Z>\n      readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n    }\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    options: {\n      readonly while: Predicate.Predicate<Z>\n      readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n    }\n  ) => Effect.Effect<Z, E, R>\n>(3, <A, Z, E, R>(\n  elements: Iterable<A>,\n  zero: Z,\n  options: {\n    readonly while: Predicate.Predicate<Z>\n    readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  }\n) =>\n  core.flatMap(\n    core.sync(() => elements[Symbol.iterator]()),\n    (iterator) => reduceWhileLoop(iterator, 0, zero, options.while, options.body)\n  ))\n\nconst reduceWhileLoop = <A, R, E, Z>(\n  iterator: Iterator<A>,\n  index: number,\n  state: Z,\n  predicate: Predicate.Predicate<Z>,\n  f: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n): Effect.Effect<Z, E, R> => {\n  const next = iterator.next()\n  if (!next.done && predicate(state)) {\n    return core.flatMap(\n      f(state, next.value, index),\n      (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f)\n    )\n  }\n  return core.succeed(state)\n}\n\n/* @internal */\nexport const repeatN = dual<\n  (n: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, n: number) => Effect.Effect<A, E, R>\n>(2, (self, n) => core.suspend(() => repeatNLoop(self, n)))\n\n/* @internal */\nconst repeatNLoop = <A, E, R>(self: Effect.Effect<A, E, R>, n: number): Effect.Effect<A, E, R> =>\n  core.flatMap(self, (a) =>\n    n <= 0\n      ? core.succeed(a)\n      : core.zipRight(core.yieldNow(), repeatNLoop(self, n - 1)))\n\n/* @internal */\nexport const sandbox = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Cause.Cause<E>, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: core.fail,\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const setFiberRefs = (fiberRefs: FiberRefs.FiberRefs): Effect.Effect<void> =>\n  core.suspend(() => FiberRefs.setAll(fiberRefs))\n\n/* @internal */\nexport const sleep: (duration: Duration.DurationInput) => Effect.Effect<void> = Clock.sleep\n\n/* @internal */\nexport const succeedNone: Effect.Effect<Option.Option<never>> = core.succeed(Option.none())\n\n/* @internal */\nexport const succeedSome = <A>(value: A): Effect.Effect<Option.Option<A>> => core.succeed(Option.some(value))\n\n/* @internal */\nexport const summarized: {\n  <B, E2, R2, C>(\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[C, A], E2 | E, R2 | R>\n  <A, E, R, B, E2, R2, C>(\n    self: Effect.Effect<A, E, R>,\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): Effect.Effect<[C, A], E2 | E, R2 | R>\n} = dual(\n  3,\n  <A, E, R, B, E2, R2, C>(\n    self: Effect.Effect<A, E, R>,\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): Effect.Effect<[C, A], E2 | E, R2 | R> =>\n    core.flatMap(\n      summary,\n      (start) => core.flatMap(self, (value) => core.map(summary, (end) => [f(start, end), value]))\n    )\n)\n\n/* @internal */\nexport const tagMetrics = dual<\n  {\n    (key: string, value: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, string>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: string): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, string>): Effect.Effect<A, E, R>\n  }\n>((args) => core.isEffect(args[0]), function() {\n  return labelMetrics(\n    arguments[0],\n    typeof arguments[1] === \"string\"\n      ? [metricLabel.make(arguments[1], arguments[2])]\n      : Object.entries<string>(arguments[1]).map(([k, v]) => metricLabel.make(k, v))\n  )\n})\n\n/* @internal */\nexport const labelMetrics = dual<\n  (labels: Iterable<MetricLabel.MetricLabel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>) => Effect.Effect<A, E, R>\n>(\n  2,\n  (self, labels) => core.fiberRefLocallyWith(self, core.currentMetricLabels, (old) => Arr.union(old, labels))\n)\n\n/* @internal */\nexport const takeUntil: {\n  <A, R, E>(\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let effect: Effect.Effect<boolean, E, R> = core.succeed(false)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        effect = core.flatMap(effect, (bool) => {\n          if (bool) {\n            return core.succeed(true)\n          }\n          builder.push(a)\n          return predicate(a, index)\n        })\n      }\n      return core.map(effect, () => builder)\n    })\n)\n\n/* @internal */\nexport const takeWhile = dual<\n  <A, E, R>(\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ) => Effect.Effect<Array<A>, E, R>\n>(\n  2,\n  <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>) =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let taking: Effect.Effect<boolean, E, R> = core.succeed(true)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        taking = core.flatMap(taking, (taking) =>\n          pipe(\n            taking ? predicate(a, index) : core.succeed(false),\n            core.map((bool) => {\n              if (bool) {\n                builder.push(a)\n              }\n              return bool\n            })\n          ))\n      }\n      return core.map(taking, () => builder)\n    })\n)\n\n/* @internal */\nexport const tapBoth = dual<\n  <E, X, E2, R2, A, X1, E3, R3>(\n    options: {\n      readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X, E2, R2>\n      readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X1, E3, R3>\n    }\n  ) => <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2 | E3, R | R2 | R3>,\n  <A, E, R, X, E2, R2, X1, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<X, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<X1, E3, R3>\n    }\n  ) => Effect.Effect<A, E | E2 | E3, R | R2 | R3>\n>(2, (self, { onFailure, onSuccess }) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const either = internalCause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\": {\n          return core.zipRight(onFailure(either.left as any), core.failCause(cause))\n        }\n        case \"Right\": {\n          return core.failCause(cause)\n        }\n      }\n    },\n    onSuccess: (a) => core.as(onSuccess(a as any), a)\n  }))\n\n/* @internal */\nexport const tapDefect = dual<\n  <X, E2, R2>(\n    f: (cause: Cause.Cause<never>) => Effect.Effect<X, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<never>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.catchAllCause(self, (cause) =>\n    Option.match(internalCause.keepDefects(cause), {\n      onNone: () => core.failCause(cause),\n      onSome: (a) => core.zipRight(f(a), core.failCause(cause))\n    })))\n\n/* @internal */\nexport const tapError = dual<\n  <E, X, E2, R2>(\n    f: (e: NoInfer<E>) => Effect.Effect<X, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const either = internalCause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\":\n          return core.zipRight(f(either.left as any), core.failCause(cause))\n        case \"Right\":\n          return core.failCause(cause)\n      }\n    },\n    onSuccess: core.succeed\n  }))\n\n/* @internal */\nexport const tapErrorTag = dual<\n  <K extends (E extends { _tag: string } ? E[\"_tag\"] : never), E, A1, E1, R1>(\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R | R1>,\n  <A, E, R, K extends (E extends { _tag: string } ? E[\"_tag\"] : never), A1, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => Effect.Effect<A, E | E1, R | R1>\n>(3, (self, k, f) =>\n  tapError(self, (e) => {\n    if (Predicate.isTagged(e, k)) {\n      return f(e as any)\n    }\n    return core.void as any\n  }))\n\n/* @internal */\nexport const tapErrorCause = dual<\n  <E, X, E2, R2>(\n    f: (cause: Cause.Cause<NoInfer<E>>) => Effect.Effect<X, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => core.zipRight(f(cause), core.failCause(cause)),\n    onSuccess: core.succeed\n  }))\n\n/* @internal */\nexport const timed = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[Duration.Duration, A], E, R> => timedWith(self, Clock.currentTimeNanos)\n\n/* @internal */\nexport const timedWith = dual<\n  <E1, R1>(\n    nanoseconds: Effect.Effect<bigint, E1, R1>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[Duration.Duration, A], E | E1, R | R1>,\n  <A, E, R, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    nanoseconds: Effect.Effect<bigint, E1, R1>\n  ) => Effect.Effect<[Duration.Duration, A], E | E1, R | R1>\n>(\n  2,\n  (self, nanos) => summarized(self, nanos, (start, end) => Duration.nanos(end - start))\n)\n\n/* @internal */\nexport const tracerWith: <A, E, R>(f: (tracer: Tracer.Tracer) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  Tracer.tracerWith\n\n/** @internal */\nexport const tracer: Effect.Effect<Tracer.Tracer> = tracerWith(core.succeed)\n\n/* @internal */\nexport const tryPromise: {\n  <A, E>(\n    options: {\n      readonly try: (signal: AbortSignal) => PromiseLike<A>\n      readonly catch: (error: unknown) => E\n    }\n  ): Effect.Effect<A, E>\n  <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect.Effect<A, Cause.UnknownException>\n} = <A, E>(\n  arg: ((signal: AbortSignal) => PromiseLike<A>) | {\n    readonly try: (signal: AbortSignal) => PromiseLike<A>\n    readonly catch: (error: unknown) => E\n  }\n): Effect.Effect<A, E | Cause.UnknownException> => {\n  let evaluate: (signal?: AbortSignal) => PromiseLike<A>\n  let catcher: ((error: unknown) => E) | undefined = undefined\n  if (typeof arg === \"function\") {\n    evaluate = arg as (signal?: AbortSignal) => PromiseLike<A>\n  } else {\n    evaluate = arg.try as (signal?: AbortSignal) => PromiseLike<A>\n    catcher = arg.catch\n  }\n\n  if (evaluate.length >= 1) {\n    return core.async((resolve, signal) => {\n      try {\n        evaluate(signal)\n          .then(\n            (a) => resolve(core.exitSucceed(a)),\n            (e) => resolve(catcher ? core.failSync(() => catcher(e)) : core.fail(new core.UnknownException(e)))\n          )\n      } catch (e) {\n        resolve(catcher ? core.failSync(() => catcher(e)) : core.fail(new core.UnknownException(e)))\n      }\n    })\n  }\n\n  return core.async((resolve) => {\n    try {\n      evaluate()\n        .then(\n          (a) => resolve(core.exitSucceed(a)),\n          (e) => resolve(catcher ? core.failSync(() => catcher(e)) : core.fail(new core.UnknownException(e)))\n        )\n    } catch (e) {\n      resolve(catcher ? core.failSync(() => catcher(e)) : core.fail(new core.UnknownException(e)))\n    }\n  })\n}\n\n/* @internal */\nexport const tryMap = dual<\n  <A, B, E1>(\n    options: {\n      readonly try: (a: A) => B\n      readonly catch: (error: unknown) => E1\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E1, R>,\n  <A, E, R, B, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly try: (a: A) => B\n      readonly catch: (error: unknown) => E1\n    }\n  ) => Effect.Effect<B, E | E1, R>\n>(2, (self, options) =>\n  core.flatMap(self, (a) =>\n    try_({\n      try: () => options.try(a),\n      catch: options.catch\n    })))\n\n/* @internal */\nexport const tryMapPromise = dual<\n  <A, B, E1>(\n    options: {\n      readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n      readonly catch: (error: unknown) => E1\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E1, R>,\n  <A, E, R, B, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n      readonly catch: (error: unknown) => E1\n    }\n  ) => Effect.Effect<B, E | E1, R>\n>(2, <A, E, R, B, E1>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n    readonly catch: (error: unknown) => E1\n  }\n) =>\n  core.flatMap(self, (a) =>\n    tryPromise({\n      try: options.try.length >= 1\n        ? (signal) => options.try(a, signal)\n        : () => (options.try as (a: A) => PromiseLike<B>)(a),\n      catch: options.catch\n    })))\n\n/* @internal */\nexport const unless = dual<\n  (condition: LazyArg<boolean>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, condition: LazyArg<boolean>) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (self, condition) =>\n  core.suspend(() =>\n    condition()\n      ? succeedNone\n      : asSome(self)\n  ))\n\n/* @internal */\nexport const unlessEffect = dual<\n  <E2, R2>(\n    condition: Effect.Effect<boolean, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E | E2, R | R2>,\n  <A, E, R, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    condition: Effect.Effect<boolean, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n>(2, (self, condition) => core.flatMap(condition, (b) => (b ? succeedNone : asSome(self))))\n\n/* @internal */\nexport const unsandbox = <A, E, R>(self: Effect.Effect<A, Cause.Cause<E>, R>) =>\n  mapErrorCause(self, internalCause.flatten)\n\n/* @internal */\nexport const updateFiberRefs = (\n  f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs\n): Effect.Effect<void> =>\n  core.withFiberRuntime((state) => {\n    state.setFiberRefs(f(state.id(), state.getFiberRefs()))\n    return core.void\n  })\n\n/* @internal */\nexport const updateService = dual<\n  <T extends Context.Tag<any, any>>(\n    tag: T,\n    f: (service: Context.Tag.Service<T>) => Context.Tag.Service<T>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | Context.Tag.Identifier<T>>,\n  <A, E, R, T extends Context.Tag<any, any>>(\n    self: Effect.Effect<A, E, R>,\n    tag: T,\n    f: (service: Context.Tag.Service<T>) => Context.Tag.Service<T>\n  ) => Effect.Effect<A, E, R | Context.Tag.Identifier<T>>\n>(3, <A, E, R, T extends Context.Tag<any, any>>(\n  self: Effect.Effect<A, E, R>,\n  tag: T,\n  f: (service: Context.Tag.Service<T>) => Context.Tag.Service<T>\n) =>\n  core.mapInputContext(self, (context) =>\n    Context.add(\n      context,\n      tag,\n      f(Context.unsafeGet(context, tag))\n    )) as Effect.Effect<A, E, R | Context.Tag.Identifier<T>>)\n\n/* @internal */\nexport const when = dual<\n  (condition: LazyArg<boolean>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, condition: LazyArg<boolean>) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (self, condition) =>\n  core.suspend(() =>\n    condition()\n      ? core.map(self, Option.some)\n      : core.succeed(Option.none())\n  ))\n\n/* @internal */\nexport const whenFiberRef = dual<\n  <S>(\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[S, Option.Option<A>], E, R>,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) => Effect.Effect<[S, Option.Option<A>], E, R>\n>(\n  3,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) =>\n    core.flatMap(core.fiberRefGet(fiberRef), (s) =>\n      predicate(s)\n        ? core.map(self, (a) => [s, Option.some(a)])\n        : core.succeed<[S, Option.Option<A>]>([s, Option.none()]))\n)\n\n/* @internal */\nexport const whenRef = dual<\n  <S>(\n    ref: Ref.Ref<S>,\n    predicate: Predicate.Predicate<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[S, Option.Option<A>], E, R>,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    ref: Ref.Ref<S>,\n    predicate: Predicate.Predicate<S>\n  ) => Effect.Effect<[S, Option.Option<A>], E, R>\n>(\n  3,\n  <A, E, R, S>(self: Effect.Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate.Predicate<S>) =>\n    core.flatMap(Ref.get(ref), (s) =>\n      predicate(s)\n        ? core.map(self, (a) => [s, Option.some(a)])\n        : core.succeed<[S, Option.Option<A>]>([s, Option.none()]))\n)\n\n/* @internal */\nexport const withMetric = dual<\n  <Type, In, Out>(\n    metric: Metric.Metric<Type, In, Out>\n  ) => <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A extends In, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, metric) => metric(self))\n\n/** @internal */\nexport const serviceFunctionEffect = <T extends Effect.Effect<any, any, any>, Args extends Array<any>, A, E, R>(\n  getService: T,\n  f: (_: Effect.Effect.Success<T>) => (...args: Args) => Effect.Effect<A, E, R>\n) =>\n(...args: Args): Effect.Effect<A, E | Effect.Effect.Error<T>, R | Effect.Effect.Context<T>> =>\n  core.flatMap(getService, (a) => f(a)(...args))\n\n/** @internal */\nexport const serviceFunction = <T extends Effect.Effect<any, any, any>, Args extends Array<any>, A>(\n  getService: T,\n  f: (_: Effect.Effect.Success<T>) => (...args: Args) => A\n) =>\n(...args: Args): Effect.Effect<A, Effect.Effect.Error<T>, Effect.Effect.Context<T>> =>\n  core.map(getService, (a) => f(a)(...args))\n\n/** @internal */\nexport const serviceFunctions = <S, SE, SR>(\n  getService: Effect.Effect<S, SE, SR>\n): {\n  [k in keyof S as S[k] extends (...args: Array<any>) => Effect.Effect<any, any, any> ? k : never]: S[k] extends\n    (...args: infer Args) => Effect.Effect<infer A, infer E, infer R>\n    ? (...args: Args) => Effect.Effect<A, E | SE, R | SR>\n    : never\n} =>\n  new Proxy({} as any, {\n    get(_target: any, prop: any, _receiver) {\n      return (...args: Array<any>) => core.flatMap(getService, (s: any) => s[prop](...args))\n    }\n  })\n\n/** @internal */\nexport const serviceConstants = <S, SE, SR>(\n  getService: Effect.Effect<S, SE, SR>\n): {\n  [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect.Effect<infer A, infer E, infer R> ?\n    Effect.Effect<A, E | SE, R | SR> :\n    Effect.Effect<S[k], SE, SR>\n} =>\n  new Proxy({} as any, {\n    get(_target: any, prop: any, _receiver) {\n      return core.flatMap(getService, (s: any) => core.isEffect(s[prop]) ? s[prop] : core.succeed(s[prop]))\n    }\n  })\n\n/** @internal */\nexport const serviceMembers = <S, SE, SR>(getService: Effect.Effect<S, SE, SR>): {\n  functions: {\n    [k in keyof S as S[k] extends (...args: Array<any>) => Effect.Effect<any, any, any> ? k : never]: S[k] extends\n      (...args: infer Args) => Effect.Effect<infer A, infer E, infer R>\n      ? (...args: Args) => Effect.Effect<A, E | SE, R | SR>\n      : never\n  }\n  constants: {\n    [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect.Effect<infer A, infer E, infer R> ?\n      Effect.Effect<A, E | SE, R | SR> :\n      Effect.Effect<S[k], SE, SR>\n  }\n} => ({\n  functions: serviceFunctions(getService) as any,\n  constants: serviceConstants(getService)\n})\n\n/** @internal */\nexport const serviceOption = <I, S>(tag: Context.Tag<I, S>) => core.map(core.context<never>(), Context.getOption(tag))\n\n/** @internal */\nexport const serviceOptional = <I, S>(tag: Context.Tag<I, S>) =>\n  core.flatMap(core.context<never>(), Context.getOption(tag))\n\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const annotateCurrentSpan: {\n  (key: string, value: unknown): Effect.Effect<void>\n  (values: Record<string, unknown>): Effect.Effect<void>\n} = function(): Effect.Effect<void> {\n  const args = arguments\n  return ignore(core.flatMap(\n    currentSpan,\n    (span) =>\n      core.sync(() => {\n        if (typeof args[0] === \"string\") {\n          span.attribute(args[0], args[1])\n        } else {\n          for (const key in args[0]) {\n            span.attribute(key, args[0][key])\n          }\n        }\n      })\n  ))\n}\n\n/* @internal */\nexport const annotateSpans = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: unknown): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, unknown>): Effect.Effect<A, E, R>\n  }\n>(\n  (args) => core.isEffect(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return core.fiberRefLocallyWith(\n      args[0] as Effect.Effect<A, E, R>,\n      core.currentTracerSpanAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n/** @internal */\nexport const currentParentSpan: Effect.Effect<Tracer.AnySpan, Cause.NoSuchElementException> = serviceOptional(\n  internalTracer.spanTag\n)\n\n/** @internal */\nexport const currentSpan: Effect.Effect<Tracer.Span, Cause.NoSuchElementException> = core.flatMap(\n  core.context<never>(),\n  (context) => {\n    const span = context.unsafeMap.get(internalTracer.spanTag.key) as Tracer.AnySpan | undefined\n    return span !== undefined && span._tag === \"Span\"\n      ? core.succeed(span)\n      : core.fail(new core.NoSuchElementException())\n  }\n)\n\n/* @internal */\nexport const linkSpans = dual<\n  (\n    span: Tracer.AnySpan,\n    attributes?: Record<string, unknown>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    span: Tracer.AnySpan,\n    attributes?: Record<string, unknown>\n  ) => Effect.Effect<A, E, R>\n>(\n  (args) => core.isEffect(args[0]),\n  (self, span, attributes) =>\n    core.fiberRefLocallyWith(\n      self,\n      core.currentTracerSpanLinks,\n      Chunk.append(\n        {\n          _tag: \"SpanLink\",\n          span,\n          attributes: attributes ?? {}\n        } as const\n      )\n    )\n)\n\nconst bigint0 = BigInt(0)\n\n/** @internal */\nexport const unsafeMakeSpan = <XA, XE>(\n  fiber: FiberRuntime<XA, XE>,\n  name: string,\n  options: Tracer.SpanOptions\n) => {\n  const enabled = fiber.getFiberRef(core.currentTracerEnabled)\n  if (enabled === false) {\n    return core.noopSpan(name)\n  }\n\n  const context = fiber.getFiberRef(core.currentContext)\n  const services = fiber.getFiberRef(defaultServices.currentServices)\n\n  const tracer = Context.get(services, internalTracer.tracerTag)\n  const clock = Context.get(services, Clock.Clock)\n  const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled)\n\n  const fiberRefs = fiber.getFiberRefs()\n  const annotationsFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanAnnotations)\n  const linksFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanLinks)\n\n  const parent = options.parent\n    ? Option.some(options.parent)\n    : options.root\n    ? Option.none()\n    : Context.getOption(context, internalTracer.spanTag)\n\n  const links = linksFromEnv._tag === \"Some\" ?\n    options.links !== undefined ?\n      [\n        ...Chunk.toReadonlyArray(linksFromEnv.value),\n        ...(options.links ?? [])\n      ] :\n      Chunk.toReadonlyArray(linksFromEnv.value) :\n    options.links ?? Arr.empty()\n\n  const span = tracer.span(\n    name,\n    parent,\n    options.context ?? Context.empty(),\n    links,\n    timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0,\n    options.kind ?? \"internal\"\n  )\n\n  if (typeof options.captureStackTrace === \"function\") {\n    internalCause.spanToTrace.set(span, options.captureStackTrace)\n  }\n\n  if (annotationsFromEnv._tag === \"Some\") {\n    HashMap.forEach(annotationsFromEnv.value, (value, key) => span.attribute(key, value))\n  }\n  if (options.attributes !== undefined) {\n    Object.entries(options.attributes).forEach(([k, v]) => span.attribute(k, v))\n  }\n\n  return span\n}\n\n/** @internal */\nexport const makeSpan = (\n  name: string,\n  options?: Tracer.SpanOptions\n): Effect.Effect<Tracer.Span> => {\n  options = internalTracer.addSpanStackTrace(options)\n  return core.withFiberRuntime((fiber) => core.succeed(unsafeMakeSpan(fiber, name, options)))\n}\n\n/* @internal */\nexport const spanAnnotations: Effect.Effect<HashMap.HashMap<string, unknown>> = core\n  .fiberRefGet(core.currentTracerSpanAnnotations)\n\n/* @internal */\nexport const spanLinks: Effect.Effect<Chunk.Chunk<Tracer.SpanLink>> = core\n  .fiberRefGet(core.currentTracerSpanLinks)\n\n/** @internal */\nexport const endSpan = <A, E>(span: Tracer.Span, exit: Exit<A, E>, clock: Clock.Clock, timingEnabled: boolean) =>\n  core.sync(() => {\n    if (span.status._tag === \"Ended\") {\n      return\n    }\n    if (core.exitIsFailure(exit) && internalCause.spanToTrace.has(span)) {\n      span.attribute(\"code.stacktrace\", internalCause.spanToTrace.get(span)!())\n    }\n    span.end(timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, exit)\n  })\n\n/** @internal */\nexport const useSpan: {\n  <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <A, E, R>(\n    name: string,\n    options: Tracer.SpanOptions,\n    evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = <A, E, R>(\n  name: string,\n  ...args: [evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>] | [\n    options: any,\n    evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>\n  ]\n) => {\n  const options = internalTracer.addSpanStackTrace(args.length === 1 ? undefined : args[0])\n  const evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R> = args[args.length - 1]\n\n  return core.withFiberRuntime<A, E, R>((fiber) => {\n    const span = unsafeMakeSpan(fiber, name, options)\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled)\n    const clock = Context.get(fiber.getFiberRef(defaultServices.currentServices), clockTag)\n    return core.onExit(evaluate(span), (exit) => endSpan(span, exit, clock, timingEnabled))\n  })\n}\n\n/** @internal */\nexport const withParentSpan = dual<\n  (\n    span: Tracer.AnySpan\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, span: Tracer.AnySpan) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n>(2, (self, span) => provideService(self, internalTracer.spanTag, span))\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions | undefined\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    name: string,\n    options?: Tracer.SpanOptions | undefined\n  ): Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = internalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  if (dataFirst) {\n    const self = arguments[0]\n    return useSpan(name, options, (span) => withParentSpan(self, span))\n  }\n  return (self: Effect.Effect<any, any, any>) => useSpan(name, options, (span) => withParentSpan(self, span))\n} as any\n\nexport const functionWithSpan = <Args extends Array<any>, Ret extends Effect.Effect<any, any, any>>(\n  options: {\n    readonly body: (...args: Args) => Ret\n    readonly options: Effect.FunctionWithSpanOptions | ((...args: Args) => Effect.FunctionWithSpanOptions)\n    readonly captureStackTrace?: boolean | undefined\n  }\n): (...args: Args) => Unify<Ret> =>\n  (function(this: any) {\n    let captureStackTrace: LazyArg<string | undefined> | boolean = options.captureStackTrace ?? false\n    if (options.captureStackTrace !== false) {\n      const limit = Error.stackTraceLimit\n      Error.stackTraceLimit = 2\n      const error = new Error()\n      Error.stackTraceLimit = limit\n      let cache: false | string = false\n      captureStackTrace = () => {\n        if (cache !== false) {\n          return cache\n        }\n        if (error.stack) {\n          const stack = error.stack.trim().split(\"\\n\")\n          cache = stack.slice(2).join(\"\\n\").trim()\n          return cache\n        }\n      }\n    }\n    return core.suspend(() => {\n      const opts = typeof options.options === \"function\"\n        ? options.options.apply(null, arguments as any)\n        : options.options\n      return withSpan(\n        core.suspend(() => internalCall(() => options.body.apply(this, arguments as any))),\n        opts.name,\n        {\n          ...opts,\n          captureStackTrace\n        }\n      )\n    })\n  }) as any\n\n// -------------------------------------------------------------------------------------\n// optionality\n// -------------------------------------------------------------------------------------\n\n/* @internal */\nexport const fromNullable = <A>(value: A): Effect.Effect<NonNullable<A>, Cause.NoSuchElementException> =>\n  value == null ? core.fail(new core.NoSuchElementException()) : core.succeed(value as NonNullable<A>)\n\n/* @internal */\nexport const optionFromOptional = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R> =>\n  core.catchAll(\n    core.map(self, Option.some),\n    (error) =>\n      core.isNoSuchElementException(error) ?\n        succeedNone :\n        core.fail(error as Exclude<E, Cause.NoSuchElementException>)\n  )\n"],"names":["internalCall","Arr","Chunk","Clock","Context","Duration","FiberRefs","constFalse","constTrue","constVoid","dual","identity","pipe","HashMap","HashSet","List","LogLevel","LogSpan","Option","Predicate","Ref","Tracer","yieldWrapGet","internalCause","clockTag","core","defaultServices","doNotation","fiberRefsPatch","metricLabel","runtimeFlags","internalTracer","annotateLogs","args","isEffect","arguments","fiberRefLocallyWith","currentLogAnnotations","set","annotations","Object","entries","reduce","acc","key","value","asSome","self","map","some","asSomeError","mapError","try_","arg","evaluate","onFailure","undefined","try","catch","sync","error","makeEffectError","fail","UnknownException","_catch","tag","options","catchAll","e","hasProperty","failure","catchAllDefect","f","catchAllCause","cause","option","find","_","isDieType","none","_tag","failCause","defect","catchSomeCause","matchCauseEffect","onSuccess","succeed","catchSomeDefect","pf","optionEffect","catchTag","k","catchIf","isTagged","catchTags","cases","keys","isString","includes","matchCause","empty","clockWith","clock","delay","duration","zipRight","sleep","descriptorWith","withFiberRuntime","state","status","id","interruptors","getFiberRef","currentInterruptedCause","allowInterrupt","descriptor","size","interrupt","void","diffFiberRefs","summarized","fiberRefs","diff","diffFiberRefsAndRuntimeFlags","zip","refs","flags","refsNew","flagsNew","Do","bind","flatMap","bindTo","let_","dropUntil","elements","predicate","suspend","iterator","Symbol","builder","next","dropping","i","done","a","index","bool","push","dropWhile","d","b","contextWith","context","eventually","orElse","yieldNow","filterMap","forEachSequential","filterOrDie","orDieWith","filterOrElse","dieSync","filterOrDieMessage","message","dieMessage","liftPredicate","orFailWith","filterOrFail","NoSuchElementException","failSync","findFirst","findLoop","result","firstSuccessOf","effects","list","fromIterable","isNonEmpty","IllegalArgumentException","tailNonEmpty","headNonEmpty","left","right","flipWith","flip","match","matchEffect","every","forAllLoop","forever","loop","gen","length","run","val","getFiberRefs","head","as","ignore","ignoreLogged","logDebug","inheritFiberRefs","childFiberRefs","updateFiberRefs","parentFiberId","parentFiberRefs","joinAs","isFailure","isSuccess","iterate","initial","while","body","z2","logWithLevel","level","levelOption","fromNullable","len","msg","isCause","sequential","slice","fiberState","log","logTrace","Trace","Debug","logInfo","Info","logWarning","Warning","logError","Error","logFatal","Fatal","withLogSpan","effect","label","currentTimeMillis","now","currentLogSpan","prepend","make","logAnnotations","fiberRefGet","discard","loopDiscard","step","loopInternal","cont","inc","mapAccum","zero","z","mapErrorCause","c","failCauseSync","memoize","deferredMake","deferred","intoDeferred","once","complete","deferredAwait","patch","patchFiberRefs","updateRuntimeFlags","merge","negate","ref","asVoid","whenEffect","getAndSet","orElseFail","orElseSucceed","parallelErrors","errors","failures","fiberId","promise","async","resolve","signal","then","exitSucceed","exitDie","provideService","service","contextWithEffect","env","provideContext","add","provideServiceEffect","random","randomWith","el","reduceRight","reduceWhile","reduceWhileLoop","nextState","repeatN","n","repeatNLoop","sandbox","setFiberRefs","setAll","succeedNone","succeedSome","summary","start","end","tagMetrics","labelMetrics","v","labels","currentMetricLabels","old","union","takeUntil","takeWhile","taking","tapBoth","either","failureOrCause","tapDefect","keepDefects","onNone","onSome","tapError","tapErrorTag","tapErrorCause","timed","timedWith","currentTimeNanos","nanos","tracerWith","tracer","tryPromise","catcher","tryMap","tryMapPromise","unless","condition","unlessEffect","unsandbox","flatten","updateService","mapInputContext","unsafeGet","when","whenFiberRef","fiberRef","s","whenRef","get","withMetric","metric","serviceFunctionEffect","getService","serviceFunction","serviceFunctions","Proxy","_target","prop","_receiver","serviceConstants","serviceMembers","functions","constants","serviceOption","getOption","serviceOptional","annotateCurrentSpan","currentSpan","span","attribute","annotateSpans","currentTracerSpanAnnotations","currentParentSpan","spanTag","unsafeMap","linkSpans","attributes","currentTracerSpanLinks","append","bigint0","BigInt","unsafeMakeSpan","fiber","name","enabled","currentTracerEnabled","noopSpan","currentContext","services","currentServices","tracerTag","timingEnabled","currentTracerTimingEnabled","annotationsFromEnv","linksFromEnv","parent","root","links","toReadonlyArray","unsafeCurrentTimeNanos","kind","captureStackTrace","spanToTrace","forEach","makeSpan","addSpanStackTrace","spanAnnotations","spanLinks","endSpan","exit","exitIsFailure","has","useSpan","onExit","withParentSpan","withSpan","dataFirst","functionWithSpan","limit","stackTraceLimit","cache","stack","trim","split","join","opts","apply","optionFromOptional","isNoSuchElementException"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 848, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}