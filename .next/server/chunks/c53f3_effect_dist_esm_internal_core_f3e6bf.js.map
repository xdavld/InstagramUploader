{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"core.js","sources":["file:///Users/david/src/5.%20Semester/SoftwareEngineering-Project/node_modules/.pnpm/effect%403.10.3/node_modules/effect/src/internal/core.ts"],"sourcesContent":["import { internalCall } from \"effect/Utils\"\nimport * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Deferred from \"../Deferred.js\"\nimport type * as Differ from \"../Differ.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as ExecutionStrategy from \"../ExecutionStrategy.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport type * as FiberStatus from \"../FiberStatus.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport type * as HashSet from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as List from \"../List.js\"\nimport type * as LogLevel from \"../LogLevel.js\"\nimport type * as LogSpan from \"../LogSpan.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, isObject, isPromiseLike, type Predicate, type Refinement } from \"../Predicate.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as BlockedRequests from \"../RequestBlock.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type { NoInfer, NotFunction } from \"../Types.js\"\nimport { YieldWrap } from \"../Utils.js\"\nimport * as _blockedRequests from \"./blockedRequests.js\"\nimport * as internalCause from \"./cause.js\"\nimport * as deferred from \"./deferred.js\"\nimport * as internalDiffer from \"./differ.js\"\nimport { CommitPrototype, effectVariance, StructuralCommitPrototype } from \"./effectable.js\"\nimport { getBugErrorMessage } from \"./errors.js\"\nimport type * as FiberRuntime from \"./fiberRuntime.js\"\nimport type * as fiberScope from \"./fiberScope.js\"\nimport * as DeferredOpCodes from \"./opCodes/deferred.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as _runtimeFlags from \"./runtimeFlags.js\"\nimport { SingleShotGen } from \"./singleShotGen.js\"\n\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst EffectErrorSymbolKey = \"effect/EffectError\"\n\n/** @internal */\nexport const EffectErrorTypeId = Symbol.for(EffectErrorSymbolKey)\n\n/** @internal */\nexport type EffectErrorTypeId = typeof EffectErrorTypeId\n\n/** @internal */\nexport interface EffectError<out E> {\n  readonly [EffectErrorTypeId]: EffectErrorTypeId\n  readonly _tag: \"EffectError\"\n  readonly cause: Cause.Cause<E>\n}\n\n/** @internal */\nexport const isEffectError = (u: unknown): u is EffectError<unknown> => hasProperty(u, EffectErrorTypeId)\n\n/** @internal */\nexport const makeEffectError = <E>(cause: Cause.Cause<E>): EffectError<E> => ({\n  [EffectErrorTypeId]: EffectErrorTypeId,\n  _tag: \"EffectError\",\n  cause\n})\n\n/**\n * @internal\n */\nexport const blocked = <A, E>(\n  blockedRequests: BlockedRequests.RequestBlock,\n  _continue: Effect.Effect<A, E>\n): Effect.Blocked<A, E> => {\n  const effect = new EffectPrimitive(\"Blocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  effect.effect_instruction_i1 = _continue\n  return effect\n}\n\n/**\n * @internal\n */\nexport const runRequestBlock = (\n  blockedRequests: BlockedRequests.RequestBlock\n): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(\"RunBlocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  return effect\n}\n\n/** @internal */\nexport const EffectTypeId: Effect.EffectTypeId = Symbol.for(\"effect/Effect\") as Effect.EffectTypeId\n\n/** @internal */\nexport type Primitive =\n  | Async\n  | Commit\n  | Failure\n  | OnFailure\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | Success\n  | Sync\n  | UpdateRuntimeFlags\n  | While\n  | WithRuntime\n  | Yield\n  | OpTag\n  | Blocked\n  | RunBlocked\n  | Either.Either<any, any>\n  | Option.Option<any>\n\n/** @internal */\nexport type Continuation =\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | OnFailure\n  | While\n  | RevertFlags\n\n/** @internal */\nexport class RevertFlags {\n  readonly _op = OpCodes.OP_REVERT_FLAGS\n  constructor(\n    readonly patch: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    readonly op: Primitive & { _op: OpCodes.OP_UPDATE_RUNTIME_FLAGS }\n  ) {\n  }\n}\n\nclass EffectPrimitive {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {}\n  [Equal.symbol](this: {}, that: unknown) {\n    return this === that\n  }\n  [Hash.symbol](this: {}) {\n    return Hash.cached(this, Hash.random(this))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      effect_instruction_i0: toJSON(this.effect_instruction_i0),\n      effect_instruction_i1: toJSON(this.effect_instruction_i1),\n      effect_instruction_i2: toJSON(this.effect_instruction_i2)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveFailure {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Failure\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get cause() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: (this.cause as any).toJSON()\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveSuccess {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Success\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get value() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nexport type Op<Tag extends string, Body = {}> = Effect.Effect<never> & Body & {\n  readonly _op: Tag\n}\n\n/** @internal */\nexport interface Async extends\n  Op<OpCodes.OP_ASYNC, {\n    effect_instruction_i0(resume: (effect: Primitive) => void): void\n    readonly effect_instruction_i1: FiberId.FiberId\n  }>\n{}\n\n/** @internal */\nexport interface Blocked<out E = any, out A = any> extends\n  Op<\"Blocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n    readonly effect_instruction_i1: Effect.Effect<A, E>\n  }>\n{}\n\n/** @internal */\nexport interface RunBlocked extends\n  Op<\"RunBlocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n  }>\n{}\n\n/** @internal */\nexport interface Failure extends\n  Op<OpCodes.OP_FAILURE, {\n    readonly effect_instruction_i0: Cause.Cause<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OpTag extends Op<OpCodes.OP_TAG, {}> {}\n\n/** @internal */\nexport interface Commit extends\n  Op<OpCodes.OP_COMMIT, {\n    commit(): Effect.Effect<unknown, unknown, unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OnFailure extends\n  Op<OpCodes.OP_ON_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnSuccess extends\n  Op<OpCodes.OP_ON_SUCCESS, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnStep extends Op<\"OnStep\", { readonly effect_instruction_i0: Primitive }> {}\n\n/** @internal */\nexport interface OnSuccessAndFailure extends\n  Op<OpCodes.OP_ON_SUCCESS_AND_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n    effect_instruction_i2(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Success extends\n  Op<OpCodes.OP_SUCCESS, {\n    readonly effect_instruction_i0: unknown\n  }>\n{}\n\n/** @internal */\nexport interface Sync extends\n  Op<OpCodes.OP_SYNC, {\n    effect_instruction_i0(): unknown\n  }>\n{}\n\n/** @internal */\nexport interface UpdateRuntimeFlags extends\n  Op<OpCodes.OP_UPDATE_RUNTIME_FLAGS, {\n    readonly effect_instruction_i0: RuntimeFlagsPatch.RuntimeFlagsPatch\n    readonly effect_instruction_i1?: (oldRuntimeFlags: RuntimeFlags.RuntimeFlags) => Primitive\n  }>\n{}\n\n/** @internal */\nexport interface While extends\n  Op<OpCodes.OP_WHILE, {\n    effect_instruction_i0(): boolean\n    effect_instruction_i1(): Primitive\n    effect_instruction_i2(a: unknown): void\n  }>\n{}\n\n/** @internal */\nexport interface WithRuntime extends\n  Op<OpCodes.OP_WITH_RUNTIME, {\n    effect_instruction_i0(fiber: FiberRuntime.FiberRuntime<unknown, unknown>, status: FiberStatus.Running): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Yield extends Op<OpCodes.OP_YIELD> {}\n\n/** @internal */\nexport const isEffect = (u: unknown): u is Effect.Effect<unknown, unknown, unknown> => hasProperty(u, EffectTypeId)\n\n/* @internal */\nexport const withFiberRuntime = <A, E = never, R = never>(\n  withRuntime: (fiber: FiberRuntime.FiberRuntime<A, E>, status: FiberStatus.Running) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME) as any\n  effect.effect_instruction_i0 = withRuntime\n  return effect\n}\n\n/* @internal */\nexport const acquireUseRelease: {\n  <A2, E2, R2, A, X, R3>(\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): <E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2 | E, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, X, R3>(\n    acquire: Effect.Effect<A, E, R>,\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): Effect.Effect<A2, E | E2, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, X, R3>(\n  acquire: Effect.Effect<A, E, R>,\n  use: (a: A) => Effect.Effect<A2, E2, R2>,\n  release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n): Effect.Effect<A2, E | E2, R | R2 | R3> =>\n  uninterruptibleMask((restore) =>\n    flatMap(\n      acquire,\n      (a) =>\n        flatMap(exit(suspend(() => restore(use(a)))), (exit): Effect.Effect<A2, E | E2, R | R2 | R3> => {\n          return suspend(() => release(a, exit)).pipe(\n            matchCauseEffect({\n              onFailure: (cause) => {\n                switch (exit._tag) {\n                  case OpCodes.OP_FAILURE:\n                    return failCause(internalCause.parallel(exit.effect_instruction_i0, cause))\n                  case OpCodes.OP_SUCCESS:\n                    return failCause(cause)\n                }\n              },\n              onSuccess: () => exit\n            })\n          )\n        })\n    )\n  ))\n\n/* @internal */\nexport const as: {\n  <B>(value: B): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R> => flatMap(self, () => succeed(value))\n)\n\n/* @internal */\nexport const asVoid = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, E, R> => as(self, void 0)\n\n/* @internal */\nexport const custom: {\n  <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X }) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <X, Y, A, E, R>(\n    i0: X,\n    i1: Y,\n    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y }) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n  <X, Y, Z, A, E, R>(\n    i0: X,\n    i1: Y,\n    i2: Z,\n    body: (\n      this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z }\n    ) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = function() {\n  const wrapper = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  switch (arguments.length) {\n    case 2: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.commit = arguments[1]\n      break\n    }\n    case 3: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.commit = arguments[2]\n      break\n    }\n    case 4: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.effect_instruction_i2 = arguments[2]\n      wrapper.commit = arguments[3]\n      break\n    }\n    default: {\n      throw new Error(getBugErrorMessage(\"you're not supposed to end up here\"))\n    }\n  }\n  return wrapper\n}\n\n/* @internal */\nexport const unsafeAsync = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n  let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n  effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n    cancelerRef = register(resume)\n  }\n  effect.effect_instruction_i1 = blockingOn\n  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_)\n}\n\n/* @internal */\nexport const async = <A, E = never, R = never>(\n  resume: (\n    callback: (_: Effect.Effect<A, E, R>) => void,\n    signal: AbortSignal\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  return custom(resume, function() {\n    let backingResume: ((_: Effect.Effect<A, E, R>) => void) | undefined = undefined\n    let pendingEffect: Effect.Effect<A, E, R> | undefined = undefined\n    function proxyResume(effect: Effect.Effect<A, E, R>) {\n      if (backingResume) {\n        backingResume(effect)\n      } else if (pendingEffect === undefined) {\n        pendingEffect = effect\n      }\n    }\n    const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n    effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n      backingResume = resume\n      if (pendingEffect) {\n        resume(pendingEffect)\n      }\n    }\n    effect.effect_instruction_i1 = blockingOn\n    let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n    let controllerRef: AbortController | void = undefined\n    if (this.effect_instruction_i0.length !== 1) {\n      controllerRef = new AbortController()\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef!.signal))\n    } else {\n      cancelerRef = internalCall(() => (this.effect_instruction_i0 as any)(proxyResume))\n    }\n    return (cancelerRef || controllerRef) ?\n      onInterrupt(effect, (_) => {\n        if (controllerRef) {\n          controllerRef.abort()\n        }\n        return cancelerRef ?? void_\n      }) :\n      effect\n  })\n}\n\n/* @internal */\nexport const catchAllCause = dual<\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2 | A, E2, R2 | R>\n>(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = f\n  return effect\n})\n\n/* @internal */\nexport const catchAll: {\n  <E, A2, E2, R2>(\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => matchEffect(self, { onFailure: f, onSuccess: succeed })\n)\n\n/* @internal */\nexport const catchIf: {\n  <E, EB extends E, A2, E2, R2>(\n    refinement: Refinement<NoInfer<E>, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <E, A2, E2, R2>(\n    predicate: Predicate<NoInfer<E>>,\n    f: (e: NoInfer<E>) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, EB extends E, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Refinement<E, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A | A2, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate<E>,\n  f: (e: E) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  catchAllCause(self, (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return predicate(either.left) ? f(either.left) : failCause(cause)\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const catchSome = dual<\n  <E, A2, E2, R2>(\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A2 | A, E | E2, R2 | R>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n) =>\n  catchAllCause(self, (cause): Effect.Effect<A2 | A, E | E2, R2 | R> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return pipe(pf(either.left), Option.getOrElse(() => failCause(cause)))\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const checkInterruptible = <A, E, R>(\n  f: (isInterruptible: boolean) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((_, status) => f(_runtimeFlags.interruption(status.runtimeFlags)))\n\nconst spanSymbol = Symbol.for(\"effect/SpanAnnotation\")\nconst originalSymbol = Symbol.for(\"effect/OriginalAnnotation\")\n\n/* @internal */\nexport const originalInstance = <E>(obj: E): E => {\n  if (hasProperty(obj, originalSymbol)) {\n    // @ts-expect-error\n    return obj[originalSymbol]\n  }\n  return obj\n}\n\n/* @internal */\nexport const capture = <E>(obj: E & object, span: Option.Option<Tracer.Span>): E => {\n  if (Option.isSome(span)) {\n    return new Proxy(obj, {\n      has(target, p) {\n        return p === spanSymbol || p === originalSymbol || p in target\n      },\n      get(target, p) {\n        if (p === spanSymbol) {\n          return span.value\n        }\n        if (p === originalSymbol) {\n          return obj\n        }\n        // @ts-expect-error\n        return target[p]\n      }\n    })\n  }\n  return obj\n}\n\n/* @internal */\nexport const die = (defect: unknown): Effect.Effect<never> =>\n  isObject(defect) && !(spanSymbol in defect) ?\n    withFiberRuntime((fiber) => failCause(internalCause.die(capture(defect, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.die(defect))\n\n/* @internal */\nexport const dieMessage = (message: string): Effect.Effect<never> =>\n  failCauseSync(() => internalCause.die(new RuntimeException(message)))\n\n/* @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Effect.Effect<never> => flatMap(sync(evaluate), die)\n\n/* @internal */\nexport const either = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Either.Either<A, E>, never, R> =>\n  matchEffect(self, {\n    onFailure: (e) => succeed(Either.left(e)),\n    onSuccess: (a) => succeed(Either.right(a))\n  })\n\n/* @internal */\nexport const exit = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Exit.Exit<A, E>, never, R> =>\n  matchCause(self, {\n    onFailure: exitFailCause,\n    onSuccess: exitSucceed\n  })\n\n/* @internal */\nexport const fail = <E>(error: E): Effect.Effect<never, E> =>\n  isObject(error) && !(spanSymbol in error) ?\n    withFiberRuntime((fiber) => failCause(internalCause.fail(capture(error, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.fail(error))\n\n/* @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Effect.Effect<never, E> => flatMap(sync(evaluate), fail)\n\n/* @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Effect.Effect<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/* @internal */\nexport const failCauseSync = <E>(\n  evaluate: LazyArg<Cause.Cause<E>>\n): Effect.Effect<never, E> => flatMap(sync(evaluate), failCause)\n\n/* @internal */\nexport const fiberId: Effect.Effect<FiberId.FiberId> = withFiberRuntime((state) => succeed(state.id()))\n\n/* @internal */\nexport const fiberIdWith = <A, E, R>(\n  f: (descriptor: FiberId.Runtime) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((state) => f(state.id()))\n\n/* @internal */\nexport const flatMap = dual<\n  <A, B, E1, R1>(\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>,\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => Effect.Effect<B, E | E1, R | R1>\n>(\n  2,\n  (self, f) => {\n    const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS) as any\n    effect.effect_instruction_i0 = self\n    effect.effect_instruction_i1 = f\n    return effect\n  }\n)\n\n/* @internal */\nexport const andThen: {\n  <A, X>(\n    f: (a: NoInfer<A>) => X\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <X>(\n    f: NotFunction<X>\n  ): <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: NoInfer<A>) => X\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: NotFunction<X>\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n} = dual(2, (self, f) =>\n  flatMap(self, (a) => {\n    const b = typeof f === \"function\" ? (f as any)(a) : f\n    if (isEffect(b)) {\n      return b\n    } else if (isPromiseLike(b)) {\n      return async<any, Cause.UnknownException>((resume) => {\n        b.then((a) => resume(succeed(a)), (e) => resume(fail(new UnknownException(e))))\n      })\n    }\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const step = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Exit.Exit<A, E> | Effect.Blocked<A, E>, never, R> => {\n  const effect = new EffectPrimitive(\"OnStep\") as any\n  effect.effect_instruction_i0 = self\n  return effect\n}\n\n/* @internal */\nexport const flatten = <A, E1, R1, E, R>(\n  self: Effect.Effect<Effect.Effect<A, E1, R1>, E, R>\n): Effect.Effect<A, E | E1, R | R1> => flatMap(self, identity)\n\n/* @internal */\nexport const flip = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E, A, R> =>\n  matchEffect(self, { onFailure: succeed, onSuccess: fail })\n\n/* @internal */\nexport const matchCause: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => A2\n    readonly onSuccess: (a: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => succeed(options.onFailure(cause)),\n    onSuccess: (a) => succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const matchCauseEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = options.onFailure\n  effect.effect_instruction_i2 = options.onSuccess\n  return effect\n})\n\n/* @internal */\nexport const matchEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(internalCause.electFailures(cause))\n      }\n      const failures = internalCause.failures(cause)\n      if (failures.length > 0) {\n        return options.onFailure(Chunk.unsafeHead(failures))\n      }\n      return failCause(cause as Cause.Cause<never>)\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/* @internal */\nexport const forEachSequential: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<Array<B>, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      const ret = Arr.allocate<B>(arr.length)\n      let i = 0\n      return as(\n        whileLoop({\n          while: () => i < arr.length,\n          body: () => f(arr[i], i),\n          step: (b) => {\n            ret[i++] = b\n          }\n        }),\n        ret as Array<B>\n      )\n    })\n)\n\n/* @internal */\nexport const forEachSequentialDiscard: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<void, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      let i = 0\n      return whileLoop({\n        while: () => i < arr.length,\n        body: () => f(arr[i], i),\n        step: () => {\n          i++\n        }\n      })\n    })\n)\n\n/* @internal */\nexport const if_ = dual<\n  <A1, E1, R1, A2, E2, R2>(\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => <E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean\n  ) => Effect.Effect<A1 | A2, E | E1 | E2, R | R1 | R2>,\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>\n>(\n  (args) => typeof args[0] === \"boolean\" || isEffect(args[0]),\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ): Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R> =>\n    isEffect(self)\n      ? flatMap(self, (b): Effect.Effect<A1 | A2, E1 | E2, R1 | R2> => (b ? options.onTrue() : options.onFalse()))\n      : self\n      ? options.onTrue()\n      : options.onFalse()\n)\n\n/* @internal */\nexport const interrupt: Effect.Effect<never> = flatMap(fiberId, (fiberId) => interruptWith(fiberId))\n\n/* @internal */\nexport const interruptWith = (fiberId: FiberId.FiberId): Effect.Effect<never> =>\n  failCause(internalCause.interrupt(fiberId))\n\n/* @internal */\nexport const interruptible = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const interruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      _runtimeFlags.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\n/* @internal */\nexport const intoDeferred: {\n  <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<boolean, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R> =>\n    uninterruptibleMask((restore) =>\n      flatMap(\n        exit(restore(self)),\n        (exit) => deferredDone(deferred, exit)\n      )\n    )\n)\n\n/* @internal */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> =>\n    flatMap(self, (a) => sync(() => f(a)))\n)\n\n/* @internal */\nexport const mapBoth: {\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>\n  <A, E, R, E2, A2>(\n    self: Effect.Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect.Effect<A2, E2, R>\n} = dual(2, <A, E, R, E2, A2>(\n  self: Effect.Effect<A, E, R>,\n  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n): Effect.Effect<A2, E2, R> =>\n  matchEffect(self, {\n    onFailure: (e) => failSync(() => options.onFailure(e)),\n    onSuccess: (a) => sync(() => options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const mapError: {\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> =>\n    matchCauseEffect(self, {\n      onFailure: (cause) => {\n        const either = internalCause.failureOrCause(cause)\n        switch (either._tag) {\n          case \"Left\": {\n            return failSync(() => f(either.left))\n          }\n          case \"Right\": {\n            return failCause(either.right)\n          }\n        }\n      },\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const onError: {\n  <E, X, R2>(\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(self, (exit) => exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)))\n\n/* @internal */\nexport const onExit: {\n  <A, E, X, R2>(\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  uninterruptibleMask((restore) =>\n    matchCauseEffect(restore(self), {\n      onFailure: (cause1) => {\n        const result = exitFailCause(cause1)\n        return matchCauseEffect(cleanup(result), {\n          onFailure: (cause2) => exitFailCause(internalCause.sequential(cause1, cause2)),\n          onSuccess: () => result\n        })\n      },\n      onSuccess: (success) => {\n        const result = exitSucceed(success)\n        return zipRight(cleanup(result), result)\n      }\n    })\n  ))\n\n/* @internal */\nexport const onInterrupt: {\n  <X, R2>(\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(\n    self,\n    exitMatch({\n      onFailure: (cause) =>\n        internalCause.isInterruptedOnly(cause)\n          ? asVoid(cleanup(internalCause.interruptors(cause)))\n          : void_,\n      onSuccess: () => void_\n    })\n  ))\n\n/* @internal */\nexport const orElse: {\n  <A2, E2, R2>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => attemptOrElse(self, that, succeed)\n)\n\n/* @internal */\nexport const orDie = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> => orDieWith(self, identity)\n\n/* @internal */\nexport const orDieWith: {\n  <E>(f: (error: E) => unknown): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R> =>\n    matchEffect(self, {\n      onFailure: (e) => die(f(e)),\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const partitionMap: <A, A1, A2>(\n  elements: Iterable<A>,\n  f: (a: A) => Either.Either<A2, A1>\n) => [left: Array<A1>, right: Array<A2>] = Arr.partitionMap\n/* @internal */\nexport const runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags> = withFiberRuntime((_, status) =>\n  succeed(status.runtimeFlags)\n)\n\n/* @internal */\nexport const succeed = <A>(value: A): Effect.Effect<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/* @internal */\nexport const suspend = <A, E, R>(effect: LazyArg<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R> =>\n  flatMap(sync(effect), identity)\n\n/* @internal */\nexport const sync = <A>(thunk: LazyArg<A>): Effect.Effect<A> => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC) as any\n  effect.effect_instruction_i0 = thunk\n  return effect\n}\n\n/* @internal */\nexport const tap = dual<\n  {\n    <A, X>(\n      f: (a: NoInfer<A>) => X\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, X, E1, R1>(\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n    <X>(\n      f: NotFunction<X>\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <X, E1, R1>(\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n  },\n  {\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => X\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: NotFunction<X>\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n  }\n>(\n  (args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && \"onlyEffect\" in args[1]),\n  <A, E, R, X>(self: Effect.Effect<A, E, R>, f: X) =>\n    flatMap(self, (a) => {\n      const b = typeof f === \"function\" ? (f as any)(a) : f\n      if (isEffect(b)) {\n        return as(b, a)\n      } else if (isPromiseLike(b)) {\n        return async<any, Cause.UnknownException>((resume) => {\n          b.then((_) => resume(succeed(a)), (e) => resume(fail(new UnknownException(e))))\n        })\n      }\n      return succeed(a)\n    })\n)\n\n/* @internal */\nexport const transplant = <A, E, R>(\n  f: (grafter: <A2, E2, R2>(effect: Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  withFiberRuntime<A, E, R>((state) => {\n    const scopeOverride = state.getFiberRef(currentForkScopeOverride)\n    const scope = pipe(scopeOverride, Option.getOrElse(() => state.scope()))\n    return f(fiberRefLocally(currentForkScopeOverride, Option.some(scope)))\n  })\n\n/* @internal */\nexport const attemptOrElse: {\n  <A2, E2, R2, A, A3, E3, R3>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  that: LazyArg<Effect.Effect<A2, E2, R2>>,\n  onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)))\n      }\n      return that()\n    },\n    onSuccess\n  }))\n\n/* @internal */\nexport const uninterruptible: <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const uninterruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      _runtimeFlags.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\nconst void_: Effect.Effect<void> = succeed(void 0)\nexport {\n  /* @internal */\n  void_ as void\n}\n\n/* @internal */\nexport const updateRuntimeFlags = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = patch\n  effect.effect_instruction_i1 = void 0\n  return effect\n}\n\n/* @internal */\nexport const whenEffect: {\n  <E, R>(\n    condition: Effect.Effect<boolean, E, R>\n  ): <A, E2, R2>(\n    effect: Effect.Effect<A, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n  <A, E2, R2, E, R>(\n    self: Effect.Effect<A, E2, R2>,\n    condition: Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E | E2, R | R2>\n} = dual(2, <A, E2, R2, E, R>(\n  self: Effect.Effect<A, E2, R2>,\n  condition: Effect.Effect<boolean, E, R>\n): Effect.Effect<Option.Option<A>, E | E2, R | R2> =>\n  flatMap(condition, (b) => {\n    if (b) {\n      return pipe(self, map(Option.some))\n    }\n    return succeed(Option.none())\n  }))\n\n/* @internal */\nexport const whileLoop = <A, E, R>(\n  options: {\n    readonly while: LazyArg<boolean>\n    readonly body: LazyArg<Effect.Effect<A, E, R>>\n    readonly step: (a: A) => void\n  }\n): Effect.Effect<void, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE) as any\n  effect.effect_instruction_i0 = options.while\n  effect.effect_instruction_i1 = options.body\n  effect.effect_instruction_i2 = options.step\n  return effect\n}\n\n/* @internal */\nexport const withConcurrency = dual<\n  (concurrency: number | \"unbounded\") => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, concurrency: number | \"unbounded\") => Effect.Effect<A, E, R>\n>(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency))\n\n/* @internal */\nexport const withRequestBatching = dual<\n  (requestBatching: boolean) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, requestBatching: boolean) => Effect.Effect<A, E, R>\n>(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching))\n\n/* @internal */\nexport const withRuntimeFlags = dual<\n  (update: RuntimeFlagsPatch.RuntimeFlagsPatch) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect.Effect<A, E, R>\n>(2, (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = update\n  effect.effect_instruction_i1 = () => self\n  return effect\n})\n\n/** @internal */\nexport const withTracerEnabled = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerEnabled,\n    enabled\n  ))\n\n/** @internal */\nexport const withTracerTiming = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerTimingEnabled,\n    enabled\n  ))\n\n/* @internal */\nexport const yieldNow = (options?: {\n  readonly priority?: number | undefined\n}): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD) as any\n  return typeof options?.priority !== \"undefined\" ?\n    withSchedulingPriority(effect, options.priority) :\n    effect\n}\n\n/* @internal */\nexport const zip = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [a, b])))\n\n/* @internal */\nexport const zipFlatten: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A extends ReadonlyArray<any>, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[...A, A2], E | E2, R | R2>\n  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<[...A, A2], E | E2, R | R2>\n} = dual(2, <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[...A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [...a, b])))\n\n/* @internal */\nexport const zipLeft: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A, E | E2, R | R2> => flatMap(self, (a) => as(that, a)))\n\n/* @internal */\nexport const zipRight: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A2, E | E2, R | R2> => flatMap(self, () => that))\n\n/* @internal */\nexport const zipWith: {\n  <A2, E2, R2, A, B>(\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E2, R | R2>\n  <A, E, R, A2, E2, R2, B>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): Effect.Effect<B, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2, B>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>,\n  f: (a: A, b: A2) => B\n): Effect.Effect<B, E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => f(a, b))))\n\n/* @internal */\nexport const never: Effect.Effect<never> = async<never>(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1)\n  return sync(() => clearInterval(interval))\n})\n\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const interruptFiber = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Exit.Exit<A, E>> =>\n  flatMap(fiberId, (fiberId) => pipe(self, interruptAsFiber(fiberId)))\n\n/* @internal */\nexport const interruptAsFiber = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Fiber.Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>,\n  <A, E>(self: Fiber.Fiber<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<Exit.Exit<A, E>>\n>(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await))\n\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const logLevelAll: LogLevel.LogLevel = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelFatal: LogLevel.LogLevel = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelError: LogLevel.LogLevel = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelWarning: LogLevel.LogLevel = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelInfo: LogLevel.LogLevel = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelDebug: LogLevel.LogLevel = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelTrace: LogLevel.LogLevel = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelNone: LogLevel.LogLevel = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const allLogLevels: ReadonlyArray<LogLevel.LogLevel> = [\n  logLevelAll,\n  logLevelTrace,\n  logLevelDebug,\n  logLevelInfo,\n  logLevelWarning,\n  logLevelError,\n  logLevelFatal,\n  logLevelNone\n]\n\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\"\n\n/** @internal */\nexport const FiberRefTypeId: FiberRef.FiberRefTypeId = Symbol.for(\n  FiberRefSymbolKey\n) as FiberRef.FiberRefTypeId\n\nconst fiberRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/* @internal */\nexport const fiberRefGet = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<A> =>\n  withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)))\n\n/* @internal */\nexport const fiberRefGetAndSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<A>\n>(2, (self, value) => fiberRefModify(self, (v) => [v, value] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdateSome = dual<\n  <A>(\n    pf: (a: A) => Option.Option<A>\n  ) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    pf: (a: A) => Option.Option<A>\n  ) => Effect.Effect<A>\n>(2, (self, pf) => fiberRefModify(self, (v) => [v, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefGetWith = dual<\n  <B, E, R, A>(f: (a: A) => Effect.Effect<B, E, R>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(self: FiberRef.FiberRef<A>, f: (a: A) => Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n>(2, (self, f) => flatMap(fiberRefGet(self), f))\n\n/* @internal */\nexport const fiberRefSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<void>\n>(2, (self, value) => fiberRefModify(self, () => [void 0, value] as const))\n\n/* @internal */\nexport const fiberRefDelete = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> =>\n  withFiberRuntime((state) => {\n    state.unsafeDeleteFiberRef(self)\n    return void_\n  })\n\n/* @internal */\nexport const fiberRefReset = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> => fiberRefSet(self, self.initial)\n\n/* @internal */\nexport const fiberRefModify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B>,\n  <A, B>(self: FiberRef.FiberRef<A>, f: (a: A) => readonly [B, A]) => Effect.Effect<B>\n>(2, <A, B>(\n  self: FiberRef.FiberRef<A>,\n  f: (a: A) => readonly [B, A]\n): Effect.Effect<B> =>\n  withFiberRuntime((state) => {\n    const [b, a] = f(state.getFiberRef(self) as A)\n    state.setFiberRef(self, a)\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const fiberRefModifySome = <A, B>(\n  self: FiberRef.FiberRef<A>,\n  def: B,\n  f: (a: A) => Option.Option<readonly [B, A]>\n): Effect.Effect<B> => fiberRefModify(self, (v) => Option.getOrElse(f(v), () => [def, v] as const))\n\n/* @internal */\nexport const fiberRefUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<void>\n>(2, (self, f) => fiberRefModify(self, (v) => [void 0, f(v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateSome = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<void>\n>(2, (self, pf) => fiberRefModify(self, (v) => [void 0, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateAndGet = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) =>\n  fiberRefModify(self, (v) => {\n    const result = f(v)\n    return [result, result] as const\n  }))\n\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<A>\n>(2, (self, pf) =>\n  fiberRefModify(self, (v) => {\n    const result = Option.getOrElse(pf(v), () => v)\n    return [result, result] as const\n  }))\n\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\"\n\n/** @internal */\nexport const RequestResolverTypeId: RequestResolver.RequestResolverTypeId = Symbol.for(\n  RequestResolverSymbolKey\n) as RequestResolver.RequestResolverTypeId\n\nconst requestResolverVariance = {\n  /* c8 ignore next */\n  _A: (_: unknown) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class RequestResolverImpl<in A, out R> implements RequestResolver.RequestResolver<A, R> {\n  readonly [RequestResolverTypeId] = requestResolverVariance\n  constructor(\n    readonly runAll: (\n      requests: Array<Array<Request.Entry<A>>>\n    ) => Effect.Effect<void, never, R>,\n    readonly target?: unknown\n  ) {\n  }\n  [Hash.symbol](): number {\n    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this))\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return this.target ?\n      isRequestResolver(that) && Equal.equals(this.target, (that as RequestResolverImpl<any, any>).target) :\n      this === that\n  }\n  identified(...ids: Array<unknown>): RequestResolver.RequestResolver<A, R> {\n    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isRequestResolver = (u: unknown): u is RequestResolver.RequestResolver<unknown, unknown> =>\n  hasProperty(u, RequestResolverTypeId)\n\n// end\n\n/** @internal */\nexport const resolverLocally = dual<\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => <R, B extends Request.Request<any, any>>(\n    use: RequestResolver.RequestResolver<B, R>\n  ) => RequestResolver.RequestResolver<B, R>,\n  <R, B extends Request.Request<any, any>, A>(\n    use: RequestResolver.RequestResolver<B, R>,\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => RequestResolver.RequestResolver<B, R>\n>(3, <R, B extends Request.Request<any, any>, A>(\n  use: RequestResolver.RequestResolver<B, R>,\n  self: FiberRef.FiberRef<A>,\n  value: A\n): RequestResolver.RequestResolver<B, R> =>\n  new RequestResolverImpl<B, R>(\n    (requests) =>\n      fiberRefLocally(\n        use.runAll(requests),\n        self,\n        value\n      ),\n    Chunk.make(\"Locally\", use, self, value)\n  ))\n\n/** @internal */\nexport const requestBlockLocally = <A>(\n  self: BlockedRequests.RequestBlock,\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock => _blockedRequests.reduce(self, LocallyReducer(ref, value))\n\nconst LocallyReducer = <A>(\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock.Reducer<BlockedRequests.RequestBlock> => ({\n  emptyCase: () => _blockedRequests.empty,\n  parCase: (left, right) => _blockedRequests.par(left, right),\n  seqCase: (left, right) => _blockedRequests.seq(left, right),\n  singleCase: (dataSource, blockedRequest) =>\n    _blockedRequests.single(\n      resolverLocally(dataSource, ref, value),\n      blockedRequest as any\n    )\n})\n\n/* @internal */\nexport const fiberRefLocally: {\n  <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R>\n} = dual(\n  3,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R> =>\n    acquireUseRelease(\n      zipLeft(fiberRefGet(self), fiberRefSet(self, value)),\n      () => use,\n      (oldValue) => fiberRefSet(self, oldValue)\n    )\n)\n\n/* @internal */\nexport const fiberRefLocallyWith = dual<\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<B, E, R>\n>(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))))\n\n/** @internal */\nexport const fiberRefUnsafeMake = <Value>(\n  initial: Value,\n  options?: {\n    readonly fork?: ((a: Value) => Value) | undefined\n    readonly join?: ((left: Value, right: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: internalDiffer.update(),\n    fork: options?.fork ?? identity,\n    join: options?.join\n  })\n\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = <A>(\n  initial: HashSet.HashSet<A>\n): FiberRef.FiberRef<HashSet.HashSet<A>> => {\n  const differ = internalDiffer.hashSet<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeReadonlyArray = <A>(\n  initial: ReadonlyArray<A>\n): FiberRef.FiberRef<ReadonlyArray<A>> => {\n  const differ = internalDiffer.readonlyArray(internalDiffer.update<A>())\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeContext = <A>(\n  initial: Context.Context<A>\n): FiberRef.FiberRef<Context.Context<A>> => {\n  const differ = internalDiffer.environment<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakePatch = <Value, Patch>(\n  initial: Value,\n  options: {\n    readonly differ: Differ.Differ<Value, Patch>\n    readonly fork: Patch\n    readonly join?: ((oldV: Value, newV: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> => {\n  const _fiberRef = {\n    ...CommitPrototype,\n    [FiberRefTypeId]: fiberRefVariance,\n    initial,\n    commit() {\n      return fiberRefGet(this)\n    },\n    diff: (oldValue: Value, newValue: Value) => options.differ.diff(oldValue, newValue),\n    combine: (first: Patch, second: Patch) => options.differ.combine(first, second),\n    patch: (patch: Patch) => (oldValue: Value) => options.differ.patch(patch, oldValue),\n    fork: options.fork,\n    join: options.join ?? ((_, n) => n)\n  }\n  return _fiberRef\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = (\n  initial: RuntimeFlags.RuntimeFlags\n): FiberRef.FiberRef<RuntimeFlags.RuntimeFlags> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: _runtimeFlags.differ,\n    fork: _runtimeFlags.differ.empty\n  })\n\n/** @internal */\nexport const currentContext: FiberRef.FiberRef<Context.Context<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentContext\"),\n  () => fiberRefUnsafeMakeContext(Context.empty())\n)\n\n/** @internal */\nexport const currentSchedulingPriority: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"),\n  () => fiberRefUnsafeMake(0)\n)\n\n/** @internal */\nexport const currentMaxOpsBeforeYield: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"),\n  () => fiberRefUnsafeMake(2048)\n)\n\n/** @internal */\nexport const currentLogAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogAnnotation\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentLogLevel: FiberRef.FiberRef<LogLevel.LogLevel> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogLevel\"),\n  () => fiberRefUnsafeMake<LogLevel.LogLevel>(logLevelInfo)\n)\n\n/** @internal */\nexport const currentLogSpan: FiberRef.FiberRef<List.List<LogSpan.LogSpan>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogSpan\"),\n  () => fiberRefUnsafeMake(List.empty<LogSpan.LogSpan>())\n)\n\n/** @internal */\nexport const withSchedulingPriority = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler))\n\n/** @internal */\nexport const withMaxOpsBeforeYield = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler))\n\n/** @internal */\nexport const currentConcurrency: FiberRef.FiberRef<\"unbounded\" | number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentConcurrency\"),\n  () => fiberRefUnsafeMake<\"unbounded\" | number>(\"unbounded\")\n)\n\n/**\n * @internal\n */\nexport const currentRequestBatching = globalValue(\n  Symbol.for(\"effect/FiberRef/currentRequestBatching\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentUnhandledErrorLogLevel: FiberRef.FiberRef<Option.Option<LogLevel.LogLevel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"),\n  () => fiberRefUnsafeMake(Option.some<LogLevel.LogLevel>(logLevelDebug))\n)\n\n/** @internal */\nexport const withUnhandledErrorLogLevel = dual<\n  (level: Option.Option<LogLevel.LogLevel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>) => Effect.Effect<A, E, R>\n>(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level))\n\n/** @internal */\nexport const currentMetricLabels: FiberRef.FiberRef<ReadonlyArray<MetricLabel.MetricLabel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMetricLabels\"),\n  () => fiberRefUnsafeMakeReadonlyArray(Arr.empty())\n)\n\n/* @internal */\nexport const metricLabels: Effect.Effect<ReadonlyArray<MetricLabel.MetricLabel>> = fiberRefGet(\n  currentMetricLabels\n)\n\n/** @internal */\nexport const currentForkScopeOverride: FiberRef.FiberRef<Option.Option<fiberScope.FiberScope>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"),\n  () =>\n    fiberRefUnsafeMake(Option.none(), {\n      fork: () => Option.none() as Option.Option<fiberScope.FiberScope>,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentInterruptedCause: FiberRef.FiberRef<Cause.Cause<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentInterruptedCause\"),\n  () =>\n    fiberRefUnsafeMake(internalCause.empty, {\n      fork: () => internalCause.empty,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentTracerEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerEnabled\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerTimingEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerTiming\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerSpanAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentTracerSpanLinks: FiberRef.FiberRef<Chunk.Chunk<Tracer.SpanLink>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"),\n  () => fiberRefUnsafeMake(Chunk.empty())\n)\n\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const ScopeTypeId: Scope.ScopeTypeId = Symbol.for(\"effect/Scope\") as Scope.ScopeTypeId\n\n/** @internal */\nexport const CloseableScopeTypeId: Scope.CloseableScopeTypeId = Symbol.for(\n  \"effect/CloseableScope\"\n) as Scope.CloseableScopeTypeId\n\n/* @internal */\nexport const scopeAddFinalizer = (\n  self: Scope.Scope,\n  finalizer: Effect.Effect<unknown>\n): Effect.Effect<void> => self.addFinalizer(() => asVoid(finalizer))\n\n/* @internal */\nexport const scopeAddFinalizerExit = (\n  self: Scope.Scope,\n  finalizer: Scope.Scope.Finalizer\n): Effect.Effect<void> => self.addFinalizer(finalizer)\n\n/* @internal */\nexport const scopeClose = (\n  self: Scope.Scope.Closeable,\n  exit: Exit.Exit<unknown, unknown>\n): Effect.Effect<void> => self.close(exit)\n\n/* @internal */\nexport const scopeFork = (\n  self: Scope.Scope,\n  strategy: ExecutionStrategy.ExecutionStrategy\n): Effect.Effect<Scope.Scope.Closeable> => self.fork(strategy)\n\n// -----------------------------------------------------------------------------\n// Cause\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const causeSquash = <E>(self: Cause.Cause<E>): unknown => {\n  return causeSquashWith(identity)(self)\n}\n\n/** @internal */\nexport const causeSquashWith = dual<\n  <E>(f: (error: E) => unknown) => (self: Cause.Cause<E>) => unknown,\n  <E>(self: Cause.Cause<E>, f: (error: E) => unknown) => unknown\n>(2, (self, f) => {\n  const option = pipe(self, internalCause.failureOption, Option.map(f))\n  switch (option._tag) {\n    case \"None\": {\n      return pipe(\n        internalCause.defects(self),\n        Chunk.head,\n        Option.match({\n          onNone: () => {\n            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap((fiberId) =>\n              Arr.fromIterable(FiberId.ids(fiberId)).map((id) => `#${id}`)\n            )\n            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0)\n          },\n          onSome: identity\n        })\n      )\n    }\n    case \"Some\": {\n      return option.value\n    }\n  }\n})\n\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const YieldableError: new(message?: string, options?: ErrorOptions) => Cause.YieldableError = (function() {\n  class YieldableError extends globalThis.Error {\n    commit() {\n      return fail(this)\n    }\n    toJSON() {\n      return { ...this }\n    }\n    [NodeInspectSymbol]() {\n      if (this.toString !== globalThis.Error.prototype.toString) {\n        return this.stack ? `${this.toString()}\\n${this.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : this.toString()\n      } else if (\"Bun\" in globalThis) {\n        return internalCause.pretty(internalCause.fail(this), { renderErrorCause: true })\n      }\n      return this\n    }\n  }\n  Object.assign(YieldableError.prototype, StructuralCommitPrototype)\n  return YieldableError as any\n})()\n\nconst makeException = <T extends { _tag: string; message?: string }>(\n  proto: Omit<T, keyof Cause.YieldableError | \"_tag\">,\n  tag: T[\"_tag\"]\n): new(message?: string | undefined) => T => {\n  class Base extends YieldableError {\n    readonly _tag = tag\n  }\n  Object.assign(Base.prototype, proto)\n  ;(Base.prototype as any).name = tag\n  return Base as any\n}\n\n/** @internal */\nexport const RuntimeExceptionTypeId: Cause.RuntimeExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/RuntimeException\"\n) as Cause.RuntimeExceptionTypeId\n\n/** @internal */\nexport const RuntimeException = makeException<Cause.RuntimeException>({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\")\n\n/** @internal */\nexport const isRuntimeException = (u: unknown): u is Cause.RuntimeException => hasProperty(u, RuntimeExceptionTypeId)\n\n/** @internal */\nexport const InterruptedExceptionTypeId: Cause.InterruptedExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InterruptedException\"\n) as Cause.InterruptedExceptionTypeId\n\n/** @internal */\nexport const InterruptedException = makeException<Cause.InterruptedException>({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\")\n\n/** @internal */\nexport const isInterruptedException = (u: unknown): u is Cause.InterruptedException =>\n  hasProperty(u, InterruptedExceptionTypeId)\n\n/** @internal */\nexport const IllegalArgumentExceptionTypeId: Cause.IllegalArgumentExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/IllegalArgument\"\n) as Cause.IllegalArgumentExceptionTypeId\n\n/** @internal */\nexport const IllegalArgumentException = makeException<Cause.IllegalArgumentException>({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\")\n\n/** @internal */\nexport const isIllegalArgumentException = (u: unknown): u is Cause.IllegalArgumentException =>\n  hasProperty(u, IllegalArgumentExceptionTypeId)\n\n/** @internal */\nexport const NoSuchElementExceptionTypeId: Cause.NoSuchElementExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/NoSuchElement\"\n) as Cause.NoSuchElementExceptionTypeId\n\n/** @internal */\nexport const NoSuchElementException = makeException<Cause.NoSuchElementException>({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\")\n\n/** @internal */\nexport const isNoSuchElementException = (u: unknown): u is Cause.NoSuchElementException =>\n  hasProperty(u, NoSuchElementExceptionTypeId)\n\n/** @internal */\nexport const InvalidPubSubCapacityExceptionTypeId: Cause.InvalidPubSubCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InvalidPubSubCapacityException\"\n) as Cause.InvalidPubSubCapacityExceptionTypeId\n\n/** @internal */\nexport const InvalidPubSubCapacityException = makeException<Cause.InvalidPubSubCapacityException>({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\")\n\n/** @internal */\nexport const ExceededCapacityExceptionTypeId: Cause.ExceededCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/ExceededCapacityException\"\n) as Cause.ExceededCapacityExceptionTypeId\n\n/** @internal */\nexport const ExceededCapacityException = makeException<Cause.ExceededCapacityException>({\n  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}, \"ExceededCapacityException\")\n\n/** @internal */\nexport const isExceededCapacityException = (u: unknown): u is Cause.ExceededCapacityException =>\n  hasProperty(u, ExceededCapacityExceptionTypeId)\n\n/** @internal */\nexport const isInvalidCapacityError = (u: unknown): u is Cause.InvalidPubSubCapacityException =>\n  hasProperty(u, InvalidPubSubCapacityExceptionTypeId)\n\n/** @internal */\nexport const TimeoutExceptionTypeId: Cause.TimeoutExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/Timeout\"\n) as Cause.TimeoutExceptionTypeId\n\n/** @internal */\nexport const TimeoutException = makeException<Cause.TimeoutException>({\n  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}, \"TimeoutException\")\n/** @internal */\nexport const timeoutExceptionFromDuration = (duration: Duration.DurationInput): Cause.TimeoutException =>\n  new TimeoutException(`Operation timed out before the specified duration of '${Duration.format(duration)}' elapsed`)\n\n/** @internal */\nexport const isTimeoutException = (u: unknown): u is Cause.TimeoutException => hasProperty(u, TimeoutExceptionTypeId)\n\n/** @internal */\nexport const UnknownExceptionTypeId: Cause.UnknownExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/UnknownException\"\n) as Cause.UnknownExceptionTypeId\n\n/** @internal */\nexport const UnknownException: new(cause: unknown, message?: string | undefined) => Cause.UnknownException =\n  (function() {\n    class UnknownException extends YieldableError {\n      readonly _tag = \"UnknownException\"\n      readonly error: unknown\n      constructor(readonly cause: unknown, message?: string) {\n        super(message ?? \"An unknown error occurred\", { cause })\n        this.error = cause\n      }\n    }\n    Object.assign(UnknownException.prototype, {\n      [UnknownExceptionTypeId]: UnknownExceptionTypeId,\n      name: \"UnknownException\"\n    })\n    return UnknownException as any\n  })()\n\n/** @internal */\nexport const isUnknownException = (u: unknown): u is Cause.UnknownException => hasProperty(u, UnknownExceptionTypeId)\n\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const exitIsExit = (u: unknown): u is Exit.Exit<unknown, unknown> =>\n  isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\")\n\n/** @internal */\nexport const exitIsFailure = <A, E>(self: Exit.Exit<A, E>): self is Exit.Failure<A, E> => self._tag === \"Failure\"\n\n/** @internal */\nexport const exitIsSuccess = <A, E>(self: Exit.Exit<A, E>): self is Exit.Success<A, E> => self._tag === \"Success\"\n\n/** @internal */\nexport const exitIsInterrupted = <A, E>(self: Exit.Exit<A, E>): boolean => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return internalCause.isInterrupted(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return false\n  }\n}\n\n/** @internal */\nexport const exitAs = dual<\n  <A2>(value: A2) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E>,\n  <A, E, A2>(self: Exit.Exit<A, E>, value: A2) => Exit.Exit<A2, E>\n>(2, <A, E, A2>(self: Exit.Exit<A, E>, value: A2): Exit.Exit<A2, E> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exitSucceed(value) as Exit.Exit<A2, E>\n    }\n  }\n})\n\n/** @internal */\nexport const exitAsVoid = <A, E>(self: Exit.Exit<A, E>): Exit.Exit<void, E> => exitAs(self, void 0)\n\n/** @internal */\nexport const exitCauseOption = <A, E>(self: Exit.Exit<A, E>): Option.Option<Cause.Cause<E>> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return Option.some(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return Option.none()\n  }\n}\n\n/** @internal */\nexport const exitCollectAll = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  options?: {\n    readonly parallel?: boolean | undefined\n  }\n): Option.Option<Exit.Exit<Array<A>, E>> =>\n  exitCollectAllInternal(exits, options?.parallel ? internalCause.parallel : internalCause.sequential)\n\n/** @internal */\nexport const exitDie = (defect: unknown): Exit.Exit<never> =>\n  exitFailCause(internalCause.die(defect)) as Exit.Exit<never>\n\n/** @internal */\nexport const exitExists: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit.Exit<A, E>) => self is Exit.Exit<B>\n  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit.Exit<A, E>) => boolean\n  <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B>\n  <A, E>(self: Exit.Exit<A, E>, predicate: Predicate<A>): boolean\n} = dual(2, <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return false\n    case OpCodes.OP_SUCCESS:\n      return refinement(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitFail = <E>(error: E): Exit.Exit<never, E> =>\n  exitFailCause(internalCause.fail(error)) as Exit.Exit<never, E>\n\n/** @internal */\nexport const exitFailCause = <E>(cause: Cause.Cause<E>): Exit.Exit<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/** @internal */\nexport const exitFlatMap = dual<\n  <A, A2, E2>(f: (a: A) => Exit.Exit<A2, E2>) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>): Exit.Exit<A2, E | E2> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatMapEffect: {\n  <A, E, A2, E2, R>(\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): (self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  <A, E, A2, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): Effect.Effect<Exit.Exit<A2, E>, E2, R>\n} = dual(2, <A, E, A2, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n): Effect.Effect<Exit.Exit<A2, E>, E2, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatten = <A, E, E2>(\n  self: Exit.Exit<Exit.Exit<A, E>, E2>\n): Exit.Exit<A, E | E2> => pipe(self, exitFlatMap(identity))\n\n/** @internal */\nexport const exitForEachEffect: {\n  <A, B, E2, R>(\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): <E>(self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n  <A, E, B, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n} = dual(2, <A, E, B, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<B, E2, R>\n): Effect.Effect<Exit.Exit<B, E | E2>, never, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exit(f(self.effect_instruction_i0))\n    }\n  }\n})\n\n/** @internal */\nexport const exitFromEither = <R, L>(either: Either.Either<R, L>): Exit.Exit<R, L> => {\n  switch (either._tag) {\n    case \"Left\":\n      return exitFail(either.left)\n    case \"Right\":\n      return exitSucceed(either.right)\n  }\n}\n\n/** @internal */\nexport const exitFromOption = <A>(option: Option.Option<A>): Exit.Exit<A, void> => {\n  switch (option._tag) {\n    case \"None\":\n      return exitFail(void 0)\n    case \"Some\":\n      return exitSucceed(option.value)\n  }\n}\n\n/** @internal */\nexport const exitGetOrElse = dual<\n  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2) => <A>(self: Exit.Exit<A, E>) => A | A2,\n  <A, E, A2>(self: Exit.Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2) => A | A2\n>(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return orElse(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return self.effect_instruction_i0\n  }\n})\n\n/** @internal */\nexport const exitInterrupt = (fiberId: FiberId.FiberId): Exit.Exit<never> =>\n  exitFailCause(internalCause.interrupt(fiberId))\n\n/** @internal */\nexport const exitMap = dual<\n  <A, B>(f: (a: A) => B) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<B, E>,\n  <A, E, B>(self: Exit.Exit<A, E>, f: (a: A) => B) => Exit.Exit<B, E>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(f(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapBoth = dual<\n  <E, A, E2, A2>(\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<A2, E2>,\n  <A, E, E2, A2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => Exit.Exit<A2, E2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(onFailure)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(onSuccess(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapError = dual<\n  <E, E2>(f: (e: E) => E2) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <A, E, E2>(self: Exit.Exit<A, E>, f: (e: E) => E2) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(f)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMapErrorCause = dual<\n  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <E, A, E2>(self: Exit.Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(f(self.effect_instruction_i0))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatch = dual<\n  <E, A, Z1, Z2>(options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => (self: Exit.Exit<A, E>) => Z1 | Z2,\n  <A, E, Z1, Z2>(self: Exit.Exit<A, E>, options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => Z1 | Z2\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatchEffect = dual<\n  <E, A2, E2, R, A, A3, E3, R2>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>,\n  <A, E, A2, E2, R, A3, E3, R2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => Effect.Effect<A2 | A3, E2 | E3, R | R2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitSucceed = <A>(value: A): Exit.Exit<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/** @internal */\nexport const exitVoid: Exit.Exit<void> = exitSucceed(void 0)\n\n/** @internal */\nexport const exitZip = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipPar = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipWith = dual<\n  <B, E2, A, C, E>(\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<C, E | E2>,\n  <A, E, B, E2, C>(\n    self: Exit.Exit<A, E>,\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => Exit.Exit<C, E | E2>\n>(3, (\n  self,\n  that,\n  { onFailure, onSuccess }\n) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitFailCause(self.effect_instruction_i0)\n        case OpCodes.OP_FAILURE: {\n          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0))\n        }\n      }\n    }\n    case OpCodes.OP_SUCCESS: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0))\n        case OpCodes.OP_FAILURE:\n          return exitFailCause(that.effect_instruction_i0)\n      }\n    }\n  }\n})\n\nconst exitCollectAllInternal = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  combineCauses: (causeA: Cause.Cause<E>, causeB: Cause.Cause<E>) => Cause.Cause<E>\n): Option.Option<Exit.Exit<Array<A>, E>> => {\n  const list = Chunk.fromIterable(exits)\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none()\n  }\n  return pipe(\n    Chunk.tailNonEmpty(list),\n    Arr.reduce(\n      pipe(Chunk.headNonEmpty(list), exitMap<A, Chunk.Chunk<A>>(Chunk.of)),\n      (accumulator, current) =>\n        pipe(\n          accumulator,\n          exitZipWith(current, {\n            onSuccess: (list, value) => pipe(list, Chunk.prepend(value)),\n            onFailure: combineCauses\n          })\n        )\n    ),\n    exitMap(Chunk.reverse),\n    exitMap((chunk) => Chunk.toReadonlyArray(chunk) as Array<A>),\n    Option.some\n  )\n}\n\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const deferredUnsafeMake = <A, E = never>(fiberId: FiberId.FiberId): Deferred.Deferred<A, E> => {\n  const _deferred = {\n    ...CommitPrototype,\n    [deferred.DeferredTypeId]: deferred.deferredVariance,\n    state: MutableRef.make(deferred.pending<A, E>([])),\n    commit() {\n      return deferredAwait(this)\n    },\n    blockingOn: fiberId\n  }\n  return _deferred\n}\n\n/* @internal */\nexport const deferredMake = <A, E = never>(): Effect.Effect<Deferred.Deferred<A, E>> =>\n  flatMap(fiberId, (id) => deferredMakeAs<A, E>(id))\n\n/* @internal */\nexport const deferredMakeAs = <A, E = never>(fiberId: FiberId.FiberId): Effect.Effect<Deferred.Deferred<A, E>> =>\n  sync(() => deferredUnsafeMake<A, E>(fiberId))\n\n/* @internal */\nexport const deferredAwait = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<A, E> =>\n  async<A, E>((resume) => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return resume(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        // we can push here as the internal state is mutable\n        state.joiners.push(resume)\n        return deferredInterruptJoiner(self, resume)\n      }\n    }\n  }, self.blockingOn)\n\n/* @internal */\nexport const deferredComplete: {\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>\n} = dual(\n  2,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean> =>\n    intoDeferred(effect, self)\n)\n\n/* @internal */\nexport const deferredCompleteWith = dual<\n  <A, E>(effect: Effect.Effect<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>) => Effect.Effect<boolean>\n>(2, (self, effect) =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return false\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        MutableRef.set(self.state, deferred.done(effect))\n        for (let i = 0, len = state.joiners.length; i < len; i++) {\n          state.joiners[i](effect)\n        }\n        return true\n      }\n    }\n  }))\n\n/* @internal */\nexport const deferredDone = dual<\n  <A, E>(exit: Exit.Exit<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, exit: Exit.Exit<A, E>) => Effect.Effect<boolean>\n>(2, (self, exit) => deferredCompleteWith(self, exit))\n\n/* @internal */\nexport const deferredFail = dual<\n  <E>(error: E) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, error: E) => Effect.Effect<boolean>\n>(2, (self, error) => deferredCompleteWith(self, fail(error)))\n\n/* @internal */\nexport const deferredFailSync = dual<\n  <E>(evaluate: LazyArg<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<E>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)))\n\n/* @internal */\nexport const deferredFailCause = dual<\n  <E>(cause: Cause.Cause<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, cause: Cause.Cause<E>) => Effect.Effect<boolean>\n>(2, (self, cause) => deferredCompleteWith(self, failCause(cause)))\n\n/* @internal */\nexport const deferredFailCauseSync = dual<\n  <E>(evaluate: LazyArg<Cause.Cause<E>>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)))\n\n/* @internal */\nexport const deferredDie = dual<\n  (defect: unknown) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, defect: unknown) => Effect.Effect<boolean>\n>(2, (self, defect) => deferredCompleteWith(self, die(defect)))\n\n/* @internal */\nexport const deferredDieSync = dual<\n  (evaluate: LazyArg<unknown>) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<unknown>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)))\n\n/* @internal */\nexport const deferredInterrupt = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  flatMap(fiberId, (fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredInterruptWith = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<boolean>\n>(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredIsDone = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE)\n\n/* @internal */\nexport const deferredPoll = <A, E>(\n  self: Deferred.Deferred<A, E>\n): Effect.Effect<Option.Option<Effect.Effect<A, E>>> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return Option.some(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        return Option.none()\n      }\n    }\n  })\n\n/* @internal */\nexport const deferredSucceed = dual<\n  <A>(value: A) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, value: A) => Effect.Effect<boolean>\n>(2, (self, value) => deferredCompleteWith(self, succeed(value)))\n\n/* @internal */\nexport const deferredSync = dual<\n  <A>(evaluate: LazyArg<A>) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<A>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)))\n\n/** @internal */\nexport const deferredUnsafeDone = <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): void => {\n  const state = MutableRef.get(self.state)\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(self.state, deferred.done(effect))\n    for (let i = 0, len = state.joiners.length; i < len; i++) {\n      state.joiners[i](effect)\n    }\n  }\n}\n\nconst deferredInterruptJoiner = <A, E>(\n  self: Deferred.Deferred<A, E>,\n  joiner: (effect: Effect.Effect<A, E>) => void\n): Effect.Effect<void> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n      const index = state.joiners.indexOf(joiner)\n      if (index >= 0) {\n        // we can splice here as the internal state is mutable\n        state.joiners.splice(index, 1)\n      }\n    }\n  })\n\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\n\nconst constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext))\n\n/* @internal */\nexport const context = <R>(): Effect.Effect<Context.Context<R>, never, R> => constContext as any\n\n/* @internal */\nexport const contextWith = <R0, A>(\n  f: (context: Context.Context<R0>) => A\n): Effect.Effect<A, never, R0> => map(context<R0>(), f)\n\n/* @internal */\nexport const contextWithEffect = <R0, A, E, R>(\n  f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R | R0> => flatMap(context<R0>(), f)\n\n/* @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) => Effect.Effect<A, E>\n>(2, <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) =>\n  fiberRefLocally(\n    currentContext,\n    context\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const provideSomeContext = dual<\n  <R>(context: Context.Context<R>) => <A, E, R1>(self: Effect.Effect<A, E, R1>) => Effect.Effect<A, E, Exclude<R1, R>>,\n  <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) => Effect.Effect<A, E, Exclude<R1, R>>\n>(2, <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) =>\n  fiberRefLocallyWith(\n    currentContext,\n    (parent) => Context.merge(parent, context)\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const mapInputContext = dual<\n  <R0, R>(\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R0>,\n  <A, E, R, R0>(\n    self: Effect.Effect<A, E, R>,\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => Effect.Effect<A, E, R0>\n>(2, <A, E, R, R0>(\n  self: Effect.Effect<A, E, R>,\n  f: (context: Context.Context<R0>) => Context.Context<R>\n) => contextWithEffect((context: Context.Context<R0>) => provideContext(self, f(context))))\n\n// -----------------------------------------------------------------------------\n// Tracing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const currentSpanFromFiber = <A, E>(fiber: Fiber.RuntimeFiber<A, E>): Option.Option<Tracer.Span> => {\n  const span = fiber.currentSpan\n  return span !== undefined && span._tag === \"Span\" ? Option.some(span) : Option.none()\n}\n\nconst NoopSpanProto: Tracer.Span = {\n  _tag: \"Span\",\n  spanId: \"noop\",\n  traceId: \"noop\",\n  name: \"noop\",\n  sampled: false,\n  parent: Option.none(),\n  context: Context.empty(),\n  status: {\n    _tag: \"Ended\",\n    startTime: BigInt(0),\n    endTime: BigInt(0),\n    exit: exitVoid\n  },\n  attributes: new Map(),\n  links: [],\n  kind: \"internal\",\n  attribute() {},\n  event() {},\n  end() {}\n}\n\n/** @internal */\nexport const noopSpan = (name: string): Tracer.Span => {\n  const span = Object.create(NoopSpanProto)\n  span.name = name\n  return span\n}\n"],"names":["internalCall","Arr","Chunk","Context","Duration","Either","Equal","FiberId","dual","identity","pipe","globalValue","Hash","HashMap","format","NodeInspectSymbol","toJSON","List","MutableRef","Option","pipeArguments","hasProperty","isObject","isPromiseLike","RuntimeFlagsPatch","YieldWrap","_blockedRequests","internalCause","deferred","internalDiffer","CommitPrototype","effectVariance","StructuralCommitPrototype","getBugErrorMessage","DeferredOpCodes","OpCodes","_runtimeFlags","SingleShotGen","EffectErrorSymbolKey","EffectErrorTypeId","Symbol","for","isEffectError","u","makeEffectError","cause","_tag","blocked","blockedRequests","_continue","effect","EffectPrimitive","effect_instruction_i0","effect_instruction_i1","runRequestBlock","EffectTypeId","RevertFlags","patch","op","_op","OP_REVERT_FLAGS","constructor","undefined","effect_instruction_i2","trace","symbol","that","cached","random","arguments","_id","toString","iterator","EffectPrimitiveFailure","exitIsExit","equals","string","combine","hash","EffectPrimitiveSuccess","value","isEffect","withFiberRuntime","withRuntime","OP_WITH_RUNTIME","acquireUseRelease","acquire","use","release","uninterruptibleMask","restore","flatMap","a","exit","suspend","matchCauseEffect","onFailure","OP_FAILURE","failCause","parallel","OP_SUCCESS","onSuccess","as","self","succeed","asVoid","custom","wrapper","OP_COMMIT","length","commit","Error","unsafeAsync","register","blockingOn","none","OP_ASYNC","cancelerRef","resume","onInterrupt","_","void_","async","backingResume","pendingEffect","proxyResume","controllerRef","AbortController","signal","abort","catchAllCause","f","OP_ON_FAILURE","catchAll","matchEffect","catchIf","predicate","either","failureOrCause","left","right","catchSome","pf","getOrElse","checkInterruptible","status","interruption","runtimeFlags","spanSymbol","originalSymbol","originalInstance","obj","capture","span","isSome","Proxy","has","target","p","get","die","defect","fiber","currentSpanFromFiber","dieMessage","message","failCauseSync","RuntimeException","dieSync","evaluate","sync","e","matchCause","exitFailCause","exitSucceed","fail","error","failSync","fiberId","state","id","fiberIdWith","OP_ON_SUCCESS","andThen","b","then","UnknownException","step","flatten","flip","options","OP_ON_SUCCESS_AND_FAILURE","defects","electFailures","failures","unsafeHead","forEachSequential","arr","fromIterable","ret","allocate","i","whileLoop","while","body","forEachSequentialDiscard","if_","args","onTrue","onFalse","interrupt","interruptWith","interruptible","OP_UPDATE_RUNTIME_FLAGS","enable","Interruption","interruptibleMask","oldFlags","uninterruptible","intoDeferred","deferredDone","map","mapBoth","mapError","onError","cleanup","onExit","exitIsSuccess","cause1","result","cause2","sequential","success","zipRight","exitMatch","isInterruptedOnly","interruptors","orElse","attemptOrElse","orDie","orDieWith","partitionMap","thunk","OP_SYNC","tap","transplant","scopeOverride","getFiberRef","currentForkScopeOverride","scope","fiberRefLocally","some","getOrThrow","keepDefectsAndElectFailures","disable","void","updateRuntimeFlags","whenEffect","condition","OP_WHILE","withConcurrency","concurrency","currentConcurrency","withRequestBatching","requestBatching","currentRequestBatching","withRuntimeFlags","update","withTracerEnabled","enabled","currentTracerEnabled","withTracerTiming","currentTracerTimingEnabled","yieldNow","OP_YIELD","priority","withSchedulingPriority","zip","zipFlatten","zipLeft","zipWith","never","interval","setInterval","clearInterval","interruptFiber","interruptAsFiber","interruptAsFork","await","logLevelAll","syslog","label","ordinal","Number","MIN_SAFE_INTEGER","logLevelFatal","logLevelError","logLevelWarning","logLevelInfo","logLevelDebug","logLevelTrace","logLevelNone","MAX_SAFE_INTEGER","allLogLevels","FiberRefSymbolKey","FiberRefTypeId","fiberRefVariance","_A","fiberRefGet","fiberRefGetAndSet","fiberRefModify","v","fiberRefGetAndUpdate","fiberRefGetAndUpdateSome","fiberRefGetWith","fiberRefSet","fiberRefDelete","unsafeDeleteFiberRef","fiberRefReset","initial","setFiberRef","fiberRefModifySome","def","fiberRefUpdate","fiberRefUpdateSome","fiberRefUpdateAndGet","fiberRefUpdateSomeAndGet","RequestResolverSymbolKey","RequestResolverTypeId","requestResolverVariance","_R","RequestResolverImpl","runAll","isRequestResolver","identified","ids","resolverLocally","requests","make","requestBlockLocally","ref","reduce","LocallyReducer","emptyCase","empty","parCase","par","seqCase","seq","singleCase","dataSource","blockedRequest","single","oldValue","fiberRefLocallyWith","fiberRefUnsafeMake","fiberRefUnsafeMakePatch","differ","fork","join","fiberRefUnsafeMakeHashSet","hashSet","fiberRefUnsafeMakeReadonlyArray","readonlyArray","fiberRefUnsafeMakeContext","environment","_fiberRef","diff","newValue","first","second","n","fiberRefUnsafeMakeRuntimeFlags","currentContext","currentSchedulingPriority","currentMaxOpsBeforeYield","currentLogAnnotations","currentLogLevel","currentLogSpan","scheduler","withMaxOpsBeforeYield","currentUnhandledErrorLogLevel","withUnhandledErrorLogLevel","level","currentMetricLabels","metricLabels","parent","currentInterruptedCause","currentTracerSpanAnnotations","currentTracerSpanLinks","ScopeTypeId","CloseableScopeTypeId","scopeAddFinalizer","finalizer","addFinalizer","scopeAddFinalizerExit","scopeClose","close","scopeFork","strategy","causeSquash","causeSquashWith","option","failureOption","head","match","onNone","interrupts","InterruptedException","onSome","YieldableError","globalThis","prototype","stack","split","slice","pretty","renderErrorCause","Object","assign","makeException","proto","tag","Base","name","RuntimeExceptionTypeId","isRuntimeException","InterruptedExceptionTypeId","isInterruptedException","IllegalArgumentExceptionTypeId","IllegalArgumentException","isIllegalArgumentException","NoSuchElementExceptionTypeId","NoSuchElementException","isNoSuchElementException","InvalidPubSubCapacityExceptionTypeId","InvalidPubSubCapacityException","ExceededCapacityExceptionTypeId","ExceededCapacityException","isExceededCapacityException","isInvalidCapacityError","TimeoutExceptionTypeId","TimeoutException","timeoutExceptionFromDuration","duration","isTimeoutException","UnknownExceptionTypeId","isUnknownException","exitIsFailure","exitIsInterrupted","isInterrupted","exitAs","exitAsVoid","exitCauseOption","exitCollectAll","exits","exitCollectAllInternal","exitDie","exitExists","refinement","exitFail","exitFlatMap","exitFlatMapEffect","exitFlatten","exitForEachEffect","exitFromEither","exitFromOption","exitGetOrElse","exitInterrupt","exitMap","exitMapBoth","exitMapError","exitMapErrorCause","exitMatchEffect","exitVoid","exitZip","exitZipWith","a2","exitZipLeft","exitZipRight","exitZipPar","exitZipParLeft","exitZipParRight","combineCauses","list","isNonEmpty","tailNonEmpty","headNonEmpty","of","accumulator","current","prepend","reverse","chunk","toReadonlyArray","deferredUnsafeMake","_deferred","DeferredTypeId","deferredVariance","pending","deferredAwait","deferredMake","deferredMakeAs","OP_STATE_DONE","OP_STATE_PENDING","joiners","push","deferredInterruptJoiner","deferredComplete","deferredCompleteWith","set","done","len","deferredFail","deferredFailSync","deferredFailCause","deferredFailCauseSync","deferredDie","deferredDieSync","deferredInterrupt","deferredInterruptWith","deferredIsDone","deferredPoll","deferredSucceed","deferredSync","deferredUnsafeDone","joiner","index","indexOf","splice","constContext","context","contextWith","contextWithEffect","provideContext","provideSomeContext","merge","mapInputContext","currentSpan","NoopSpanProto","spanId","traceId","sampled","startTime","BigInt","endTime","attributes","Map","links","kind","attribute","event","end","noopSpan","create"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAASqB,WAAW,EAAEC,QAAQ,EAAEC,aAAa,QAAyC,iBAAiB;AAmBvG,OAAO,KAAKY,OAAO,MAAM,qBAAqB;AAL9C,SAASL,eAAe,EAAEC,cAAc,EAAEC,yBAAyB,QAAQ,iBAAiB;AAnC5F,OAAO,KAAK1B,KAAK,MAAM,aAAa;AAUpC,OAAO,KAAKM,IAAI,MAAM,YAAY;AAUlC,SAASQ,aAAa,QAAQ,gBAAgB;AAP9C,SAASN,MAAM,EAAEC,iBAAiB,EAAEC,MAAM,QAAQ,mBAAmB;AA6BrE,SAASqB,aAAa,QAAQ,oBAAoB;AAZlD,SAASZ,SAAS,QAAQ,aAAa;AAtBvC,SAASjB,IAAI,EAAEC,QAAQ,EAAEC,IAAI,QAAQ,gBAAgB;AAwBrD,OAAO,KAAKiB,aAAa,MAAM,YAAY;AAI3C,SAASM,kBAAkB,QAAQ,aAAa;AAhChD,OAAO,KAAK1B,OAAO,MAAM,eAAe;AAexC,OAAO,KAAKY,MAAM,MAAM,cAAc;AAsBtC,OAAO,KAAKiB,aAAa,MAAM,mBAAmB;AA1ClD,OAAO,KAAK/B,MAAM,MAAM,cAAc;AANtC,OAAO,KAAKH,KAAK,MAAM,aAAa;AAFpC,OAAO,KAAKD,GAAG,MAAM,aAAa;AAmClC,OAAO,KAAKuB,iBAAiB,MAAM,yBAAyB;AAK5D,OAAO,KAAKE,gBAAgB,MAAM,sBAAsB;AAGxD,OAAO,KAAKG,cAAc,MAAM,aAAa;AAzB7C,SAASlB,WAAW,QAAQ,mBAAmB;AAf/C,OAAO,KAAKR,OAAO,MAAM,eAAe;AAiBxC,OAAO,KAAKU,OAAO,MAAM,eAAe;AAGxC,OAAO,KAAKI,IAAI,MAAM,YAAY;AAjBlC,OAAO,KAAKb,QAAQ,MAAM,gBAAgB;AAoC1C,OAAO,KAAKwB,QAAQ,MAAM,eAAe;AAfzC,OAAO,KAAKV,UAAU,MAAM,kBAAkB;AAqB9C,OAAO,KAAKgB,eAAe,MAAM,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKxD,gFAAA;AACA,SAAA;AACA,gFAAA;AAEA,cAAA,GACA,MAAMI,oBAAoB,GAAG,oBAAoB;AAG1C,MAAMC,iBAAiB,GAAA,WAAA,GAAGC,MAAM,CAACC,GAAG,CAACH,oBAAoB,CAAC;AAa1D,MAAMI,aAAa,IAAIC,CAAU,gNAAgCtB,cAAAA,AAAW,EAACsB,CAAC,EAAEJ,iBAAiB,CAAC;AAGlG,MAAMK,eAAe,IAAOC,KAAqB,GAAA,CAAsB;QAC5E,CAACN,iBAAiB,CAAA,EAAGA,iBAAiB;QACtCO,IAAI,EAAE,aAAa;QACnBD;KACD,CAAC;AAKK,MAAME,OAAO,GAAGA,CACrBC,eAA6C,EAC7CC,SAA8B,KACN;IACxB,MAAMC,MAAM,GAAG,IAAIC,eAAe,CAAC,SAAS,CAAQ;IACpDD,MAAM,CAACE,qBAAqB,GAAGJ,eAAe;IAC9CE,MAAM,CAACG,qBAAqB,GAAGJ,SAAS;IACxC,OAAOC,MAAM;AACf,CAAC;AAKM,MAAMI,eAAe,IAC1BN,eAA6C,IACtB;IACvB,MAAME,MAAM,GAAG,IAAIC,eAAe,CAAC,YAAY,CAAQ;IACvDD,MAAM,CAACE,qBAAqB,GAAGJ,eAAe;IAC9C,OAAOE,MAAM;AACf,CAAC;AAGM,MAAMK,YAAY,GAAA,WAAA,GAAwBf,MAAM,CAACC,GAAG,CAAC,eAAe,CAAwB;AAiC7F,MAAOe,WAAW;IAGXC,KAAA,CAAA;IACAC,EAAA,CAAA;IAHFC,GAAG,GAAGxB,OAAO,sNAACyB,eAAe,CAAA;IACtCC,YACWJ,KAA0C,EAC1CC,EAAwD,CAAA;QADxD,IAAA,CAAAD,KAAK,GAALA,KAAK;QACL,IAAA,CAAAC,EAAE,GAAFA,EAAE;IAEb;;AAGF,MAAMP,eAAe;IAMEQ,GAAA,CAAA;IALdP,qBAAqB,GAAGU,SAAS,CAAA;IACjCT,qBAAqB,GAAGS,SAAS,CAAA;IACjCC,qBAAqB,GAAGD,SAAS,CAAA;IACjCE,KAAK,GAAGF,SAAS,CAAA;IACxB,CAACP,YAAY,CAAA,yNAAIxB,iBAAc,CAAA;IAC/B8B,YAAqBF,GAAqB,CAAA;QAArB,IAAA,CAAAA,GAAG,GAAHA,GAAG;IAAqB;IAC7C,CAACrD,KAAK,gMAAC2D,MAAM,CAAA,CAAYC,IAAa,EAAA;QACpC,OAAO,IAAI,KAAKA,IAAI;IACtB;IACA,CAACtD,IAAI,gMAACqD,MAAM,CAAA,GAAC;QACX,OAAOrD,IAAI,gMAACuD,MAAM,CAAC,IAAI,EAAEvD,IAAI,gMAACwD,MAAM,CAAC,IAAI,CAAC,CAAC;IAC7C;IACA1D,IAAIA,CAAA,EAAA;QACF,mNAAOU,gBAAa,AAAbA,EAAc,IAAI,EAAEiD,SAAS,CAAC;IACvC;IACArD,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLsD,GAAG,EAAE,QAAQ;YACbX,GAAG,EAAE,IAAI,CAACA,GAAG;YACbP,qBAAqB,iNAAEpC,SAAAA,AAAM,EAAC,IAAI,CAACoC,qBAAqB,CAAC;YACzDC,qBAAqB,GAAErC,uNAAAA,AAAM,EAAC,IAAI,CAACqC,qBAAqB,CAAC;YACzDU,qBAAqB,iNAAE/C,SAAAA,AAAM,EAAC,IAAI,CAAC+C,qBAAqB;SACzD;IACH;IACAQ,QAAQA,CAAA,EAAA;QACN,OAAOzD,wNAAAA,AAAM,EAAC,IAAI,CAACE,MAAM,EAAE,CAAC;IAC9B;IACA,4MAACD,oBAAiB,CAAA,GAAC;QACjB,OAAO,IAAI,CAACC,MAAM,EAAE;IACtB;IACA,CAACwB,MAAM,CAACgC,QAAQ,CAAA,GAAC;QACf,OAAO,6NAAInC,gBAAa,CAAC,IAAIZ,iNAAS,CAAC,IAAI,CAAC,CAAC;IAC/C;;AAGF,cAAA,GACA,MAAMgD,sBAAsB;IAMLd,GAAA,CAAA;IALdP,qBAAqB,GAAGU,SAAS,CAAA;IACjCT,qBAAqB,GAAGS,SAAS,CAAA;IACjCC,qBAAqB,GAAGD,SAAS,CAAA;IACjCE,KAAK,GAAGF,SAAS,CAAA;IACxB,CAACP,YAAY,CAAA,yNAAIxB,iBAAc,CAAA;IAC/B8B,YAAqBF,GAAqB,CAAA;QAArB,IAAA,CAAAA,GAAG,GAAHA,GAAG;QACtB,mBAAA;QACA,IAAI,CAACb,IAAI,GAAGa,GAAG;IACjB;IACA,CAACrD,KAAK,gMAAC2D,MAAM,CAAA,CAAYC,IAAa,EAAA;QACpC,OAAOQ,UAAU,CAACR,IAAI,CAAC,IAAIA,IAAI,CAACP,GAAG,KAAK,SAAS,IAC/C,mBAAA;QACArD,KAAK,gMAACqE,MAAM,CAAC,IAAI,CAACvB,qBAAqB,EAAEc,IAAI,CAACd,qBAAqB,CAAC;IACxE;IACA,CAACxC,IAAI,gMAACqD,MAAM,CAAA,GAAC;QACX,mNAAOvD,OAAAA,AAAI,EACT,mBAAA;QACAE,IAAI,gMAACgE,MAAM,CAAC,IAAI,CAAC9B,IAAI,CAAC,EACtB,mBAAA;QACAlC,IAAI,gMAACiE,OAAO,CAACjE,IAAI,gMAACkE,IAAI,CAAC,IAAI,CAAC1B,qBAAqB,CAAC,CAAC,EACnDxC,IAAI,gMAACuD,MAAM,CAAC,IAAI,CAAC,CAClB;IACH;IACA,IAAItB,KAAKA,CAAA,EAAA;QACP,OAAO,IAAI,CAACO,qBAAqB;IACnC;IACA1C,IAAIA,CAAA,EAAA;QACF,mNAAOU,gBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;IACArD,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLsD,GAAG,EAAE,MAAM;YACXxB,IAAI,EAAE,IAAI,CAACa,GAAG;YACdd,KAAK,EAAG,IAAI,CAACA,KAAa,CAAC7B,MAAM;SAClC;IACH;IACAuD,QAAQA,CAAA,EAAA;QACN,sNAAOzD,SAAAA,AAAM,EAAC,IAAI,CAACE,MAAM,EAAE,CAAC;IAC9B;IACA,4MAACD,oBAAiB,CAAA,GAAC;QACjB,OAAO,IAAI,CAACC,MAAM,EAAE;IACtB;IACA,CAACwB,MAAM,CAACgC,QAAQ,CAAA,GAAC;QACf,OAAO,6NAAInC,gBAAa,CAAC,yMAAIZ,YAAS,CAAC,IAAI,CAAC,CAAC;IAC/C;;AAGF,cAAA,GACA,MAAMsD,sBAAsB;IAMLpB,GAAA,CAAA;IALdP,qBAAqB,GAAGU,SAAS,CAAA;IACjCT,qBAAqB,GAAGS,SAAS,CAAA;IACjCC,qBAAqB,GAAGD,SAAS,CAAA;IACjCE,KAAK,GAAGF,SAAS,CAAA;IACxB,CAACP,YAAY,CAAA,GAAIxB,uOAAc,CAAA;IAC/B8B,YAAqBF,GAAqB,CAAA;QAArB,IAAA,CAAAA,GAAG,GAAHA,GAAG;QACtB,mBAAA;QACA,IAAI,CAACb,IAAI,GAAGa,GAAG;IACjB;IACA,CAACrD,KAAK,gMAAC2D,MAAM,CAAA,CAAYC,IAAa,EAAA;QACpC,OAAOQ,UAAU,CAACR,IAAI,CAAC,IAAIA,IAAI,CAACP,GAAG,KAAK,SAAS,IAC/C,mBAAA;QACArD,KAAK,gMAACqE,MAAM,CAAC,IAAI,CAACvB,qBAAqB,EAAEc,IAAI,CAACd,qBAAqB,CAAC;IACxE;IACA,CAACxC,IAAI,gMAACqD,MAAM,CAAA,GAAC;QACX,mNAAOvD,OAAAA,AAAI,EACT,mBAAA;QACAE,IAAI,gMAACgE,MAAM,CAAC,IAAI,CAAC9B,IAAI,CAAC,EACtB,mBAAA;QACAlC,IAAI,gMAACiE,OAAO,CAACjE,IAAI,gMAACkE,IAAI,CAAC,IAAI,CAAC1B,qBAAqB,CAAC,CAAC,EACnDxC,IAAI,gMAACuD,MAAM,CAAC,IAAI,CAAC,CAClB;IACH;IACA,IAAIa,KAAKA,CAAA,EAAA;QACP,OAAO,IAAI,CAAC5B,qBAAqB;IACnC;IACA1C,IAAIA,CAAA,EAAA;QACF,mNAAOU,gBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;IACArD,MAAMA,CAAA,EAAA;QACJ,OAAO;YACLsD,GAAG,EAAE,MAAM;YACXxB,IAAI,EAAE,IAAI,CAACa,GAAG;YACdqB,KAAK,EAAEhE,wNAAAA,AAAM,EAAC,IAAI,CAACgE,KAAK;SACzB;IACH;IACAT,QAAQA,CAAA,EAAA;QACN,sNAAOzD,SAAAA,AAAM,EAAC,IAAI,CAACE,MAAM,EAAE,CAAC;IAC9B;IACA,4MAACD,oBAAiB,CAAA,GAAC;QACjB,OAAO,IAAI,CAACC,MAAM,EAAE;IACtB;IACA,CAACwB,MAAM,CAACgC,QAAQ,CAAA,GAAC;QACf,OAAO,6NAAInC,gBAAa,CAAC,yMAAIZ,YAAS,CAAC,IAAI,CAAC,CAAC;IAC/C;;AAsHK,MAAMwD,QAAQ,GAAItC,CAAU,QAAoDtB,uNAAAA,AAAW,EAACsB,CAAC,EAAEY,YAAY,CAAC;AAG5G,MAAM2B,gBAAgB,IAC3BC,WAA4G,IAClF;IAC1B,MAAMjC,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACiD,eAAe,CAAQ;IAClElC,MAAM,CAACE,qBAAqB,GAAG+B,WAAW;IAC1C,OAAOjC,MAAM;AACf,CAAC;AAGM,MAAMmC,iBAAiB,GAAA,WAAA,GAU1B7E,mNAAAA,AAAI,EAAC,CAAC,EAAE,CACV8E,OAA+B,EAC/BC,GAAwC,EACxCC,OAAuE,GAEvEC,mBAAmB,EAAEC,OAAO,GAC1BC,OAAO,CACLL,OAAO,GACNM,CAAC,GACAD,OAAO,CAACE,IAAI,CAACC,OAAO,CAAC,IAAMJ,OAAO,CAACH,GAAG,CAACK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,IAAI,IAA4C;gBAC7F,OAAOC,OAAO,CAAC,IAAMN,OAAO,CAACI,CAAC,EAAEC,IAAI,CAAC,CAAC,CAACnF,IAAI,CACzCqF,gBAAgB,CAAC;oBACfC,SAAS,EAAGnD,KAAK,IAAI;wBACnB,OAAQgD,IAAI,CAAC/C,IAAI;4BACf,KAAKX,OAAO,sNAAC8D,UAAU;gCACrB,OAAOC,SAAS,CAACvE,aAAa,oMAACwE,QAAQ,CAACN,IAAI,CAACzC,qBAAqB,EAAEP,KAAK,CAAC,CAAC;4BAC7E,KAAKV,OAAO,sNAACiE,UAAU;gCACrB,OAAOF,SAAS,CAACrD,KAAK,CAAC;wBAC3B;oBACF,CAAC;oBACDwD,SAAS,EAAEA,CAAA,GAAMR;iBAClB,CAAC,CACH;YACH,CAAC,CAAC,CACL,CACF,CAAC;AAGG,MAAMS,EAAE,GAAA,WAAA,+MAGX9F,OAAAA,AAAI,EACN,CAAC,EACD,CAAa+F,IAA4B,EAAEvB,KAAQ,GAA6BW,OAAO,CAACY,IAAI,EAAE,IAAMC,OAAO,CAACxB,KAAK,CAAC,CAAC,CACpH;AAGM,MAAMyB,MAAM,IAAaF,IAA4B,GAAgCD,EAAE,CAACC,IAAI,EAAE,KAAK,CAAC,CAAC;AAGrG,MAAMG,MAAM,GAef,SAAAA,CAAA;IACF,MAAMC,OAAO,GAAG,IAAIxD,eAAe,CAAChB,OAAO,sNAACyE,SAAS,CAAQ;IAC7D,OAAQvC,SAAS,CAACwC,MAAM;QACtB,KAAK,CAAC;YAAE;gBACNF,OAAO,CAACvD,qBAAqB,GAAGiB,SAAS,CAAC,CAAC,CAAC;gBAC5CsC,OAAO,CAACG,MAAM,GAAGzC,SAAS,CAAC,CAAC,CAAC;gBAC7B;YACF;QACA,KAAK,CAAC;YAAE;gBACNsC,OAAO,CAACvD,qBAAqB,GAAGiB,SAAS,CAAC,CAAC,CAAC;gBAC5CsC,OAAO,CAACtD,qBAAqB,GAAGgB,SAAS,CAAC,CAAC,CAAC;gBAC5CsC,OAAO,CAACG,MAAM,GAAGzC,SAAS,CAAC,CAAC,CAAC;gBAC7B;YACF;QACA,KAAK,CAAC;YAAE;gBACNsC,OAAO,CAACvD,qBAAqB,GAAGiB,SAAS,CAAC,CAAC,CAAC;gBAC5CsC,OAAO,CAACtD,qBAAqB,GAAGgB,SAAS,CAAC,CAAC,CAAC;gBAC5CsC,OAAO,CAAC5C,qBAAqB,GAAGM,SAAS,CAAC,CAAC,CAAC;gBAC5CsC,OAAO,CAACG,MAAM,GAAGzC,SAAS,CAAC,CAAC,CAAC;gBAC7B;YACF;QACA;YAAS;gBACP,MAAM,IAAI0C,KAAK,uNAAC9E,qBAAAA,AAAkB,EAAC,oCAAoC,CAAC,CAAC;YAC3E;IACF;IACA,OAAO0E,OAAO;AAChB,CAAC;AAGM,MAAMK,WAAW,GAAGA,CACzBC,QAEyC,EACzCC,UAAA,GAA8B3G,OAAO,gMAAC4G,IAAI,KAChB;IAC1B,MAAMjE,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACiF,QAAQ,CAAQ;IAC3D,IAAIC,WAAW,GAAyCvD,SAAS;IACjEZ,MAAM,CAACE,qBAAqB,IAAIkE,MAA2C,IAAI;QAC7ED,WAAW,GAAGJ,QAAQ,CAACK,MAAM,CAAC;IAChC,CAAC;IACDpE,MAAM,CAACG,qBAAqB,GAAG6D,UAAU;IACzC,OAAOK,WAAW,CAACrE,MAAM,GAAGsE,CAAC,GAAKvC,QAAQ,CAACoC,WAAW,CAAC,GAAGA,WAAW,GAAGI,KAAK,CAAC;AAChF,CAAC;AAGM,MAAMC,KAAK,GAAGA,CACnBJ,MAGyC,EACzCJ,UAAA,GAA8B3G,OAAO,gMAAC4G,IAAI,KAChB;IAC1B,OAAOT,MAAM,CAACY,MAAM,EAAE;QACpB,IAAIK,aAAa,GAAsD7D,SAAS;QAChF,IAAI8D,aAAa,GAAuC9D,SAAS;QACjE,SAAS+D,WAAWA,CAAC3E,MAA8B;YACjD,IAAIyE,aAAa,EAAE;gBACjBA,aAAa,CAACzE,MAAM,CAAC;YACvB,CAAC,MAAM,IAAI0E,aAAa,KAAK9D,SAAS,EAAE;gBACtC8D,aAAa,GAAG1E,MAAM;YACxB;QACF;QACA,MAAMA,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACiF,QAAQ,CAAQ;QAC3DlE,MAAM,CAACE,qBAAqB,IAAIkE,MAA2C,IAAI;YAC7EK,aAAa,GAAGL,MAAM;YACtB,IAAIM,aAAa,EAAE;gBACjBN,MAAM,CAACM,aAAa,CAAC;YACvB;QACF,CAAC;QACD1E,MAAM,CAACG,qBAAqB,GAAG6D,UAAU;QACzC,IAAIG,WAAW,GAAyCvD,SAAS;QACjE,IAAIgE,aAAa,GAA2BhE,SAAS;QACrD,IAAI,IAAI,CAACV,qBAAqB,CAACyD,MAAM,KAAK,CAAC,EAAE;YAC3CiB,aAAa,GAAG,IAAIC,eAAe,EAAE;YACrCV,WAAW,2MAAGrH,gBAAY,AAAZA,EAAa,IAAM,IAAI,CAACoD,qBAAqB,CAACyE,WAAW,EAAEC,aAAc,CAACE,MAAM,CAAC,CAAC;QAClG,CAAC,MAAM;YACLX,WAAW,4MAAGrH,eAAAA,AAAY,EAAC,IAAO,IAAI,CAACoD,qBAA6B,CAACyE,WAAW,CAAC,CAAC;QACpF;QACA,OAAQR,WAAW,IAAIS,aAAa,GAClCP,WAAW,CAACrE,MAAM,GAAGsE,CAAC,IAAI;YACxB,IAAIM,aAAa,EAAE;gBACjBA,aAAa,CAACG,KAAK,EAAE;YACvB;YACA,OAAOZ,WAAW,IAAII,KAAK;QAC7B,CAAC,CAAC,GACFvE,MAAM;IACV,CAAC,CAAC;AACJ,CAAC;AAGM,MAAMgF,aAAa,GAAA,WAAA,+MAAG1H,OAAAA,AAAI,EAQ/B,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,KAAI;IACf,MAAMjF,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACiG,aAAa,CAAQ;IAChElF,MAAM,CAACE,qBAAqB,GAAGmD,IAAI;IACnCrD,MAAM,CAACG,qBAAqB,GAAG8E,CAAC;IAChC,OAAOjF,MAAM;AACf,CAAC,CAAC;AAGK,MAAMmF,QAAQ,GAAA,WAAA,+MAQjB7H,OAAAA,AAAI,EACN,CAAC,EACD,CACE+F,IAA4B,EAC5B4B,CAAsC,GACAG,WAAW,CAAC/B,IAAI,EAAE;QAAEP,SAAS,EAAEmC,CAAC;QAAE9B,SAAS,EAAEG;IAAO,CAAE,CAAC,CAChG;AAGM,MAAM+B,OAAO,GAAA,WAAA,+MAmBhB/H,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BiC,SAAuB,EACvBL,CAAsC,GAEtCD,aAAa,CAAC3B,IAAI,GAAG1D,KAAK,IAA2C;QACnE,MAAM4F,MAAM,GAAG9G,aAAa,oMAAC+G,cAAc,CAAC7F,KAAK,CAAC;QAClD,OAAQ4F,MAAM,CAAC3F,IAAI;YACjB,KAAK,MAAM;gBACT,OAAO0F,SAAS,CAACC,MAAM,CAACE,IAAI,CAAC,GAAGR,CAAC,CAACM,MAAM,CAACE,IAAI,CAAC,GAAGzC,SAAS,CAACrD,KAAK,CAAC;YACnE,KAAK,OAAO;gBACV,OAAOqD,SAAS,CAACuC,MAAM,CAACG,KAAK,CAAC;QAClC;IACF,CAAC,CAAC,CAAC;AAGE,MAAMC,SAAS,GAAA,WAAA,+MAAGrI,OAAAA,AAAI,EAQ3B,CAAC,EAAE,CACH+F,IAA4B,EAC5BuC,EAA+D,GAE/DZ,aAAa,CAAC3B,IAAI,GAAG1D,KAAK,IAA2C;QACnE,MAAM4F,MAAM,GAAG9G,aAAa,oMAAC+G,cAAc,CAAC7F,KAAK,CAAC;QAClD,OAAQ4F,MAAM,CAAC3F,IAAI;YACjB,KAAK,MAAM;gBACT,mNAAOpC,OAAAA,AAAI,EAACoI,EAAE,CAACL,MAAM,CAACE,IAAI,CAAC,EAAExH,MAAM,gMAAC4H,SAAS,CAAC,IAAM7C,SAAS,CAACrD,KAAK,CAAC,CAAC,CAAC;YACxE,KAAK,OAAO;gBACV,OAAOqD,SAAS,CAACuC,MAAM,CAACG,KAAK,CAAC;QAClC;IACF,CAAC,CAAC,CAAC;AAGE,MAAMI,kBAAkB,IAC7Bb,CAAuD,GAC5BjD,gBAAgB,CAAC,CAACsC,CAAC,EAAEyB,MAAM,GAAKd,CAAC,CAAC/F,aAAa,2MAAC8G,YAAY,CAACD,MAAM,CAACE,YAAY,CAAC,CAAC,CAAC;AAEhH,MAAMC,UAAU,GAAA,WAAA,GAAG5G,MAAM,CAACC,GAAG,CAAC,uBAAuB,CAAC;AACtD,MAAM4G,cAAc,GAAA,WAAA,GAAG7G,MAAM,CAACC,GAAG,CAAC,2BAA2B,CAAC;AAGvD,MAAM6G,gBAAgB,IAAOC,GAAM,IAAO;IAC/C,IAAIlI,2NAAW,AAAXA,EAAYkI,GAAG,EAAEF,cAAc,CAAC,EAAE;QACpC,mBAAA;QACA,OAAOE,GAAG,CAACF,cAAc,CAAC;IAC5B;IACA,OAAOE,GAAG;AACZ,CAAC;AAGM,MAAMC,OAAO,GAAGA,CAAID,GAAe,EAAEE,IAAgC,KAAO;IACjF,IAAItI,MAAM,gMAACuI,MAAM,CAACD,IAAI,CAAC,EAAE;QACvB,OAAO,IAAIE,KAAK,CAACJ,GAAG,EAAE;YACpBK,GAAGA,EAACC,MAAM,EAAEC,CAAC;gBACX,OAAOA,CAAC,KAAKV,UAAU,IAAIU,CAAC,KAAKT,cAAc,IAAIS,CAAC,IAAID,MAAM;YAChE,CAAC;YACDE,GAAGA,EAACF,MAAM,EAAEC,CAAC;gBACX,IAAIA,CAAC,KAAKV,UAAU,EAAE;oBACpB,OAAOK,IAAI,CAACzE,KAAK;gBACnB;gBACA,IAAI8E,CAAC,KAAKT,cAAc,EAAE;oBACxB,OAAOE,GAAG;gBACZ;gBACA,mBAAA;gBACA,OAAOM,MAAM,CAACC,CAAC,CAAC;YAClB;SACD,CAAC;IACJ;IACA,OAAOP,GAAG;AACZ,CAAC;AAGM,MAAMS,GAAG,IAAIC,MAAe,gNACjC3I,WAAAA,AAAQ,EAAC2I,MAAM,CAAC,IAAI,CAAA,CAAEb,UAAU,IAAIa,MAAM,CAAC,GACzC/E,gBAAgB,EAAEgF,KAAK,GAAKhE,SAAS,CAACvE,aAAa,oMAACqI,GAAG,CAACR,OAAO,CAACS,MAAM,EAAEE,oBAAoB,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GACrGhE,SAAS,CAACvE,aAAa,oMAACqI,GAAG,CAACC,MAAM,CAAC,CAAC;AAGnC,MAAMG,UAAU,IAAIC,OAAe,GACxCC,aAAa,CAAC,IAAM3I,aAAa,oMAACqI,GAAG,CAAC,IAAIO,gBAAgB,CAACF,OAAO,CAAC,CAAC,CAAC;AAGhE,MAAMG,OAAO,IAAIC,QAA0B,GAA2B9E,OAAO,CAAC+E,IAAI,CAACD,QAAQ,CAAC,EAAET,GAAG,CAAC;AAGlG,MAAMvB,MAAM,GAAalC,IAA4B,IAC1D+B,WAAW,CAAC/B,IAAI,EAAE;QAChBP,SAAS,GAAG2E,CAAC,GAAKnE,OAAO,CAACnG,MAAM,gMAACsI,IAAI,CAACgC,CAAC,CAAC,CAAC;QACzCtE,SAAS,GAAGT,CAAC,GAAKY,OAAO,CAACnG,MAAM,gMAACuI,KAAK,CAAChD,CAAC,CAAC;KAC1C,CAAC;AAGG,MAAMC,IAAI,IAAaU,IAA4B,GACxDqE,UAAU,CAACrE,IAAI,EAAE;QACfP,SAAS,EAAE6E,aAAa;QACxBxE,SAAS,EAAEyE;KACZ,CAAC;AAGG,MAAMC,IAAI,IAAOC,KAAQ,gNAC9B1J,WAAQ,AAARA,EAAS0J,KAAK,CAAC,IAAI,CAAA,CAAE5B,UAAU,IAAI4B,KAAK,CAAC,GACvC9F,gBAAgB,CAAEgF,KAAK,IAAKhE,SAAS,CAACvE,aAAa,oMAACoJ,IAAI,CAACvB,OAAO,CAACwB,KAAK,EAAEb,oBAAoB,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GACrGhE,SAAS,CAACvE,aAAa,oMAACoJ,IAAI,CAACC,KAAK,CAAC,CAAC;AAGnC,MAAMC,QAAQ,IAAOR,QAAoB,GAA8B9E,OAAO,CAAC+E,IAAI,CAACD,QAAQ,CAAC,EAAEM,IAAI,CAAC;AAGpG,MAAM7E,SAAS,IAAOrD,KAAqB,IAA6B;IAC7E,MAAMK,MAAM,GAAG,IAAIuB,sBAAsB,CAACtC,OAAO,sNAAC8D,UAAU,CAAQ;IACpE/C,MAAM,CAACE,qBAAqB,GAAGP,KAAK;IACpC,OAAOK,MAAM;AACf,CAAC;AAGM,MAAMoH,aAAa,GACxBG,QAAiC,IACL9E,OAAO,CAAC+E,IAAI,CAACD,QAAQ,CAAC,EAAEvE,SAAS,CAAC;AAGzD,MAAMgF,OAAO,GAAA,WAAA,GAAmChG,gBAAgB,EAAEiG,KAAK,GAAK3E,OAAO,CAAC2E,KAAK,CAACC,EAAE,EAAE,CAAC,CAAC;AAGhG,MAAMC,WAAW,IACtBlD,CAA0D,GAC/BjD,gBAAgB,EAAEiG,KAAK,GAAKhD,CAAC,CAACgD,KAAK,CAACC,EAAE,EAAE,CAAC,CAAC;AAGhE,MAAMzF,OAAO,GAAA,WAAA,GAAGnF,mNAAAA,AAAI,EASzB,CAAC,EACD,CAAC+F,IAAI,EAAE4B,CAAC,KAAI;IACV,MAAMjF,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACmJ,aAAa,CAAQ;IAChEpI,MAAM,CAACE,qBAAqB,GAAGmD,IAAI;IACnCrD,MAAM,CAACG,qBAAqB,GAAG8E,CAAC;IAChC,OAAOjF,MAAM;AACf,CAAC,CACF;AAGM,MAAMqI,OAAO,GAAA,WAAA,+MA2BhB/K,OAAAA,AAAI,EAAC,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,GAClBxC,OAAO,CAACY,IAAI,GAAGX,CAAC,IAAI;QAClB,MAAM4F,CAAC,GAAG,OAAOrD,CAAC,KAAK,UAAU,GAAIA,CAAS,CAACvC,CAAC,CAAC,GAAGuC,CAAC;QACrD,IAAIlD,QAAQ,CAACuG,CAAC,CAAC,EAAE;YACf,OAAOA,CAAC;QACV,CAAC,MAAM,gNAAIjK,iBAAAA,AAAa,EAACiK,CAAC,CAAC,EAAE;YAC3B,OAAO9D,KAAK,EAA+BJ,MAAM,IAAI;gBACnDkE,CAAC,CAACC,IAAI,EAAE7F,CAAC,GAAK0B,MAAM,CAACd,OAAO,CAACZ,CAAC,CAAC,CAAC,GAAG+E,CAAC,GAAKrD,MAAM,CAACyD,IAAI,CAAC,IAAIW,gBAAgB,CAACf,CAAC,CAAC,CAAC,CAAC,CAAC;YACjF,CAAC,CAAC;QACJ;QACA,OAAOnE,OAAO,CAACgF,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;AAGE,MAAMG,IAAI,IACfpF,IAA4B,IACuC;IACnE,MAAMrD,MAAM,GAAG,IAAIC,eAAe,CAAC,QAAQ,CAAQ;IACnDD,MAAM,CAACE,qBAAqB,GAAGmD,IAAI;IACnC,OAAOrD,MAAM;AACf,CAAC;AAGM,MAAM0I,OAAO,IAClBrF,IAAmD,GACdZ,OAAO,CAACY,IAAI,0MAAE9F,WAAQ,CAAC;AAGvD,MAAMoL,IAAI,IAAatF,IAA4B,GACxD+B,WAAW,CAAC/B,IAAI,EAAE;QAAEP,SAAS,EAAEQ,OAAO;QAAEH,SAAS,EAAE0E;IAAI,CAAE,CAAC;AAGrD,MAAMH,UAAU,GAAA,WAAA,+MAcnBpK,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BuF,OAGC,GAED/F,gBAAgB,CAACQ,IAAI,EAAE;QACrBP,SAAS,GAAGnD,KAAK,GAAK2D,OAAO,CAACsF,OAAO,CAAC9F,SAAS,CAACnD,KAAK,CAAC,CAAC;QACvDwD,SAAS,GAAGT,CAAC,GAAKY,OAAO,CAACsF,OAAO,CAACzF,SAAS,CAACT,CAAC,CAAC;KAC/C,CAAC,CAAC;AAGE,MAAMG,gBAAgB,GAAA,WAAA,GAczBvF,mNAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BuF,OAGC,KAC+C;IAChD,MAAM5I,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAAC4J,yBAAyB,CAAQ;IAC5E7I,MAAM,CAACE,qBAAqB,GAAGmD,IAAI;IACnCrD,MAAM,CAACG,qBAAqB,GAAGyI,OAAO,CAAC9F,SAAS;IAChD9C,MAAM,CAACa,qBAAqB,GAAG+H,OAAO,CAACzF,SAAS;IAChD,OAAOnD,MAAM;AACf,CAAC,CAAC;AAGK,MAAMoF,WAAW,GAAA,WAAA,+MAcpB9H,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BuF,OAGC,GAED/F,gBAAgB,CAACQ,IAAI,EAAE;QACrBP,SAAS,GAAGnD,KAAK,IAAI;YACnB,MAAMmJ,OAAO,GAAGrK,aAAa,oMAACqK,OAAO,CAACnJ,KAAK,CAAC;YAC5C,IAAImJ,OAAO,CAACnF,MAAM,GAAG,CAAC,EAAE;gBACtB,OAAOX,SAAS,CAACvE,aAAa,oMAACsK,aAAa,CAACpJ,KAAK,CAAC,CAAC;YACtD;YACA,MAAMqJ,QAAQ,GAAGvK,aAAa,oMAACuK,QAAQ,CAACrJ,KAAK,CAAC;YAC9C,IAAIqJ,QAAQ,CAACrF,MAAM,GAAG,CAAC,EAAE;gBACvB,OAAOiF,OAAO,CAAC9F,SAAS,CAAC9F,KAAK,gMAACiM,UAAU,CAACD,QAAQ,CAAC,CAAC;YACtD;YACA,OAAOhG,SAAS,CAACrD,KAA2B,CAAC;QAC/C,CAAC;QACDwD,SAAS,EAAEyF,OAAO,CAACzF,SAAAA;KACpB,CAAC,CAAC;AAGE,MAAM+F,iBAAiB,GAAA,WAAA,+MAG1B5L,OAAAA,AAAI,EACN,CAAC,EACD,CAAa+F,IAAiB,EAAE4B,CAA8C,GAC5ErC,OAAO,CAAC,MAAK;QACX,MAAMuG,GAAG,GAAGpM,GAAG,kMAACqM,YAAY,CAAC/F,IAAI,CAAC;QAClC,MAAMgG,GAAG,GAAGtM,GAAG,kMAACuM,QAAQ,CAAIH,GAAG,CAACxF,MAAM,CAAC;QACvC,IAAI4F,CAAC,GAAG,CAAC;QACT,OAAOnG,EAAE,CACPoG,SAAS,CAAC;YACRC,KAAK,EAAEA,CAAA,GAAMF,CAAC,GAAGJ,GAAG,CAACxF,MAAM;YAC3B+F,IAAI,EAAEA,CAAA,GAAMzE,CAAC,CAACkE,GAAG,CAACI,CAAC,CAAC,EAAEA,CAAC,CAAC;YACxBd,IAAI,GAAGH,CAAC,IAAI;gBACVe,GAAG,CAACE,CAAC,EAAE,CAAC,GAAGjB,CAAC;YACd;SACD,CAAC,EACFe,GAAe,CAChB;IACH,CAAC,CAAC,CACL;AAGM,MAAMM,wBAAwB,GAAA,WAAA,GAGjCrM,mNAAAA,AAAI,EACN,CAAC,EACD,CAAa+F,IAAiB,EAAE4B,CAA8C,GAC5ErC,OAAO,CAAC,MAAK;QACX,MAAMuG,GAAG,GAAGpM,GAAG,kMAACqM,YAAY,CAAC/F,IAAI,CAAC;QAClC,IAAIkG,CAAC,GAAG,CAAC;QACT,OAAOC,SAAS,CAAC;YACfC,KAAK,EAAEA,CAAA,GAAMF,CAAC,GAAGJ,GAAG,CAACxF,MAAM;YAC3B+F,IAAI,EAAEA,CAAA,GAAMzE,CAAC,CAACkE,GAAG,CAACI,CAAC,CAAC,EAAEA,CAAC,CAAC;YACxBd,IAAI,EAAEA,CAAA,KAAK;gBACTc,CAAC,EAAE;YACL;SACD,CAAC;IACJ,CAAC,CAAC,CACL;AAGM,MAAMK,GAAG,GAAA,WAAA,GAAGtM,mNAAAA,AAAI,GAiBpBuM,IAAI,GAAK,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,IAAI9H,QAAQ,CAAC8H,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3D,CACExG,IAA4C,EAC5CuF,OAGC,GAED7G,QAAQ,CAACsB,IAAI,CAAC,GACVZ,OAAO,CAACY,IAAI,EAAGiF,CAAC,IAAgDA,CAAC,GAAGM,OAAO,CAACkB,MAAM,EAAE,GAAGlB,OAAO,CAACmB,OAAO,EAAG,CAAC,GAC1G1G,IAAI,GACJuF,OAAO,CAACkB,MAAM,EAAE,GAChBlB,OAAO,CAACmB,OAAO,EAAE,CACxB;AAGM,MAAMC,SAAS,GAAA,WAAA,GAAyBvH,OAAO,CAACuF,OAAO,GAAGA,OAAO,GAAKiC,aAAa,CAACjC,OAAO,CAAC,CAAC;AAG7F,MAAMiC,aAAa,IAAIjC,OAAwB,GACpDhF,SAAS,CAACvE,aAAa,oMAACuL,SAAS,CAAChC,OAAO,CAAC,CAAC;AAGtC,MAAMkC,aAAa,IAAa7G,IAA4B,IAA4B;IAC7F,MAAMrD,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACkL,uBAAuB,CAAQ;IAC1EnK,MAAM,CAACE,qBAAqB,GAAG5B,iBAAiB,gMAAC8L,MAAM,CAAClL,aAAa,2MAACmL,YAAY,CAAC;IACnFrK,MAAM,CAACG,qBAAqB,GAAG,IAAMkD,IAAI;IACzC,OAAOrD,MAAM;AACf,CAAC;AAGM,MAAMsK,iBAAiB,IAC5BrF,CAAoH,GAEpHzB,MAAM,CAACyB,CAAC,EAAE;QACR,MAAMjF,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACkL,uBAAuB,CAAQ;QAC1EnK,MAAM,CAACE,qBAAqB,GAAG5B,iBAAiB,gMAAC8L,MAAM,CAAClL,aAAa,2MAACmL,YAAY,CAAC;QACnFrK,MAAM,CAACG,qBAAqB,IAAIoK,QAAmC,GACjErL,aAAa,2MAAC8G,YAAY,CAACuE,QAAQ,CAAC,4MAChCzN,eAAAA,AAAY,EAAC,IAAM,IAAI,CAACoD,qBAAqB,CAACgK,aAAa,CAAC,CAAC,GAC7DpN,wNAAAA,AAAY,EAAC,IAAM,IAAI,CAACoD,qBAAqB,CAACsK,eAAe,CAAC,CAAC;QACrE,OAAOxK,MAAM;IACf,CAAC,CAAC;AAGG,MAAMyK,YAAY,GAAA,WAAA,+MAGrBnN,OAAAA,AAAI,EACN,CAAC,EACD,CAAU+F,IAA4B,EAAE3E,QAAiC,GACvE6D,mBAAmB,EAAEC,OAAO,GAC1BC,OAAO,CACLE,IAAI,CAACH,OAAO,CAACa,IAAI,CAAC,CAAC,GAClBV,IAAI,GAAK+H,YAAY,CAAChM,QAAQ,EAAEiE,IAAI,CAAC,CACvC,CACF,CACJ;AAGM,MAAMgI,GAAG,GAAA,WAAA,+MAGZrN,OAAAA,AAAI,EACN,CAAC,EACD,CAAa+F,IAA4B,EAAE4B,CAAc,GACvDxC,OAAO,CAACY,IAAI,GAAGX,CAAC,GAAK8E,IAAI,CAAC,IAAMvC,CAAC,CAACvC,CAAC,CAAC,CAAC,CAAC,CACzC;AAGM,MAAMkI,OAAO,GAAA,WAAA,+MAQhBtN,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BuF,OAA+E,GAE/ExD,WAAW,CAAC/B,IAAI,EAAE;QAChBP,SAAS,GAAG2E,CAAC,GAAKM,QAAQ,CAAC,IAAMa,OAAO,CAAC9F,SAAS,CAAC2E,CAAC,CAAC,CAAC;QACtDtE,SAAS,GAAGT,CAAC,GAAK8E,IAAI,CAAC,IAAMoB,OAAO,CAACzF,SAAS,CAACT,CAAC,CAAC;KAClD,CAAC,CAAC;AAGE,MAAMmI,QAAQ,GAAA,WAAA,+MAGjBvN,OAAAA,AAAI,EACN,CAAC,EACD,CAAc+F,IAA4B,EAAE4B,CAAe,GACzDpC,gBAAgB,CAACQ,IAAI,EAAE;QACrBP,SAAS,GAAGnD,KAAK,IAAI;YACnB,MAAM4F,MAAM,GAAG9G,aAAa,oMAAC+G,cAAc,CAAC7F,KAAK,CAAC;YAClD,OAAQ4F,MAAM,CAAC3F,IAAI;gBACjB,KAAK,MAAM;oBAAE;wBACX,OAAOmI,QAAQ,CAAC,IAAM9C,CAAC,CAACM,MAAM,CAACE,IAAI,CAAC,CAAC;oBACvC;gBACA,KAAK,OAAO;oBAAE;wBACZ,OAAOzC,SAAS,CAACuC,MAAM,CAACG,KAAK,CAAC;oBAChC;YACF;QACF,CAAC;QACDvC,SAAS,EAAEG;KACZ,CAAC,CACL;AAGM,MAAMwH,OAAO,GAAA,WAAA,GAQhBxN,mNAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5B0H,OAA+D,GAE/DC,MAAM,CAAC3H,IAAI,GAAGV,IAAI,GAAKsI,aAAa,CAACtI,IAAI,CAAC,GAAG4B,KAAK,GAAGwG,OAAO,CAACpI,IAAI,CAACzC,qBAAqB,CAAC,CAAC,CAAC;AAGrF,MAAM8K,MAAM,GAAA,WAAA,+MAQf1N,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5B0H,OAA+D,GAE/DxI,mBAAmB,CAAEC,OAAO,IAC1BK,gBAAgB,CAACL,OAAO,CAACa,IAAI,CAAC,EAAE;YAC9BP,SAAS,GAAGoI,MAAM,IAAI;gBACpB,MAAMC,MAAM,GAAGxD,aAAa,CAACuD,MAAM,CAAC;gBACpC,OAAOrI,gBAAgB,CAACkI,OAAO,CAACI,MAAM,CAAC,EAAE;oBACvCrI,SAAS,GAAGsI,MAAM,GAAKzD,aAAa,CAAClJ,aAAa,oMAAC4M,UAAU,CAACH,MAAM,EAAEE,MAAM,CAAC,CAAC;oBAC9EjI,SAAS,EAAEA,CAAA,GAAMgI;iBAClB,CAAC;YACJ,CAAC;YACDhI,SAAS,GAAGmI,OAAO,IAAI;gBACrB,MAAMH,MAAM,GAAGvD,WAAW,CAAC0D,OAAO,CAAC;gBACnC,OAAOC,QAAQ,CAACR,OAAO,CAACI,MAAM,CAAC,EAAEA,MAAM,CAAC;YAC1C;SACD,CAAC,CACH,CAAC;AAGG,MAAM9G,WAAW,GAAA,WAAA,+MAQpB/G,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5B0H,OAAwF,GAExFC,MAAM,CACJ3H,IAAI,EACJmI,SAAS,CAAC;QACR1I,SAAS,GAAGnD,KAAK,GACflB,aAAa,oMAACgN,iBAAiB,CAAC9L,KAAK,CAAC,GAClC4D,MAAM,CAACwH,OAAO,CAACtM,aAAa,oMAACiN,YAAY,CAAC/L,KAAK,CAAC,CAAC,CAAC,GAClD4E,KAAK;QACXpB,SAAS,EAAEA,CAAA,GAAMoB;KAClB,CAAC,CACH,CAAC;AAGG,MAAMoH,MAAM,GAAA,WAAA,+MAQfrO,OAAAA,AAAI,EACN,CAAC,EACD,CACE+F,IAA4B,EAC5BrC,IAAwC,GACF4K,aAAa,CAACvI,IAAI,EAAErC,IAAI,EAAEsC,OAAO,CAAC,CAC3E;AAGM,MAAMuI,KAAK,IAAaxI,IAA4B,GAAiCyI,SAAS,CAACzI,IAAI,0MAAE9F,WAAQ,CAAC;AAG9G,MAAMuO,SAAS,GAAA,WAAA,OAGlBxO,+MAAAA,AAAI,EACN,CAAC,EACD,CAAU+F,IAA4B,EAAE4B,CAAwB,GAC9DG,WAAW,CAAC/B,IAAI,EAAE;QAChBP,SAAS,GAAG2E,CAAC,GAAKX,GAAG,CAAC7B,CAAC,CAACwC,CAAC,CAAC,CAAC;QAC3BtE,SAAS,EAAEG;KACZ,CAAC,CACL;AAGM,MAAMyI,YAAY,GAGkBhP,GAAG,kMAACgP,YAAY;AAEpD,MAAM9F,YAAY,GAAA,WAAA,GAA6CjE,gBAAgB,CAAC,CAACsC,CAAC,EAAEyB,MAAM,GAC/FzC,OAAO,CAACyC,MAAM,CAACE,YAAY,CAAC,CAC7B;AAGM,MAAM3C,OAAO,IAAOxB,KAAQ,IAAsB;IACvD,MAAM9B,MAAM,GAAG,IAAI6B,sBAAsB,CAAC5C,OAAO,sNAACiE,UAAU,CAAQ;IACpElD,MAAM,CAACE,qBAAqB,GAAG4B,KAAK;IACpC,OAAO9B,MAAM;AACf,CAAC;AAGM,MAAM4C,OAAO,IAAa5C,MAAuC,GACtEyC,OAAO,CAAC+E,IAAI,CAACxH,MAAM,CAAC,0MAAEzC,WAAQ,CAAC;AAG1B,MAAMiK,IAAI,IAAOwE,KAAiB,IAAsB;IAC7D,MAAMhM,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACgN,OAAO,CAAQ;IAC1DjM,MAAM,CAACE,qBAAqB,GAAG8L,KAAK;IACpC,OAAOhM,MAAM;AACf,CAAC;AAGM,MAAMkM,GAAG,GAAA,WAAA,+MAAG5O,OAAAA,AAAI,EAsDpBuM,IAAI,IAAKA,IAAI,CAAClG,MAAM,KAAK,CAAC,IAAIkG,IAAI,CAAClG,MAAM,KAAK,CAAC,IAAI,CAAA,8MAAEvF,WAAQ,AAARA,EAASyL,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,YAAY,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAC,EACnG,CAAaxG,IAA4B,EAAE4B,CAAI,GAC7CxC,OAAO,CAACY,IAAI,GAAGX,CAAC,IAAI;QAClB,MAAM4F,CAAC,GAAG,OAAOrD,CAAC,KAAK,UAAU,GAAIA,CAAS,CAACvC,CAAC,CAAC,GAAGuC,CAAC;QACrD,IAAIlD,QAAQ,CAACuG,CAAC,CAAC,EAAE;YACf,OAAOlF,EAAE,CAACkF,CAAC,EAAE5F,CAAC,CAAC;QACjB,CAAC,MAAM,iNAAIrE,gBAAAA,AAAa,EAACiK,CAAC,CAAC,EAAE;YAC3B,OAAO9D,KAAK,EAA+BJ,MAAM,IAAI;gBACnDkE,CAAC,CAACC,IAAI,EAAEjE,CAAC,GAAKF,MAAM,CAACd,OAAO,CAACZ,CAAC,CAAC,CAAC,GAAG+E,CAAC,GAAKrD,MAAM,CAACyD,IAAI,CAAC,IAAIW,gBAAgB,CAACf,CAAC,CAAC,CAAC,CAAC,CAAC;YACjF,CAAC,CAAC;QACJ;QACA,OAAOnE,OAAO,CAACZ,CAAC,CAAC;IACnB,CAAC,CAAC,CACL;AAGM,MAAMyJ,UAAU,IACrBlH,CAAoH,GAEpHjD,gBAAgB,EAAWiG,KAAK,IAAI;QAClC,MAAMmE,aAAa,GAAGnE,KAAK,CAACoE,WAAW,CAACC,wBAAwB,CAAC;QACjE,MAAMC,KAAK,+MAAG/O,OAAAA,AAAI,EAAC4O,aAAa,EAAEnO,MAAM,gMAAC4H,SAAS,CAAC,IAAMoC,KAAK,CAACsE,KAAK,EAAE,CAAC,CAAC;QACxE,OAAOtH,CAAC,CAACuH,eAAe,CAACF,wBAAwB,EAAErO,MAAM,gMAACwO,IAAI,CAACF,KAAK,CAAC,CAAC,CAAC;IACzE,CAAC,CAAC;AAGG,MAAMX,aAAa,GAAA,WAAA,8MAUtBtO,QAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BrC,IAAwC,EACxCmC,SAA8C,GAE9CN,gBAAgB,CAACQ,IAAI,EAAE;QACrBP,SAAS,GAAGnD,KAAK,IAAI;YACnB,MAAMmJ,OAAO,GAAGrK,aAAa,oMAACqK,OAAO,CAACnJ,KAAK,CAAC;YAC5C,IAAImJ,OAAO,CAACnF,MAAM,GAAG,CAAC,EAAE;gBACtB,OAAOX,SAAS,CAAC/E,MAAM,gMAACyO,UAAU,CAACjO,aAAa,oMAACkO,2BAA2B,CAAChN,KAAK,CAAC,CAAC,CAAC;YACvF;YACA,OAAOqB,IAAI,EAAE;QACf,CAAC;QACDmC;KACD,CAAC,CAAC;AAGE,MAAMqH,eAAe,IAC1BnH,IAA4B,IACF;IAC1B,MAAMrD,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACkL,uBAAuB,CAAQ;IAC1EnK,MAAM,CAACE,qBAAqB,GAAG5B,iBAAiB,gMAACsO,OAAO,CAAC1N,aAAa,2MAACmL,YAAY,CAAC;IACpFrK,MAAM,CAACG,qBAAqB,GAAG,IAAMkD,IAAI;IACzC,OAAOrD,MAAM;AACf,CAAC;AAGM,MAAMuC,mBAAmB,IAC9B0C,CAAoH,GAEpHzB,MAAM,CAACyB,CAAC,EAAE;QACR,MAAMjF,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACkL,uBAAuB,CAAQ;QAC1EnK,MAAM,CAACE,qBAAqB,GAAG5B,iBAAiB,gMAACsO,OAAO,CAAC1N,aAAa,2MAACmL,YAAY,CAAC;QACpFrK,MAAM,CAACG,qBAAqB,IAAIoK,QAAmC,GACjErL,aAAa,2MAAC8G,YAAY,CAACuE,QAAQ,CAAC,4MAChCzN,eAAAA,AAAY,EAAC,IAAM,IAAI,CAACoD,qBAAqB,CAACgK,aAAa,CAAC,CAAC,GAC7DpN,wNAAY,AAAZA,EAAa,IAAM,IAAI,CAACoD,qBAAqB,CAACsK,eAAe,CAAC,CAAC;QACrE,OAAOxK,MAAM;IACf,CAAC,CAAC;AAEJ,MAAMuE,KAAK,GAAA,WAAA,GAAwBjB,OAAO,CAAC,KAAK,CAAC,CAAC;;AAO3C,MAAMwJ,kBAAkB,GAAIvM,KAA0C,IAAyB;IACpG,MAAMP,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACkL,uBAAuB,CAAQ;IAC1EnK,MAAM,CAACE,qBAAqB,GAAGK,KAAK;IACpCP,MAAM,CAACG,qBAAqB,GAAG,KAAK,CAAC;IACrC,OAAOH,MAAM;AACf,CAAC;AAGM,MAAM+M,UAAU,GAAA,WAAA,+MAUnBzP,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA8B,EAC9B2J,SAAuC,GAEvCvK,OAAO,CAACuK,SAAS,GAAG1E,CAAC,IAAI;QACvB,IAAIA,CAAC,EAAE;YACL,mNAAO9K,OAAI,AAAJA,EAAK6F,IAAI,EAAEsH,GAAG,CAAC1M,MAAM,gMAACwO,IAAI,CAAC,CAAC;QACrC;QACA,OAAOnJ,OAAO,CAACrF,MAAM,gMAACgG,IAAI,EAAE,CAAC;IAC/B,CAAC,CAAC,CAAC;AAGE,MAAMuF,SAAS,IACpBZ,OAIC,IAC4B;IAC7B,MAAM5I,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACgO,QAAQ,CAAQ;IAC3DjN,MAAM,CAACE,qBAAqB,GAAG0I,OAAO,CAACa,KAAK;IAC5CzJ,MAAM,CAACG,qBAAqB,GAAGyI,OAAO,CAACc,IAAI;IAC3C1J,MAAM,CAACa,qBAAqB,GAAG+H,OAAO,CAACH,IAAI;IAC3C,OAAOzI,MAAM;AACf,CAAC;AAGM,MAAMkN,eAAe,GAAA,WAAA,+MAAG5P,OAAAA,AAAI,EAGjC,CAAC,EAAE,CAAC+F,IAAI,EAAE8J,WAAW,GAAKX,eAAe,CAACnJ,IAAI,EAAE+J,kBAAkB,EAAED,WAAW,CAAC,CAAC;AAG5E,MAAME,mBAAmB,GAAA,WAAA,+MAAG/P,OAAAA,AAAI,EAGrC,CAAC,EAAE,CAAC+F,IAAI,EAAEiK,eAAe,GAAKd,eAAe,CAACnJ,IAAI,EAAEkK,sBAAsB,EAAED,eAAe,CAAC,CAAC;AAGxF,MAAME,gBAAgB,GAAA,WAAA,OAAGlQ,+MAAAA,AAAI,EAGlC,CAAC,EAAE,CAAC+F,IAAI,EAAEoK,MAAM,KAAI;IACpB,MAAMzN,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAACkL,uBAAuB,CAAQ;IAC1EnK,MAAM,CAACE,qBAAqB,GAAGuN,MAAM;IACrCzN,MAAM,CAACG,qBAAqB,GAAG,IAAMkD,IAAI;IACzC,OAAOrD,MAAM;AACf,CAAC,CAAC;AAGK,MAAM0N,iBAAiB,GAAA,WAAA,+MAAGpQ,OAAAA,AAAI,EAGnC,CAAC,EAAE,CAAC0C,MAAM,EAAE2N,OAAO,GACnBnB,eAAe,CACbxM,MAAM,EACN4N,oBAAoB,EACpBD,OAAO,CACR,CAAC;AAGG,MAAME,gBAAgB,GAAA,WAAA,+MAAGvQ,OAAAA,AAAI,EAGlC,CAAC,EAAE,CAAC0C,MAAM,EAAE2N,OAAO,GACnBnB,eAAe,CACbxM,MAAM,EACN8N,0BAA0B,EAC1BH,OAAO,CACR,CAAC;AAGG,MAAMI,QAAQ,IAAInF,OAExB,IAAyB;IACxB,MAAM5I,MAAM,GAAG,IAAIC,eAAe,CAAChB,OAAO,sNAAC+O,QAAQ,CAAQ;IAC3D,OAAO,OAAOpF,OAAO,EAAEqF,QAAQ,KAAK,WAAW,GAC7CC,sBAAsB,CAAClO,MAAM,EAAE4I,OAAO,CAACqF,QAAQ,CAAC,GAChDjO,MAAM;AACV,CAAC;AAGM,MAAMmO,GAAG,GAAA,WAAA,+MAAG7Q,OAAAA,AAAI,EAUrB,CAAC,EAAE,CACH+F,IAA4B,EAC5BrC,IAA+B,GACYyB,OAAO,CAACY,IAAI,EAAGX,CAAC,IAAKiI,GAAG,CAAC3J,IAAI,GAAGsH,CAAC,GAAK;gBAAC5F,CAAC;gBAAE4F,CAAC;aAAC,CAAC,CAAC,CAAC;AAGrF,MAAM8F,UAAU,GAAA,WAAA,+MAUnB9Q,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BrC,IAA+B,GACeyB,OAAO,CAACY,IAAI,GAAGX,CAAC,GAAKiI,GAAG,CAAC3J,IAAI,GAAGsH,CAAC,GAAK,CAAC;mBAAG5F,CAAC;gBAAE4F,CAAC;aAAC,CAAC,CAAC,CAAC;AAG3F,MAAM+F,OAAO,GAAA,WAAA,+MAQhB/Q,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BrC,IAA+B,GACMyB,OAAO,CAACY,IAAI,GAAGX,CAAC,GAAKU,EAAE,CAACpC,IAAI,EAAE0B,CAAC,CAAC,CAAC,CAAC;AAGlE,MAAM6I,QAAQ,GAAA,WAAA,+MAQjBjO,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAA4B,EAC5BrC,IAA+B,GACOyB,OAAO,CAACY,IAAI,EAAE,IAAMrC,IAAI,CAAC,CAAC;AAG3D,MAAMsN,OAAO,GAAA,WAAA,GAUhBhR,mNAAI,AAAJA,EAAK,CAAC,EAAE,CACV+F,IAA4B,EAC5BrC,IAA+B,EAC/BiE,CAAqB,GACgBxC,OAAO,CAACY,IAAI,GAAGX,CAAC,GAAKiI,GAAG,CAAC3J,IAAI,GAAGsH,CAAC,GAAKrD,CAAC,CAACvC,CAAC,EAAE4F,CAAC,CAAC,CAAC,CAAC,CAAC;AAGhF,MAAMiG,KAAK,GAAA,WAAA,GAAyB/J,KAAK,CAAQ,MAAK;IAC3D,MAAMgK,QAAQ,GAAGC,WAAW,CAAC,MAAK;IAChC,EAAA;IAAA,CACD,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;IACf,OAAOjH,IAAI,CAAC,IAAMkH,aAAa,CAACF,QAAQ,CAAC,CAAC;AAC5C,CAAC,CAAC;AAOK,MAAMG,cAAc,IAAUtL,IAAuB,GAC1DZ,OAAO,CAACuF,OAAO,GAAGA,OAAO,+MAAKxK,OAAAA,AAAI,EAAC6F,IAAI,EAAEuL,gBAAgB,CAAC5G,OAAO,CAAC,CAAC,CAAC;AAG/D,MAAM4G,gBAAgB,GAAA,WAAA,+MAAGtR,OAAI,AAAJA,EAG9B,CAAC,EAAE,CAAC+F,IAAI,EAAE2E,OAAO,GAAKvF,OAAO,CAACY,IAAI,CAACwL,eAAe,CAAC7G,OAAO,CAAC,EAAE,IAAM3E,IAAI,CAACyL,KAAK,CAAC,CAAC;AAO1E,MAAMC,WAAW,GAAsB;IAC5CnP,IAAI,EAAE,KAAK;IACXoP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,KAAK;IACZC,OAAO,EAAEC,MAAM,CAACC,gBAAgB;IAChC5R,IAAIA,CAAA;QACF,mNAAOU,gBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAMkO,aAAa,GAAsB;IAC9CzP,IAAI,EAAE,OAAO;IACboP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,OAAO;IACdC,OAAO,EAAE,KAAK;IACd1R,IAAIA,CAAA;QACF,mNAAOU,gBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAMmO,aAAa,GAAsB;IAC9C1P,IAAI,EAAE,OAAO;IACboP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,OAAO;IACdC,OAAO,EAAE,KAAK;IACd1R,IAAIA,CAAA;QACF,mNAAOU,gBAAa,AAAbA,EAAc,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAMoO,eAAe,GAAsB;IAChD3P,IAAI,EAAE,SAAS;IACfoP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,MAAM;IACbC,OAAO,EAAE,KAAK;IACd1R,IAAIA,CAAA;QACF,mNAAOU,gBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAMqO,YAAY,GAAsB;IAC7C5P,IAAI,EAAE,MAAM;IACZoP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,MAAM;IACbC,OAAO,EAAE,KAAK;IACd1R,IAAIA,CAAA;QACF,WAAOU,wNAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAMsO,aAAa,GAAsB;IAC9C7P,IAAI,EAAE,OAAO;IACboP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,OAAO;IACdC,OAAO,EAAE,KAAK;IACd1R,IAAIA,CAAA;QACF,OAAOU,4NAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAMuO,aAAa,GAAsB;IAC9C9P,IAAI,EAAE,OAAO;IACboP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,OAAO;IACdC,OAAO,EAAE,CAAC;IACV1R,IAAIA,CAAA;QACF,kNAAOU,iBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAMwO,YAAY,GAAsB;IAC7C/P,IAAI,EAAE,MAAM;IACZoP,MAAM,EAAE,CAAC;IACTC,KAAK,EAAE,KAAK;IACZC,OAAO,EAAEC,MAAM,CAACS,gBAAgB;IAChCpS,IAAIA,CAAA;QACF,mNAAOU,gBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;CACD;AAGM,MAAM0O,YAAY,GAAqC;IAC5Dd,WAAW;IACXW,aAAa;IACbD,aAAa;IACbD,YAAY;IACZD,eAAe;IACfD,aAAa;IACbD,aAAa;IACbM,YAAY;CACb;AAED,gFAAA;AACA,WAAA;AACA,gFAAA;AAEA,cAAA,GACA,MAAMG,iBAAiB,GAAG,iBAAiB;AAGpC,MAAMC,cAAc,GAAA,WAAA,GAA4BzQ,MAAM,CAACC,GAAG,CAC/DuQ,iBAAiB,CACS;AAE5B,MAAME,gBAAgB,GAAG;IACvB,kBAAA,GACAC,EAAE,GAAG3L,CAAM,GAAKA;CACjB;AAGM,MAAM4L,WAAW,IAAO7M,IAA0B,GACvDrB,gBAAgB,EAAEgF,KAAK,GAAKY,WAAW,CAACZ,KAAK,CAACqF,WAAW,CAAChJ,IAAI,CAAC,CAAC,CAAC;AAG5D,MAAM8M,iBAAiB,GAAA,WAAA,+MAAG7S,OAAAA,AAAI,EAGnC,CAAC,EAAE,CAAC+F,IAAI,EAAEvB,KAAK,GAAKsO,cAAc,CAAC/M,IAAI,EAAGgN,CAAC,IAAK;YAACA,CAAC;YAAEvO,KAAK;SAAU,CAAC,CAAC;AAGhE,MAAMwO,oBAAoB,GAAA,WAAA,+MAAGhT,OAAAA,AAAI,EAGtC,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,GAAKmL,cAAc,CAAC/M,IAAI,GAAGgN,CAAC,GAAK;YAACA,CAAC;YAAEpL,CAAC,CAACoL,CAAC,CAAC;SAAU,CAAC,CAAC;AAG3D,MAAME,wBAAwB,GAAA,WAAA,GAAGjT,mNAAAA,AAAI,EAQ1C,CAAC,EAAE,CAAC+F,IAAI,EAAEuC,EAAE,GAAKwK,cAAc,CAAC/M,IAAI,GAAGgN,CAAC,GAAK;YAACA,CAAC;YAAEpS,MAAM,gMAAC4H,SAAS,CAACD,EAAE,CAACyK,CAAC,CAAC,EAAE,IAAMA,CAAC,CAAC;SAAU,CAAC,CAAC;AAGxF,MAAMG,eAAe,GAAA,WAAA,+MAAGlT,OAAAA,AAAI,EAGjC,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,GAAKxC,OAAO,CAACyN,WAAW,CAAC7M,IAAI,CAAC,EAAE4B,CAAC,CAAC,CAAC;AAGzC,MAAMwL,WAAW,GAAA,WAAA,GAAGnT,mNAAAA,AAAI,EAG7B,CAAC,EAAE,CAAC+F,IAAI,EAAEvB,KAAK,GAAKsO,cAAc,CAAC/M,IAAI,EAAE,IAAM;YAAC,KAAK,CAAC;YAAEvB,KAAK;SAAU,CAAC,CAAC;AAGpE,MAAM4O,cAAc,IAAOrN,IAA0B,GAC1DrB,gBAAgB,EAAEiG,KAAK,IAAI;QACzBA,KAAK,CAAC0I,oBAAoB,CAACtN,IAAI,CAAC;QAChC,OAAOkB,KAAK;IACd,CAAC,CAAC;AAGG,MAAMqM,aAAa,IAAOvN,IAA0B,GAA0BoN,WAAW,CAACpN,IAAI,EAAEA,IAAI,CAACwN,OAAO,CAAC;AAG7G,MAAMT,cAAc,GAAA,WAAA,+MAAG9S,OAAAA,AAAI,EAGhC,CAAC,EAAE,CACH+F,IAA0B,EAC1B4B,CAA4B,GAE5BjD,gBAAgB,CAAEiG,KAAK,IAAI;QACzB,MAAM,CAACK,CAAC,EAAE5F,CAAC,CAAC,GAAGuC,CAAC,CAACgD,KAAK,CAACoE,WAAW,CAAChJ,IAAI,CAAM,CAAC;QAC9C4E,KAAK,CAAC6I,WAAW,CAACzN,IAAI,EAAEX,CAAC,CAAC;QAC1B,OAAOY,OAAO,CAACgF,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;AAGE,MAAMyI,kBAAkB,GAAGA,CAChC1N,IAA0B,EAC1B2N,GAAM,EACN/L,CAA2C,GACtBmL,cAAc,CAAC/M,IAAI,GAAGgN,CAAC,GAAKpS,MAAM,gMAAC4H,SAAS,CAACZ,CAAC,CAACoL,CAAC,CAAC,EAAE,IAAM;gBAACW,GAAG;gBAAEX,CAAC;aAAU,CAAC,CAAC;AAG5F,MAAMY,cAAc,GAAA,WAAA,+MAAG3T,OAAAA,AAAI,EAGhC,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,GAAKmL,cAAc,CAAC/M,IAAI,GAAGgN,CAAC,GAAK;YAAC,KAAK,CAAC;YAAEpL,CAAC,CAACoL,CAAC,CAAC;SAAU,CAAC,CAAC;AAGhE,MAAMa,kBAAkB,GAAA,WAAA,+MAAG5T,OAAAA,AAAI,EAGpC,CAAC,EAAE,CAAC+F,IAAI,EAAEuC,EAAE,GAAKwK,cAAc,CAAC/M,IAAI,EAAGgN,CAAC,IAAK;YAAC,KAAK,CAAC;YAAEpS,MAAM,gMAAC4H,SAAS,CAACD,EAAE,CAACyK,CAAC,CAAC,EAAE,IAAMA,CAAC,CAAC;SAAU,CAAC,CAAC;AAG7F,MAAMc,oBAAoB,GAAA,WAAA,GAAG7T,mNAAAA,AAAI,EAGtC,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,GACXmL,cAAc,CAAC/M,IAAI,GAAGgN,CAAC,IAAI;QACzB,MAAMlF,MAAM,GAAGlG,CAAC,CAACoL,CAAC,CAAC;QACnB,OAAO;YAAClF,MAAM;YAAEA,MAAM;SAAU;IAClC,CAAC,CAAC,CAAC;AAGE,MAAMiG,wBAAwB,GAAA,WAAA,GAAG9T,mNAAAA,AAAI,EAG1C,CAAC,EAAE,CAAC+F,IAAI,EAAEuC,EAAE,GACZwK,cAAc,CAAC/M,IAAI,GAAGgN,CAAC,IAAI;QACzB,MAAMlF,MAAM,GAAGlN,MAAM,gMAAC4H,SAAS,CAACD,EAAE,CAACyK,CAAC,CAAC,EAAE,IAAMA,CAAC,CAAC;QAC/C,OAAO;YAAClF,MAAM;YAAEA,MAAM;SAAU;IAClC,CAAC,CAAC,CAAC;AAEL,WAAA;AACA,cAAA,GACA,MAAMkG,wBAAwB,GAAG,wBAAwB;AAGlD,MAAMC,qBAAqB,GAAA,WAAA,GAA0ChS,MAAM,CAACC,GAAG,CACpF8R,wBAAwB,CACgB;AAE1C,MAAME,uBAAuB,GAAG;IAC9B,kBAAA,GACAtB,EAAE,GAAG3L,CAAU,GAAKA,CAAC;IACrB,kBAAA,GACAkN,EAAE,GAAGlN,CAAQ,GAAKA;CACnB;AAGK,MAAOmN,mBAAmB;IAGnBC,MAAA,CAAA;IAGA/K,MAAA,CAAA;IALF,CAAC2K,qBAAqB,CAAA,GAAIC,uBAAuB,CAAA;IAC1D5Q,YACW+Q,MAEyB,EACzB/K,MAAgB,CAAA;QAHhB,IAAA,CAAA+K,MAAM,GAANA,MAAM;QAGN,IAAA,CAAA/K,MAAM,GAANA,MAAM;IAEjB;IACA,CAACjJ,IAAI,gMAACqD,MAAM,CAAA,GAAC;QACX,OAAOrD,IAAI,gMAACuD,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC0F,MAAM,GAAGjJ,IAAI,gMAACkE,IAAI,CAAC,IAAI,CAAC+E,MAAM,CAAC,GAAGjJ,IAAI,gMAACwD,MAAM,CAAC,IAAI,CAAC,CAAC;IACpF;IACA,CAAC9D,KAAK,gMAAC2D,MAAM,CAAA,CAAEC,IAAa,EAAA;QAC1B,OAAO,IAAI,CAAC2F,MAAM,GAChBgL,iBAAiB,CAAC3Q,IAAI,CAAC,IAAI5D,KAAK,gMAACqE,MAAM,CAAC,IAAI,CAACkF,MAAM,EAAG3F,IAAsC,CAAC2F,MAAM,CAAC,GACpG,IAAI,KAAK3F,IAAI;IACjB;IACA4Q,UAAUA,CAAC,GAAGC,GAAmB,EAAA;QAC/B,OAAO,IAAIJ,mBAAmB,CAAC,IAAI,CAACC,MAAM,EAAE1U,KAAK,gMAACoM,YAAY,CAACyI,GAAG,CAAC,CAAC;IACtE;IACArU,IAAIA,CAAA,EAAA;QACF,mNAAOU,gBAAAA,AAAa,EAAC,IAAI,EAAEiD,SAAS,CAAC;IACvC;;AAIK,MAAMwQ,iBAAiB,IAAIlS,CAAU,OAC1CtB,uNAAAA,AAAW,EAACsB,CAAC,EAAE6R,qBAAqB,CAAC;AAKhC,MAAMQ,eAAe,GAAA,WAAA,+MAAGxU,OAAAA,AAAI,EAYjC,CAAC,EAAE,CACH+E,GAA0C,EAC1CgB,IAA0B,EAC1BvB,KAAQ,GAER,IAAI2P,mBAAmB,EACpBM,QAAQ,GACPvF,eAAe,CACbnK,GAAG,CAACqP,MAAM,CAACK,QAAQ,CAAC,EACpB1O,IAAI,EACJvB,KAAK,CACN,EACH9E,KAAK,gMAACgV,IAAI,CAAC,SAAS,EAAE3P,GAAG,EAAEgB,IAAI,EAAEvB,KAAK,CAAC,CACxC,CAAC;AAGG,MAAMmQ,mBAAmB,GAAGA,CACjC5O,IAAkC,EAClC6O,GAAyB,EACzBpQ,KAAQ,GACyBtD,gBAAgB,2MAAC2T,MAAM,CAAC9O,IAAI,EAAE+O,cAAc,CAACF,GAAG,EAAEpQ,KAAK,CAAC,CAAC;AAE5F,MAAMsQ,cAAc,GAAGA,CACrBF,GAAyB,EACzBpQ,KAAQ,GAAA,CACgE;QACxEuQ,SAAS,EAAEA,CAAA,GAAM7T,gBAAgB,2MAAC8T,KAAK;QACvCC,OAAO,EAAEA,CAAC9M,IAAI,EAAEC,KAAK,GAAKlH,gBAAgB,2MAACgU,GAAG,CAAC/M,IAAI,EAAEC,KAAK,CAAC;QAC3D+M,OAAO,EAAEA,CAAChN,IAAI,EAAEC,KAAK,GAAKlH,gBAAgB,2MAACkU,GAAG,CAACjN,IAAI,EAAEC,KAAK,CAAC;QAC3DiN,UAAU,EAAEA,CAACC,UAAU,EAAEC,cAAc,GACrCrU,gBAAgB,2MAACsU,MAAM,CACrBhB,eAAe,CAACc,UAAU,EAAEV,GAAG,EAAEpQ,KAAK,CAAC,EACvC+Q,cAAqB;KAE1B,CAAC;AAGK,MAAMrG,eAAe,GAAA,WAAA,IAGxBlP,kNAAAA,AAAI,EACN,CAAC,EACD,CAAa+E,GAA2B,EAAEgB,IAA0B,EAAEvB,KAAQ,GAC5EK,iBAAiB,CACfkM,OAAO,CAAC6B,WAAW,CAAC7M,IAAI,CAAC,EAAEoN,WAAW,CAACpN,IAAI,EAAEvB,KAAK,CAAC,CAAC,EACpD,IAAMO,GAAG,GACR0Q,QAAQ,GAAKtC,WAAW,CAACpN,IAAI,EAAE0P,QAAQ,CAAC,CAC1C,CACJ;AAGM,MAAMC,mBAAmB,GAAA,WAAA,OAAG1V,+MAAAA,AAAI,EAGrC,CAAC,EAAE,CAAC+E,GAAG,EAAEgB,IAAI,EAAE4B,CAAC,GAAKuL,eAAe,CAACnN,IAAI,GAAGX,CAAC,GAAK8J,eAAe,CAACnK,GAAG,EAAEgB,IAAI,EAAE4B,CAAC,CAACvC,CAAC,CAAC,CAAC,CAAC,CAAC;AAG/E,MAAMuQ,kBAAkB,GAAGA,CAChCpC,OAAc,EACdjI,OAGC,GAEDsK,uBAAuB,CAACrC,OAAO,EAAE;QAC/BsC,MAAM,EAAExU,cAAc,oMAAC8O,MAAM,EAAE;QAC/B2F,IAAI,EAAExK,OAAO,EAAEwK,IAAI,4MAAI7V,WAAQ;QAC/B8V,IAAI,EAAEzK,OAAO,EAAEyK;KAChB,CAAC;AAGG,MAAMC,yBAAyB,IACpCzC,OAA2B,IACc;IACzC,MAAMsC,MAAM,GAAGxU,cAAc,oMAAC4U,OAAO,EAAK;IAC1C,OAAOL,uBAAuB,CAACrC,OAAO,EAAE;QACtCsC,MAAM;QACNC,IAAI,EAAED,MAAM,CAACb,KAAAA;KACd,CAAC;AACJ,CAAC;AAGM,MAAMkB,+BAA+B,IAC1C3C,OAAyB,IACc;IACvC,MAAMsC,MAAM,GAAGxU,cAAc,oMAAC8U,aAAa,CAAC9U,cAAc,oMAAC8O,MAAM,EAAK,CAAC;IACvE,OAAOyF,uBAAuB,CAACrC,OAAO,EAAE;QACtCsC,MAAM;QACNC,IAAI,EAAED,MAAM,CAACb,KAAAA;KACd,CAAC;AACJ,CAAC;AAGM,MAAMoB,yBAAyB,IACpC7C,OAA2B,IACc;IACzC,MAAMsC,MAAM,GAAGxU,cAAc,oMAACgV,WAAW,EAAK;IAC9C,OAAOT,uBAAuB,CAACrC,OAAO,EAAE;QACtCsC,MAAM;QACNC,IAAI,EAAED,MAAM,CAACb,KAAAA;KACd,CAAC;AACJ,CAAC;AAGM,MAAMY,uBAAuB,GAAGA,CACrCrC,OAAc,EACdjI,OAIC,KAC2B;IAC5B,MAAMgL,SAAS,GAAG;QAChB,yNAAGhV,kBAAe;QAClB,CAACmR,cAAc,CAAA,EAAGC,gBAAgB;QAClCa,OAAO;QACPjN,MAAMA,CAAA;YACJ,OAAOsM,WAAW,CAAC,IAAI,CAAC;QAC1B,CAAC;QACD2D,IAAI,EAAEA,CAACd,QAAe,EAAEe,QAAe,GAAKlL,OAAO,CAACuK,MAAM,CAACU,IAAI,CAACd,QAAQ,EAAEe,QAAQ,CAAC;QACnFnS,OAAO,EAAEA,CAACoS,KAAY,EAAEC,MAAa,GAAKpL,OAAO,CAACuK,MAAM,CAACxR,OAAO,CAACoS,KAAK,EAAEC,MAAM,CAAC;QAC/EzT,KAAK,GAAGA,KAAY,IAAMwS,QAAe,GAAKnK,OAAO,CAACuK,MAAM,CAAC5S,KAAK,CAACA,KAAK,EAAEwS,QAAQ,CAAC;QACnFK,IAAI,EAAExK,OAAO,CAACwK,IAAI;QAClBC,IAAI,EAAEzK,OAAO,CAACyK,IAAI,IAAA,CAAK,CAAC/O,CAAC,EAAE2P,CAAC,GAAKA,CAAC;KACnC;IACD,OAAOL,SAAS;AAClB,CAAC;AAGM,MAAMM,8BAA8B,IACzCrD,OAAkC,GAElCqC,uBAAuB,CAACrC,OAAO,EAAE;QAC/BsC,MAAM,EAAEjU,aAAa,2MAACiU,MAAM;QAC5BC,IAAI,EAAElU,aAAa,2MAACiU,MAAM,CAACb,KAAAA;KAC5B,CAAC;AAGG,MAAM6B,cAAc,GAAA,WAAA,kNAA8C1W,cAAAA,AAAW,EAAA,WAAA,GAClF6B,MAAM,CAACC,GAAG,CAAC,gCAAgC,CAAC,EAC5C,IAAMmU,yBAAyB,CAACzW,OAAO,gMAACqV,KAAK,EAAE,CAAC,CACjD;AAGM,MAAM8B,yBAAyB,GAAA,WAAA,kNAA8B3W,cAAAA,AAAW,EAAA,WAAA,GAC7E6B,MAAM,CAACC,GAAG,CAAC,2CAA2C,CAAC,EACvD,IAAM0T,kBAAkB,CAAC,CAAC,CAAC,CAC5B;AAGM,MAAMoB,wBAAwB,GAAA,WAAA,kNAA8B5W,cAAAA,AAAW,EAAA,WAAA,GAC5E6B,MAAM,CAACC,GAAG,CAAC,0CAA0C,CAAC,EACtD,IAAM0T,kBAAkB,CAAC,IAAI,CAAC,CAC/B;AAGM,MAAMqB,qBAAqB,GAAA,WAAA,kNAAwD7W,cAAAA,AAAW,EAAA,WAAA,GACnG6B,MAAM,CAACC,GAAG,CAAC,sCAAsC,CAAC,EAClD,IAAM0T,kBAAkB,CAACtV,OAAO,gMAAC2U,KAAK,EAAE,CAAC,CAC1C;AAGM,MAAMiC,eAAe,GAAA,WAAA,iNAAyC9W,eAAAA,AAAW,EAAA,WAAA,GAC9E6B,MAAM,CAACC,GAAG,CAAC,iCAAiC,CAAC,EAC7C,IAAM0T,kBAAkB,CAAoBzD,YAAY,CAAC,CAC1D;AAGM,MAAMgF,cAAc,GAAA,WAAA,kNAAkD/W,cAAW,AAAXA,EAAW,WAAA,GACtF6B,MAAM,CAACC,GAAG,CAAC,gCAAgC,CAAC,EAC5C,IAAM0T,kBAAkB,CAAClV,IAAI,gMAACuU,KAAK,EAAmB,CAAC,CACxD;AAGM,MAAMpE,sBAAsB,GAAA,WAAA,+MAAG5Q,OAAAA,AAAI,EAGxC,CAAC,EAAE,CAAC+F,IAAI,EAAEoR,SAAS,GAAKjI,eAAe,CAACnJ,IAAI,EAAE+Q,yBAAyB,EAAEK,SAAS,CAAC,CAAC;AAG/E,MAAMC,qBAAqB,GAAA,WAAA,+MAAGpX,OAAAA,AAAI,EAGvC,CAAC,EAAE,CAAC+F,IAAI,EAAEoR,SAAS,GAAKjI,eAAe,CAACnJ,IAAI,EAAEgR,wBAAwB,EAAEI,SAAS,CAAC,CAAC;AAG9E,MAAMrH,kBAAkB,GAAA,WAAA,kNAA4C3P,cAAAA,AAAW,EAAA,WAAA,GACpF6B,MAAM,CAACC,GAAG,CAAC,oCAAoC,CAAC,EAChD,IAAM0T,kBAAkB,CAAuB,WAAW,CAAC,CAC5D;AAKM,MAAM1F,sBAAsB,GAAA,WAAA,kNAAG9P,cAAAA,AAAW,EAAA,WAAA,GAC/C6B,MAAM,CAACC,GAAG,CAAC,wCAAwC,CAAC,EACpD,IAAM0T,kBAAkB,CAAC,IAAI,CAAC,CAC/B;AAGM,MAAM0B,6BAA6B,GAAA,WAAA,GAAwDlX,6NAAAA,AAAW,EAAA,WAAA,GAC3G6B,MAAM,CAACC,GAAG,CAAC,+CAA+C,CAAC,EAC3D,IAAM0T,kBAAkB,CAAChV,MAAM,gMAACwO,IAAI,CAAoBgD,aAAa,CAAC,CAAC,CACxE;AAGM,MAAMmF,0BAA0B,GAAA,WAAA,+MAAGtX,OAAAA,AAAI,EAG5C,CAAC,EAAE,CAAC+F,IAAI,EAAEwR,KAAK,GAAKrI,eAAe,CAACnJ,IAAI,EAAEsR,6BAA6B,EAAEE,KAAK,CAAC,CAAC;AAG3E,MAAMC,mBAAmB,GAAA,WAAA,kNAA8DrX,cAAAA,AAAW,EAAA,WAAA,GACvG6B,MAAM,CAACC,GAAG,CAAC,qCAAqC,CAAC,EACjD,IAAMiU,+BAA+B,CAACzW,GAAG,kMAACuV,KAAK,EAAE,CAAC,CACnD;AAGM,MAAMyC,YAAY,GAAA,WAAA,GAA0D7E,WAAW,CAC5F4E,mBAAmB,CACpB;AAGM,MAAMxI,wBAAwB,GAAA,WAAA,kNAA4D7O,cAAAA,AAAW,EAAA,WAAA,GAC1G6B,MAAM,CAACC,GAAG,CAAC,0CAA0C,CAAC,EACtD,IACE0T,kBAAkB,CAAChV,MAAM,gMAACgG,IAAI,EAAE,EAAE;QAChCmP,IAAI,EAAEA,CAAA,GAAMnV,MAAM,gMAACgG,IAAI,EAA0C;QACjEoP,IAAI,EAAEA,CAAC2B,MAAM,EAAE1Q,CAAC,GAAK0Q;KACtB,CAAC,CACL;AAGM,MAAMC,uBAAuB,GAAA,WAAA,OAA0CxX,yNAAAA,AAAW,EAAA,WAAA,GACvF6B,MAAM,CAACC,GAAG,CAAC,yCAAyC,CAAC,EACrD,IACE0T,kBAAkB,CAACxU,aAAa,oMAAC6T,KAAK,EAAE;QACtCc,IAAI,EAAEA,CAAA,GAAM3U,aAAa,oMAAC6T,KAAK;QAC/Be,IAAI,EAAEA,CAAC2B,MAAM,EAAE1Q,CAAC,GAAK0Q;KACtB,CAAC,CACL;AAGM,MAAMpH,oBAAoB,GAAA,WAAA,OAA+BnQ,yNAAAA,AAAW,EAAA,WAAA,GACzE6B,MAAM,CAACC,GAAG,CAAC,sCAAsC,CAAC,EAClD,IAAM0T,kBAAkB,CAAC,IAAI,CAAC,CAC/B;AAGM,MAAMnF,0BAA0B,GAAA,WAAA,kNAA+BrQ,cAAAA,AAAW,EAAA,WAAA,GAC/E6B,MAAM,CAACC,GAAG,CAAC,qCAAqC,CAAC,EACjD,IAAM0T,kBAAkB,CAAC,IAAI,CAAC,CAC/B;AAGM,MAAMiC,4BAA4B,GAAA,WAAA,kNAAwDzX,cAAW,AAAXA,EAAW,WAAA,GAC1G6B,MAAM,CAACC,GAAG,CAAC,8CAA8C,CAAC,EAC1D,IAAM0T,kBAAkB,CAACtV,OAAO,gMAAC2U,KAAK,EAAE,CAAC,CAC1C;AAGM,MAAM6C,sBAAsB,GAAA,WAAA,kNAAoD1X,cAAAA,AAAW,EAAA,WAAA,GAChG6B,MAAM,CAACC,GAAG,CAAC,wCAAwC,CAAC,EACpD,IAAM0T,kBAAkB,CAACjW,KAAK,gMAACsV,KAAK,EAAE,CAAC,CACxC;AAOM,MAAM8C,WAAW,GAAA,WAAA,GAAsB9V,MAAM,CAACC,GAAG,CAAC,cAAc,CAAsB;AAGtF,MAAM8V,oBAAoB,GAAA,WAAA,GAA+B/V,MAAM,CAACC,GAAG,CACxE,uBAAuB,CACM;AAGxB,MAAM+V,iBAAiB,GAAGA,CAC/BjS,IAAiB,EACjBkS,SAAiC,GACTlS,IAAI,CAACmS,YAAY,CAAC,IAAMjS,MAAM,CAACgS,SAAS,CAAC,CAAC;AAG7D,MAAME,qBAAqB,GAAGA,CACnCpS,IAAiB,EACjBkS,SAAgC,GACRlS,IAAI,CAACmS,YAAY,CAACD,SAAS,CAAC;AAG/C,MAAMG,UAAU,GAAGA,CACxBrS,IAA2B,EAC3BV,IAAiC,GACTU,IAAI,CAACsS,KAAK,CAAChT,IAAI,CAAC;AAGnC,MAAMiT,SAAS,GAAGA,CACvBvS,IAAiB,EACjBwS,QAA6C,GACJxS,IAAI,CAAC+P,IAAI,CAACyC,QAAQ,CAAC;AAOvD,MAAMC,WAAW,IAAOzS,IAAoB,IAAa;IAC9D,OAAO0S,eAAe,yMAACxY,WAAQ,CAAC,CAAC8F,IAAI,CAAC;AACxC,CAAC;AAGM,MAAM0S,eAAe,GAAA,WAAA,+MAAGzY,OAAI,AAAJA,EAG7B,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,KAAI;IACf,MAAM+Q,MAAM,+MAAGxY,OAAAA,AAAI,EAAC6F,IAAI,EAAE5E,aAAa,oMAACwX,aAAa,EAAEhY,MAAM,gMAAC0M,GAAG,CAAC1F,CAAC,CAAC,CAAC;IACrE,OAAQ+Q,MAAM,CAACpW,IAAI;QACjB,KAAK,MAAM;YAAE;gBACX,QAAOpC,kNAAAA,AAAI,EACTiB,aAAa,oMAACqK,OAAO,CAACzF,IAAI,CAAC,EAC3BrG,KAAK,gMAACkZ,IAAI,EACVjY,MAAM,gMAACkY,KAAK,CAAC;oBACXC,MAAM,EAAEA,CAAA,KAAK;wBACX,MAAMC,UAAU,GAAGtZ,GAAG,kMAACqM,YAAY,CAAC3K,aAAa,oMAACiN,YAAY,CAACrI,IAAI,CAAC,CAAC,CAACZ,OAAO,CAAEuF,OAAO,IACpFjL,GAAG,kMAACqM,YAAY,CAAC/L,OAAO,gMAACwU,GAAG,CAAC7J,OAAO,CAAC,CAAC,CAAC2C,GAAG,EAAEzC,EAAE,GAAK,CAAA,CAAA,EAAIA,EAAE,EAAE,CAAC,CAC7D;wBACD,OAAO,IAAIoO,oBAAoB,CAACD,UAAU,GAAG,CAAA,uBAAA,EAA0BA,UAAU,CAAChD,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,KAAK,CAAC,CAAC;oBAC1G,CAAC;oBACDkD,MAAM,0MAAEhZ,WAAAA;iBACT,CAAC,CACH;YACH;QACA,KAAK,MAAM;YAAE;gBACX,OAAOyY,MAAM,CAAClU,KAAK;YACrB;IACF;AACF,CAAC,CAAC;AAOK,MAAM0U,cAAc,GAAA,WAAA,GAA2E;IACpG,MAAMA,cAAe,SAAQC,UAAU,CAAC5S,KAAK;QAC3CD,MAAMA,CAAA,EAAA;YACJ,OAAOiE,IAAI,CAAC,IAAI,CAAC;QACnB;QACA/J,MAAMA,CAAA,EAAA;YACJ,OAAO;gBAAE,GAAG,IAAA;YAAI,CAAE;QACpB;QACA,4MAACD,oBAAiB,CAAA,GAAC;YACjB,IAAI,IAAI,CAACwD,QAAQ,KAAKoV,UAAU,CAAC5S,KAAK,CAAC6S,SAAS,CAACrV,QAAQ,EAAE;gBACzD,OAAO,IAAI,CAACsV,KAAK,GAAG,GAAG,IAAI,CAACtV,QAAQ,EAAE,CAAA,EAAA,EAAK,IAAI,CAACsV,KAAK,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC,CAACxD,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,CAAChS,QAAQ,EAAE;YAC3G,CAAC,MAAM,IAAI,KAAK,IAAIoV,UAAU,EAAE;gBAC9B,OAAOhY,aAAa,oMAACqY,MAAM,CAACrY,aAAa,oMAACoJ,IAAI,CAAC,IAAI,CAAC,EAAE;oBAAEkP,gBAAgB,EAAE;gBAAI,CAAE,CAAC;YACnF;YACA,OAAO,IAAI;QACb;;IAEFC,MAAM,CAACC,MAAM,CAACT,cAAc,CAACE,SAAS,wNAAE5X,4BAAyB,CAAC;IAClE,OAAO0X,cAAqB;AAC9B,CAAC,CAAC,CAAE;AAEJ,MAAMU,aAAa,GAAGA,CACpBC,KAAmD,EACnDC,GAAc,KAC4B;IAC1C,MAAMC,IAAK,SAAQb,cAAc;QACtB5W,IAAI,GAAGwX,GAAG,CAAA;;IAErBJ,MAAM,CAACC,MAAM,CAACI,IAAI,CAACX,SAAS,EAAES,KAAK,CAAC;IAClCE,IAAI,CAACX,SAAiB,CAACY,IAAI,GAAGF,GAAG;IACnC,OAAOC,IAAW;AACpB,CAAC;AAGM,MAAME,sBAAsB,GAAA,WAAA,GAAiCjY,MAAM,CAACC,GAAG,CAC5E,sCAAsC,CACP;AAG1B,MAAM8H,gBAAgB,GAAA,WAAA,GAAG6P,aAAa,CAAyB;IACpE,CAACK,sBAAsB,CAAA,EAAGA;CAC3B,EAAE,kBAAkB,CAAC;AAGf,MAAMC,kBAAkB,IAAI/X,CAAU,GAAkCtB,2NAAAA,AAAW,EAACsB,CAAC,EAAE8X,sBAAsB,CAAC;AAG9G,MAAME,0BAA0B,GAAA,WAAA,GAAqCnY,MAAM,CAACC,GAAG,CACpF,0CAA0C,CACP;AAG9B,MAAM+W,oBAAoB,GAAA,WAAA,GAAGY,aAAa,CAA6B;IAC5E,CAACO,0BAA0B,CAAA,EAAGA;CAC/B,EAAE,sBAAsB,CAAC;AAGnB,MAAMC,sBAAsB,IAAIjY,CAAU,gNAC/CtB,cAAAA,AAAW,EAACsB,CAAC,EAAEgY,0BAA0B,CAAC;AAGrC,MAAME,8BAA8B,GAAA,WAAA,GAAyCrY,MAAM,CAACC,GAAG,CAC5F,qCAAqC,CACE;AAGlC,MAAMqY,wBAAwB,GAAA,WAAA,GAAGV,aAAa,CAAiC;IACpF,CAACS,8BAA8B,CAAA,EAAGA;CACnC,EAAE,0BAA0B,CAAC;AAGvB,MAAME,0BAA0B,IAAIpY,CAAU,OACnDtB,uNAAAA,AAAW,EAACsB,CAAC,EAAEkY,8BAA8B,CAAC;AAGzC,MAAMG,4BAA4B,GAAA,WAAA,GAAuCxY,MAAM,CAACC,GAAG,CACxF,mCAAmC,CACE;AAGhC,MAAMwY,sBAAsB,GAAA,WAAA,GAAGb,aAAa,CAA+B;IAChF,CAACY,4BAA4B,CAAA,EAAGA;CACjC,EAAE,wBAAwB,CAAC;AAGrB,MAAME,wBAAwB,IAAIvY,CAAU,gNACjDtB,cAAAA,AAAW,EAACsB,CAAC,EAAEqY,4BAA4B,CAAC;AAGvC,MAAMG,oCAAoC,GAAA,WAAA,GAA+C3Y,MAAM,CAACC,GAAG,CACxG,oDAAoD,CACP;AAGxC,MAAM2Y,8BAA8B,GAAA,WAAA,GAAGhB,aAAa,CAAuC;IAChG,CAACe,oCAAoC,CAAA,EAAGA;CACzC,EAAE,gCAAgC,CAAC;AAG7B,MAAME,+BAA+B,GAAA,WAAA,GAA0C7Y,MAAM,CAACC,GAAG,CAC9F,+CAA+C,CACP;AAGnC,MAAM6Y,yBAAyB,GAAA,WAAA,GAAGlB,aAAa,CAAkC;IACtF,CAACiB,+BAA+B,CAAA,EAAGA;CACpC,EAAE,2BAA2B,CAAC;AAGxB,MAAME,2BAA2B,IAAI5Y,CAAU,gNACpDtB,cAAAA,AAAW,EAACsB,CAAC,EAAE0Y,+BAA+B,CAAC;AAG1C,MAAMG,sBAAsB,GAAI7Y,CAAU,QAC/CtB,uNAAAA,AAAW,EAACsB,CAAC,EAAEwY,oCAAoC,CAAC;AAG/C,MAAMM,sBAAsB,GAAA,WAAA,GAAiCjZ,MAAM,CAACC,GAAG,CAC5E,6BAA6B,CACE;AAG1B,MAAMiZ,gBAAgB,GAAA,WAAA,GAAGtB,aAAa,CAAyB;IACpE,CAACqB,sBAAsB,CAAA,EAAGA;CAC3B,EAAE,kBAAkB,CAAC;AAEf,MAAME,4BAA4B,IAAIC,QAAgC,GAC3E,IAAIF,gBAAgB,CAAC,CAAA,sDAAA,EAAyDtb,QAAQ,gMAACU,MAAM,CAAC8a,QAAQ,CAAC,CAAA,SAAA,CAAW,CAAC;AAG9G,MAAMC,kBAAkB,IAAIlZ,CAAU,gNAAkCtB,cAAAA,AAAW,EAACsB,CAAC,EAAE8Y,sBAAsB,CAAC;AAG9G,MAAMK,sBAAsB,GAAA,WAAA,GAAiCtZ,MAAM,CAACC,GAAG,CAC5E,sCAAsC,CACP;AAG1B,MAAMiJ,gBAAgB,GAAA,WAAA,GAC1B;IACC,MAAMA,gBAAiB,SAAQgO,cAAc;QAGtB7W,KAAA,CAAA;QAFZC,IAAI,GAAG,kBAAkB,CAAA;QACzBkI,KAAK,CAAA;QACdnH,YAAqBhB,KAAc,EAAEwH,OAAgB,CAAA;YACnD,KAAK,CAACA,OAAO,IAAI,2BAA2B,EAAE;gBAAExH;YAAK,CAAE,CAAC;YADrC,IAAA,CAAAA,KAAK,GAALA,KAAK;YAExB,IAAI,CAACmI,KAAK,GAAGnI,KAAK;QACpB;;IAEFqX,MAAM,CAACC,MAAM,CAACzO,gBAAgB,CAACkO,SAAS,EAAE;QACxC,CAACkC,sBAAsB,CAAA,EAAGA,sBAAsB;QAChDtB,IAAI,EAAE;KACP,CAAC;IACF,OAAO9O,gBAAuB;AAChC,CAAC,CAAC,CAAE;AAGC,MAAMqQ,kBAAkB,IAAIpZ,CAAU,gNAAkCtB,cAAAA,AAAW,EAACsB,CAAC,EAAEmZ,sBAAsB,CAAC;AAO9G,MAAMpX,UAAU,IAAI/B,CAAU,GACnCsC,QAAQ,CAACtC,CAAC,CAAC,IAAI,MAAM,IAAIA,CAAC,IAAA,CAAKA,CAAC,CAACG,IAAI,KAAK,SAAS,IAAIH,CAAC,CAACG,IAAI,KAAK,SAAS,CAAC;AAGvE,MAAMkZ,aAAa,IAAUzV,IAAqB,GAAiCA,IAAI,CAACzD,IAAI,KAAK,SAAS;AAG1G,MAAMqL,aAAa,GAAU5H,IAAqB,IAAiCA,IAAI,CAACzD,IAAI,KAAK,SAAS;AAG1G,MAAMmZ,iBAAiB,IAAU1V,IAAqB,IAAa;IACxE,OAAQA,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAOtE,aAAa,oMAACua,aAAa,CAAC3V,IAAI,CAACnD,qBAAqB,CAAC;QAChE,KAAKjB,OAAO,sNAACiE,UAAU;YACrB,OAAO,KAAK;IAChB;AACF,CAAC;AAGM,MAAM+V,MAAM,GAAA,WAAA,GAAG3b,mNAAAA,AAAI,EAGxB,CAAC,EAAE,CAAW+F,IAAqB,EAAEvB,KAAS,KAAsB;IACpE,OAAQuB,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YAAE;gBACvB,OAAO4E,aAAa,CAACtE,IAAI,CAACnD,qBAAqB,CAAC;YAClD;QACA,KAAKjB,OAAO,sNAACiE,UAAU;YAAE;gBACvB,OAAO0E,WAAW,CAAC9F,KAAK,CAAqB;YAC/C;IACF;AACF,CAAC,CAAC;AAGK,MAAMoX,UAAU,IAAU7V,IAAqB,GAAyB4V,MAAM,CAAC5V,IAAI,EAAE,KAAK,CAAC,CAAC;AAG5F,MAAM8V,eAAe,IAAU9V,IAAqB,IAAmC;IAC5F,OAAQA,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAO9E,MAAM,gMAACwO,IAAI,CAACpJ,IAAI,CAACnD,qBAAqB,CAAC;QAChD,KAAKjB,OAAO,sNAACiE,UAAU;YACrB,OAAOjF,MAAM,gMAACgG,IAAI,EAAE;IACxB;AACF,CAAC;AAGM,MAAMmV,cAAc,GAAGA,CAC5BC,KAAgC,EAChCzQ,OAEC,GAED0Q,sBAAsB,CAACD,KAAK,EAAEzQ,OAAO,EAAE3F,QAAQ,GAAGxE,aAAa,oMAACwE,QAAQ,GAAGxE,aAAa,oMAAC4M,UAAU,CAAC;AAG/F,MAAMkO,OAAO,IAAIxS,MAAe,GACrCY,aAAa,CAAClJ,aAAa,oMAACqI,GAAG,CAACC,MAAM,CAAC,CAAqB;AAGvD,MAAMyS,UAAU,GAAA,WAAA,+MAKnBlc,OAAAA,AAAI,EAAC,CAAC,EAAE,CAAoB+F,IAAqB,EAAEoW,UAA4B,KAA0B;IAC3G,OAAQpW,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAO,KAAK;QACd,KAAK9D,OAAO,sNAACiE,UAAU;YACrB,OAAOuW,UAAU,CAACpW,IAAI,CAACnD,qBAAqB,CAAC;IACjD;AACF,CAAC,CAAC;AAGK,MAAMwZ,QAAQ,IAAO5R,KAAQ,GAClCH,aAAa,CAAClJ,aAAa,oMAACoJ,IAAI,CAACC,KAAK,CAAC,CAAwB;AAG1D,MAAMH,aAAa,IAAOhI,KAAqB,IAAyB;IAC7E,MAAMK,MAAM,GAAG,IAAIuB,sBAAsB,CAACtC,OAAO,sNAAC8D,UAAU,CAAQ;IACpE/C,MAAM,CAACE,qBAAqB,GAAGP,KAAK;IACpC,OAAOK,MAAM;AACf,CAAC;AAGM,MAAM2Z,WAAW,GAAA,WAAA,+MAAGrc,OAAAA,AAAI,EAG7B,CAAC,EAAE,CAAe+F,IAAqB,EAAE4B,CAA8B,KAA2B;IAClG,OAAQ5B,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YAAE;gBACvB,OAAO4E,aAAa,CAACtE,IAAI,CAACnD,qBAAqB,CAAC;YAClD;QACA,KAAKjB,OAAO,sNAACiE,UAAU;YAAE;gBACvB,OAAO+B,CAAC,CAAC5B,IAAI,CAACnD,qBAAqB,CAAC;YACtC;IACF;AACF,CAAC,CAAC;AAGK,MAAM0Z,iBAAiB,GAAA,WAAA,+MAQ1Btc,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAAqB,EACrB4B,CAAmD,KACT;IAC1C,OAAQ5B,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YAAE;gBACvB,OAAOO,OAAO,CAACqE,aAAa,CAACtE,IAAI,CAACnD,qBAAqB,CAAC,CAAC;YAC3D;QACA,KAAKjB,OAAO,sNAACiE,UAAU;YAAE;gBACvB,OAAO+B,CAAC,CAAC5B,IAAI,CAACnD,qBAAqB,CAAC;YACtC;IACF;AACF,CAAC,CAAC;AAGK,MAAM2Z,WAAW,IACtBxW,IAAoC,+MACX7F,OAAAA,AAAI,EAAC6F,IAAI,EAAEsW,WAAW,yMAACpc,WAAQ,CAAC,CAAC;AAGrD,MAAMuc,iBAAiB,GAAA,WAAA,+MAQ1Bxc,OAAAA,AAAI,EAAC,CAAC,EAAE,CACV+F,IAAqB,EACrB4B,CAAoC,KACa;IACjD,OAAQ5B,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YAAE;gBACvB,OAAOO,OAAO,CAACqE,aAAa,CAACtE,IAAI,CAACnD,qBAAqB,CAAC,CAAC;YAC3D;QACA,KAAKjB,OAAO,sNAACiE,UAAU;YAAE;gBACvB,OAAOP,IAAI,CAACsC,CAAC,CAAC5B,IAAI,CAACnD,qBAAqB,CAAC,CAAC;YAC5C;IACF;AACF,CAAC,CAAC;AAGK,MAAM6Z,cAAc,IAAUxU,MAA2B,IAAqB;IACnF,OAAQA,MAAM,CAAC3F,IAAI;QACjB,KAAK,MAAM;YACT,OAAO8Z,QAAQ,CAACnU,MAAM,CAACE,IAAI,CAAC;QAC9B,KAAK,OAAO;YACV,OAAOmC,WAAW,CAACrC,MAAM,CAACG,KAAK,CAAC;IACpC;AACF,CAAC;AAGM,MAAMsU,cAAc,IAAOhE,MAAwB,IAAwB;IAChF,OAAQA,MAAM,CAACpW,IAAI;QACjB,KAAK,MAAM;YACT,OAAO8Z,QAAQ,CAAC,KAAK,CAAC,CAAC;QACzB,KAAK,MAAM;YACT,OAAO9R,WAAW,CAACoO,MAAM,CAAClU,KAAK,CAAC;IACpC;AACF,CAAC;AAGM,MAAMmY,aAAa,GAAA,WAAA,+MAAG3c,OAAAA,AAAI,EAG/B,CAAC,EAAE,CAAC+F,IAAI,EAAEsI,MAAM,KAAI;IACpB,OAAQtI,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAO4I,MAAM,CAACtI,IAAI,CAACnD,qBAAqB,CAAC;QAC3C,KAAKjB,OAAO,sNAACiE,UAAU;YACrB,OAAOG,IAAI,CAACnD,qBAAqB;IACrC;AACF,CAAC,CAAC;AAGK,MAAMga,aAAa,IAAIlS,OAAwB,GACpDL,aAAa,CAAClJ,aAAa,oMAACuL,SAAS,CAAChC,OAAO,CAAC,CAAC;AAG1C,MAAMmS,OAAO,GAAA,WAAA,+MAAG7c,OAAAA,AAAI,EAGzB,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,KAAI;IACf,OAAQ5B,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAO4E,aAAa,CAACtE,IAAI,CAACnD,qBAAqB,CAAC;QAClD,KAAKjB,OAAO,sNAACiE,UAAU;YACrB,OAAO0E,WAAW,CAAC3C,CAAC,CAAC5B,IAAI,CAACnD,qBAAqB,CAAC,CAAC;IACrD;AACF,CAAC,CAAC;AAGK,MAAMka,WAAW,GAAA,WAAA,GAAG9c,mNAAAA,AAAI,EAc7B,CAAC,EAAE,CAAC+F,IAAI,EAAE,EAAEP,SAAS,EAAEK,SAAAA,EAAW,KAAI;IACtC,OAAQE,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAO4E,aAAa,6MAACnK,OAAAA,AAAI,EAAC6F,IAAI,CAACnD,qBAAqB,EAAEzB,aAAa,oMAACkM,GAAG,CAAC7H,SAAS,CAAC,CAAC,CAAC;QACtF,KAAK7D,OAAO,sNAACiE,UAAU;YACrB,OAAO0E,WAAW,CAACzE,SAAS,CAACE,IAAI,CAACnD,qBAAqB,CAAC,CAAC;IAC7D;AACF,CAAC,CAAC;AAGK,MAAMma,YAAY,GAAA,WAAA,+MAAG/c,OAAI,AAAJA,EAG1B,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,KAAI;IACf,OAAQ5B,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAO4E,aAAa,6MAACnK,OAAAA,AAAI,EAAC6F,IAAI,CAACnD,qBAAqB,EAAEzB,aAAa,oMAACkM,GAAG,CAAC1F,CAAC,CAAC,CAAC,CAAC;QAC9E,KAAKhG,OAAO,sNAACiE,UAAU;YACrB,OAAO0E,WAAW,CAACvE,IAAI,CAACnD,qBAAqB,CAAC;IAClD;AACF,CAAC,CAAC;AAGK,MAAMoa,iBAAiB,GAAA,WAAA,+MAAGhd,OAAAA,AAAI,EAGnC,CAAC,EAAE,CAAC+F,IAAI,EAAE4B,CAAC,KAAI;IACf,OAAQ5B,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAO4E,aAAa,CAAC1C,CAAC,CAAC5B,IAAI,CAACnD,qBAAqB,CAAC,CAAC;QACrD,KAAKjB,OAAO,sNAACiE,UAAU;YACrB,OAAO0E,WAAW,CAACvE,IAAI,CAACnD,qBAAqB,CAAC;IAClD;AACF,CAAC,CAAC;AAGK,MAAMsL,SAAS,GAAA,WAAA,+MAAGlO,OAAI,AAAJA,EASvB,CAAC,EAAE,CAAC+F,IAAI,EAAE,EAAEP,SAAS,EAAEK,SAAAA,EAAW,KAAI;IACtC,OAAQE,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAOD,SAAS,CAACO,IAAI,CAACnD,qBAAqB,CAAC;QAC9C,KAAKjB,OAAO,sNAACiE,UAAU;YACrB,OAAOC,SAAS,CAACE,IAAI,CAACnD,qBAAqB,CAAC;IAChD;AACF,CAAC,CAAC;AAGK,MAAMqa,eAAe,GAAA,WAAA,+MAAGjd,OAAAA,AAAI,EAcjC,CAAC,EAAE,CAAC+F,IAAI,EAAE,EAAEP,SAAS,EAAEK,SAAAA,EAAW,KAAI;IACtC,OAAQE,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YACrB,OAAOD,SAAS,CAACO,IAAI,CAACnD,qBAAqB,CAAC;QAC9C,KAAKjB,OAAO,sNAACiE,UAAU;YACrB,OAAOC,SAAS,CAACE,IAAI,CAACnD,qBAAqB,CAAC;IAChD;AACF,CAAC,CAAC;AAGK,MAAM0H,WAAW,IAAO9F,KAAQ,IAAkB;IACvD,MAAM9B,MAAM,GAAG,IAAI6B,sBAAsB,CAAC5C,OAAO,sNAACiE,UAAU,CAAQ;IACpElD,MAAM,CAACE,qBAAqB,GAAG4B,KAAK;IACpC,OAAO9B,MAAM;AACf,CAAC;AAGM,MAAMwa,QAAQ,GAAA,WAAA,GAAoB5S,WAAW,CAAC,KAAK,CAAC,CAAC;AAGrD,MAAM6S,OAAO,GAAA,WAAA,+MAAGnd,OAAAA,AAAI,EAGzB,CAAC,EAAE,CAAC+F,IAAI,EAAErC,IAAI,GACd0Z,WAAW,CAACrX,IAAI,EAAErC,IAAI,EAAE;QACtBmC,SAAS,EAAEA,CAACT,CAAC,EAAEiY,EAAE,GAAK;gBAACjY,CAAC;gBAAEiY,EAAE;aAAC;QAC7B7X,SAAS,EAAErE,aAAa,oMAAC4M,UAAAA;KAC1B,CAAC,CAAC;AAGE,MAAMuP,WAAW,GAAA,WAAA,OAAGtd,+MAAAA,AAAI,EAG7B,CAAC,EAAE,CAAC+F,IAAI,EAAErC,IAAI,GACd0Z,WAAW,CAACrX,IAAI,EAAErC,IAAI,EAAE;QACtBmC,SAAS,EAAEA,CAACT,CAAC,EAAE4B,CAAC,GAAK5B,CAAC;QACtBI,SAAS,EAAErE,aAAa,oMAAC4M,UAAAA;KAC1B,CAAC,CAAC;AAGE,MAAMwP,YAAY,GAAA,WAAA,GAAGvd,mNAAI,AAAJA,EAG1B,CAAC,EAAE,CAAC+F,IAAI,EAAErC,IAAI,GACd0Z,WAAW,CAACrX,IAAI,EAAErC,IAAI,EAAE;QACtBmC,SAAS,EAAEA,CAACmB,CAAC,EAAEqW,EAAE,GAAKA,EAAE;QACxB7X,SAAS,EAAErE,aAAa,oMAAC4M,UAAAA;KAC1B,CAAC,CAAC;AAGE,MAAMyP,UAAU,GAAA,WAAA,8MAAGxd,QAAAA,AAAI,EAG5B,CAAC,EAAE,CAAC+F,IAAI,EAAErC,IAAI,GACd0Z,WAAW,CAACrX,IAAI,EAAErC,IAAI,EAAE;QACtBmC,SAAS,EAAEA,CAACT,CAAC,EAAEiY,EAAE,GAAK;gBAACjY,CAAC;gBAAEiY,EAAE;aAAC;QAC7B7X,SAAS,EAAErE,aAAa,oMAACwE,QAAAA;KAC1B,CAAC,CAAC;AAGE,MAAM8X,cAAc,GAAA,WAAA,+MAAGzd,OAAI,AAAJA,EAG5B,CAAC,EAAE,CAAC+F,IAAI,EAAErC,IAAI,GACd0Z,WAAW,CAACrX,IAAI,EAAErC,IAAI,EAAE;QACtBmC,SAAS,EAAEA,CAACT,CAAC,EAAE4B,CAAC,GAAK5B,CAAC;QACtBI,SAAS,EAAErE,aAAa,oMAACwE,QAAAA;KAC1B,CAAC,CAAC;AAGE,MAAM+X,eAAe,GAAA,WAAA,+MAAG1d,OAAAA,AAAI,EAGjC,CAAC,EAAE,CAAC+F,IAAI,EAAErC,IAAI,GACd0Z,WAAW,CAACrX,IAAI,EAAErC,IAAI,EAAE;QACtBmC,SAAS,EAAEA,CAACmB,CAAC,EAAEqW,EAAE,GAAKA,EAAE;QACxB7X,SAAS,EAAErE,aAAa,oMAACwE,QAAAA;KAC1B,CAAC,CAAC;AAGE,MAAMyX,WAAW,GAAA,WAAA,+MAAGpd,OAAAA,AAAI,EAgB7B,CAAC,EAAE,CACH+F,IAAI,EACJrC,IAAI,EACJ,EAAE8B,SAAS,EAAEK,SAAAA,EAAW,KACtB;IACF,OAAQE,IAAI,CAACzD,IAAI;QACf,KAAKX,OAAO,sNAAC8D,UAAU;YAAE;gBACvB,OAAQ/B,IAAI,CAACpB,IAAI;oBACf,KAAKX,OAAO,sNAACiE,UAAU;wBACrB,OAAOyE,aAAa,CAACtE,IAAI,CAACnD,qBAAqB,CAAC;oBAClD,KAAKjB,OAAO,sNAAC8D,UAAU;wBAAE;4BACvB,OAAO4E,aAAa,CAAC7E,SAAS,CAACO,IAAI,CAACnD,qBAAqB,EAAEc,IAAI,CAACd,qBAAqB,CAAC,CAAC;wBACzF;gBACF;YACF;QACA,KAAKjB,OAAO,sNAACiE,UAAU;YAAE;gBACvB,OAAQlC,IAAI,CAACpB,IAAI;oBACf,KAAKX,OAAO,sNAACiE,UAAU;wBACrB,OAAO0E,WAAW,CAACzE,SAAS,CAACE,IAAI,CAACnD,qBAAqB,EAAEc,IAAI,CAACd,qBAAqB,CAAC,CAAC;oBACvF,KAAKjB,OAAO,sNAAC8D,UAAU;wBACrB,OAAO4E,aAAa,CAAC3G,IAAI,CAACd,qBAAqB,CAAC;gBACpD;YACF;IACF;AACF,CAAC,CAAC;AAEF,MAAMoZ,sBAAsB,GAAGA,CAC7BD,KAAgC,EAChC4B,aAAiF,KACxC;IACzC,MAAMC,IAAI,GAAGle,KAAK,gMAACoM,YAAY,CAACiQ,KAAK,CAAC;IACtC,IAAI,CAACrc,KAAK,gMAACme,UAAU,CAACD,IAAI,CAAC,EAAE;QAC3B,OAAOjd,MAAM,gMAACgG,IAAI,EAAE;IACtB;IACA,mNAAOzG,OAAAA,AAAI,EACTR,KAAK,gMAACoe,YAAY,CAACF,IAAI,CAAC,EACxBne,GAAG,kMAACoV,MAAM,EACR3U,kNAAAA,AAAI,EAACR,KAAK,gMAACqe,YAAY,CAACH,IAAI,CAAC,EAAEf,OAAO,CAAoBnd,KAAK,gMAACse,EAAE,CAAC,CAAC,EACpE,CAACC,WAAW,EAAEC,OAAO,OACnBhe,+MAAAA,AAAI,EACF+d,WAAW,EACXb,WAAW,CAACc,OAAO,EAAE;YACnBrY,SAAS,EAAEA,CAAC+X,IAAI,EAAEpZ,KAAK,+MAAKtE,OAAI,AAAJA,EAAK0d,IAAI,EAAEle,KAAK,gMAACye,OAAO,CAAC3Z,KAAK,CAAC,CAAC;YAC5DgB,SAAS,EAAEmY;SACZ,CAAC,CACH,CACJ,EACDd,OAAO,CAACnd,KAAK,gMAAC0e,OAAO,CAAC,EACtBvB,OAAO,EAAEwB,KAAK,GAAK3e,KAAK,gMAAC4e,eAAe,CAACD,KAAK,CAAa,CAAC,EAC5D1d,MAAM,gMAACwO,IAAI,CACZ;AACH,CAAC;AAOM,MAAMoP,kBAAkB,IAAkB7T,OAAwB,IAA6B;IACpG,MAAM8T,SAAS,GAAG;QAChB,yNAAGld,kBAAe;QAClB,CAACF,QAAQ,4MAACqd,cAAc,CAAA,EAAGrd,QAAQ,4MAACsd,gBAAgB;QACpD/T,KAAK,EAAEjK,UAAU,gMAACgU,IAAI,CAACtT,QAAQ,4MAACud,OAAO,CAAO,EAAE,CAAC,CAAC;QAClDrY,MAAMA,CAAA;YACJ,OAAOsY,aAAa,CAAC,IAAI,CAAC;QAC5B,CAAC;QACDlY,UAAU,EAAEgE;KACb;IACD,OAAO8T,SAAS;AAClB,CAAC;AAGM,MAAMK,YAAY,GAAGA,CAAA,GAC1B1Z,OAAO,CAACuF,OAAO,GAAGE,EAAE,GAAKkU,cAAc,CAAOlU,EAAE,CAAC,CAAC;AAG7C,MAAMkU,cAAc,IAAkBpU,OAAwB,GACnER,IAAI,CAAC,IAAMqU,kBAAkB,CAAO7T,OAAO,CAAC,CAAC;AAGxC,MAAMkU,aAAa,IAAU7Y,IAA6B,GAC/DmB,KAAK,EAAQJ,MAAM,IAAI;QACrB,MAAM6D,KAAK,GAAGjK,UAAU,gMAAC6I,GAAG,CAACxD,IAAI,CAAC4E,KAAK,CAAC;QACxC,OAAQA,KAAK,CAACrI,IAAI;YAChB,KAAKZ,eAAe,gNAACqd,aAAa;gBAAE;oBAClC,OAAOjY,MAAM,CAAC6D,KAAK,CAACjI,MAAM,CAAC;gBAC7B;YACA,KAAKhB,eAAe,gNAACsd,gBAAgB;gBAAE;oBACrC,oDAAA;oBACArU,KAAK,CAACsU,OAAO,CAACC,IAAI,CAACpY,MAAM,CAAC;oBAC1B,OAAOqY,uBAAuB,CAACpZ,IAAI,EAAEe,MAAM,CAAC;gBAC9C;QACF;IACF,CAAC,EAAEf,IAAI,CAACW,UAAU,CAAC;AAGd,MAAM0Y,gBAAgB,GAAA,WAAA,+MAGzBpf,OAAAA,AAAI,EACN,CAAC,EACD,CAAO+F,IAA6B,EAAErD,MAA2B,GAC/DyK,YAAY,CAACzK,MAAM,EAAEqD,IAAI,CAAC,CAC7B;AAGM,MAAMsZ,oBAAoB,GAAA,WAAA,+MAAGrf,OAAAA,AAAI,EAGtC,CAAC,EAAE,CAAC+F,IAAI,EAAErD,MAAM,GAChBwH,IAAI,CAAC,MAAK;QACR,MAAMS,KAAK,GAAGjK,UAAU,gMAAC6I,GAAG,CAACxD,IAAI,CAAC4E,KAAK,CAAC;QACxC,OAAQA,KAAK,CAACrI,IAAI;YAChB,KAAKZ,eAAe,gNAACqd,aAAa;gBAAE;oBAClC,OAAO,KAAK;gBACd;YACA,KAAKrd,eAAe,gNAACsd,gBAAgB;gBAAE;oBACrCte,UAAU,gMAAC4e,GAAG,CAACvZ,IAAI,CAAC4E,KAAK,EAAEvJ,QAAQ,4MAACme,IAAI,CAAC7c,MAAM,CAAC,CAAC;oBACjD,IAAK,IAAIuJ,CAAC,GAAG,CAAC,EAAEuT,GAAG,GAAG7U,KAAK,CAACsU,OAAO,CAAC5Y,MAAM,EAAE4F,CAAC,GAAGuT,GAAG,EAAEvT,CAAC,EAAE,CAAE;wBACxDtB,KAAK,CAACsU,OAAO,CAAChT,CAAC,CAAC,CAACvJ,MAAM,CAAC;oBAC1B;oBACA,OAAO,IAAI;gBACb;QACF;IACF,CAAC,CAAC,CAAC;AAGE,MAAM0K,YAAY,GAAA,WAAA,GAAGpN,mNAAAA,AAAI,EAG9B,CAAC,EAAE,CAAC+F,IAAI,EAAEV,IAAI,GAAKga,oBAAoB,CAACtZ,IAAI,EAAEV,IAAI,CAAC,CAAC;AAG/C,MAAMoa,YAAY,GAAA,WAAA,+MAAGzf,OAAAA,AAAI,EAG9B,CAAC,EAAE,CAAC+F,IAAI,EAAEyE,KAAK,GAAK6U,oBAAoB,CAACtZ,IAAI,EAAEwE,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC;AAGvD,MAAMkV,gBAAgB,GAAA,WAAA,+MAAG1f,OAAAA,AAAI,EAGlC,CAAC,EAAE,CAAC+F,IAAI,EAAEkE,QAAQ,GAAKoV,oBAAoB,CAACtZ,IAAI,EAAE0E,QAAQ,CAACR,QAAQ,CAAC,CAAC,CAAC;AAGjE,MAAM0V,iBAAiB,GAAA,WAAA,OAAG3f,+MAAAA,AAAI,EAGnC,CAAC,EAAE,CAAC+F,IAAI,EAAE1D,KAAK,GAAKgd,oBAAoB,CAACtZ,IAAI,EAAEL,SAAS,CAACrD,KAAK,CAAC,CAAC,CAAC;AAG5D,MAAMud,qBAAqB,GAAA,WAAA,OAAG5f,+MAAAA,AAAI,EAGvC,CAAC,EAAE,CAAC+F,IAAI,EAAEkE,QAAQ,GAAKoV,oBAAoB,CAACtZ,IAAI,EAAE+D,aAAa,CAACG,QAAQ,CAAC,CAAC,CAAC;AAGtE,MAAM4V,WAAW,GAAA,WAAA,+MAAG7f,OAAAA,AAAI,EAG7B,CAAC,EAAE,CAAC+F,IAAI,EAAE0D,MAAM,GAAK4V,oBAAoB,CAACtZ,IAAI,EAAEyD,GAAG,CAACC,MAAM,CAAC,CAAC,CAAC;AAGxD,MAAMqW,eAAe,GAAA,WAAA,+MAAG9f,OAAI,AAAJA,EAG7B,CAAC,EAAE,CAAC+F,IAAI,EAAEkE,QAAQ,GAAKoV,oBAAoB,CAACtZ,IAAI,EAAEiE,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;AAGhE,MAAM8V,iBAAiB,IAAUha,IAA6B,GACnEZ,OAAO,CAACuF,OAAO,GAAGA,OAAO,GAAK2U,oBAAoB,CAACtZ,IAAI,EAAE4G,aAAa,CAACjC,OAAO,CAAC,CAAC,CAAC;AAG5E,MAAMsV,qBAAqB,GAAA,WAAA,+MAAGhgB,OAAAA,AAAI,EAGvC,CAAC,EAAE,CAAC+F,IAAI,EAAE2E,OAAO,GAAK2U,oBAAoB,CAACtZ,IAAI,EAAE4G,aAAa,CAACjC,OAAO,CAAC,CAAC,CAAC;AAGpE,MAAMuV,cAAc,IAAUla,IAA6B,GAChEmE,IAAI,CAAC,IAAMxJ,UAAU,gMAAC6I,GAAG,CAACxD,IAAI,CAAC4E,KAAK,CAAC,CAACrI,IAAI,KAAKZ,eAAe,gNAACqd,aAAa,CAAC;AAGxE,MAAMmB,YAAY,IACvBna,IAA6B,GAE7BmE,IAAI,CAAC,MAAK;QACR,MAAMS,KAAK,GAAGjK,UAAU,gMAAC6I,GAAG,CAACxD,IAAI,CAAC4E,KAAK,CAAC;QACxC,OAAQA,KAAK,CAACrI,IAAI;YAChB,KAAKZ,eAAe,gNAACqd,aAAa;gBAAE;oBAClC,OAAOpe,MAAM,gMAACwO,IAAI,CAACxE,KAAK,CAACjI,MAAM,CAAC;gBAClC;YACA,KAAKhB,eAAe,gNAACsd,gBAAgB;gBAAE;oBACrC,OAAOre,MAAM,gMAACgG,IAAI,EAAE;gBACtB;QACF;IACF,CAAC,CAAC;AAGG,MAAMwZ,eAAe,GAAA,WAAA,OAAGngB,+MAAAA,AAAI,EAGjC,CAAC,EAAE,CAAC+F,IAAI,EAAEvB,KAAK,GAAK6a,oBAAoB,CAACtZ,IAAI,EAAEC,OAAO,CAACxB,KAAK,CAAC,CAAC,CAAC;AAG1D,MAAM4b,YAAY,GAAA,WAAA,GAAGpgB,mNAAAA,AAAI,EAG9B,CAAC,EAAE,CAAC+F,IAAI,EAAEkE,QAAQ,GAAKoV,oBAAoB,CAACtZ,IAAI,EAAEmE,IAAI,CAACD,QAAQ,CAAC,CAAC,CAAC;AAG7D,MAAMoW,kBAAkB,GAAGA,CAAOta,IAA6B,EAAErD,MAA2B,KAAU;IAC3G,MAAMiI,KAAK,GAAGjK,UAAU,gMAAC6I,GAAG,CAACxD,IAAI,CAAC4E,KAAK,CAAC;IACxC,IAAIA,KAAK,CAACrI,IAAI,KAAKZ,eAAe,gNAACsd,gBAAgB,EAAE;QACnDte,UAAU,gMAAC4e,GAAG,CAACvZ,IAAI,CAAC4E,KAAK,EAAEvJ,QAAQ,4MAACme,IAAI,CAAC7c,MAAM,CAAC,CAAC;QACjD,IAAK,IAAIuJ,CAAC,GAAG,CAAC,EAAEuT,GAAG,GAAG7U,KAAK,CAACsU,OAAO,CAAC5Y,MAAM,EAAE4F,CAAC,GAAGuT,GAAG,EAAEvT,CAAC,EAAE,CAAE;YACxDtB,KAAK,CAACsU,OAAO,CAAChT,CAAC,CAAC,CAACvJ,MAAM,CAAC;QAC1B;IACF;AACF,CAAC;AAED,MAAMyc,uBAAuB,GAAGA,CAC9BpZ,IAA6B,EAC7Bua,MAA6C,GAE7CpW,IAAI,CAAC,MAAK;QACR,MAAMS,KAAK,GAAGjK,UAAU,gMAAC6I,GAAG,CAACxD,IAAI,CAAC4E,KAAK,CAAC;QACxC,IAAIA,KAAK,CAACrI,IAAI,KAAKZ,eAAe,gNAACsd,gBAAgB,EAAE;YACnD,MAAMuB,KAAK,GAAG5V,KAAK,CAACsU,OAAO,CAACuB,OAAO,CAACF,MAAM,CAAC;YAC3C,IAAIC,KAAK,IAAI,CAAC,EAAE;gBACd,sDAAA;gBACA5V,KAAK,CAACsU,OAAO,CAACwB,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;YAChC;QACF;IACF,CAAC,CAAC;AAEJ,gFAAA;AACA,UAAA;AACA,gFAAA;AAEA,MAAMG,YAAY,GAAA,WAAA,GAAGhc,gBAAgB,EAAEgF,KAAK,GAAKY,WAAW,CAACZ,KAAK,CAACmN,cAAc,CAAC,CAAC;AAG5E,MAAM8J,OAAO,GAAGA,CAAA,GAAsDD,YAAmB;AAGzF,MAAME,WAAW,GACtBjZ,CAAsC,IACN0F,GAAG,CAACsT,OAAO,EAAM,EAAEhZ,CAAC,CAAC;AAGhD,MAAMkZ,iBAAiB,IAC5BlZ,CAA2D,GAC3BxC,OAAO,CAACwb,OAAO,EAAM,EAAEhZ,CAAC,CAAC;AAGpD,MAAMmZ,cAAc,GAAA,WAAA,+MAAG9gB,OAAAA,AAAI,EAGhC,CAAC,EAAE,CAAU+F,IAA4B,EAAE4a,OAA2B,GACtEzR,eAAe,CACb2H,cAAc,EACd8J,OAAO,CACR,CAAC5a,IAA2B,CAAC,CAAC;AAG1B,MAAMgb,kBAAkB,GAAA,WAAA,+MAAG/gB,OAAAA,AAAI,EAGpC,CAAC,EAAE,CAAc+F,IAA6B,EAAE4a,OAA2B,GAC3EjL,mBAAmB,CACjBmB,cAAc,GACba,MAAM,GAAK/X,OAAO,gMAACqhB,KAAK,CAACtJ,MAAM,EAAEiJ,OAAO,CAAC,CAC3C,CAAC5a,IAA2B,CAAC,CAAC;AAG1B,MAAMkb,eAAe,GAAA,WAAA,IAAGjhB,kNAAAA,AAAI,EAQjC,CAAC,EAAE,CACH+F,IAA4B,EAC5B4B,CAAuD,GACpDkZ,iBAAiB,EAAEF,OAA4B,GAAKG,cAAc,CAAC/a,IAAI,EAAE4B,CAAC,CAACgZ,OAAO,CAAC,CAAC,CAAC,CAAC;AAOpF,MAAMhX,oBAAoB,IAAUD,KAA+B,IAAgC;IACxG,MAAMT,IAAI,GAAGS,KAAK,CAACwX,WAAW;IAC9B,OAAOjY,IAAI,KAAK3F,SAAS,IAAI2F,IAAI,CAAC3G,IAAI,KAAK,MAAM,GAAG3B,MAAM,gMAACwO,IAAI,CAAClG,IAAI,CAAC,GAAGtI,MAAM,gMAACgG,IAAI,EAAE;AACvF,CAAC;AAED,MAAMwa,aAAa,GAAgB;IACjC7e,IAAI,EAAE,MAAM;IACZ8e,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE,MAAM;IACfrH,IAAI,EAAE,MAAM;IACZsH,OAAO,EAAE,KAAK;IACd5J,MAAM,EAAA,WAAA,GAAE/W,MAAM,gMAACgG,IAAI,EAAE;IACrBga,OAAO,EAAA,WAAA,GAAEhhB,OAAO,gMAACqV,KAAK,EAAE;IACxBvM,MAAM,EAAE;QACNnG,IAAI,EAAE,OAAO;QACbif,SAAS,EAAA,WAAA,GAAEC,MAAM,CAAC,CAAC,CAAC;QACpBC,OAAO,EAAA,WAAA,GAAED,MAAM,CAAC,CAAC,CAAC;QAClBnc,IAAI,EAAE6X;KACP;IACDwE,UAAU,EAAA,WAAA,GAAE,IAAIC,GAAG,EAAE;IACrBC,KAAK,EAAE,EAAE;IACTC,IAAI,EAAE,UAAU;IAChBC,SAASA,CAAA,IAAI,CAAC;IACdC,KAAKA,CAAA,IAAI,CAAC;IACVC,GAAGA,CAAA,IAAI;CACR;AAGM,MAAMC,QAAQ,IAAIjI,IAAY,IAAiB;IACpD,MAAM/Q,IAAI,GAAGyQ,MAAM,CAACwI,MAAM,CAACf,aAAa,CAAC;IACzClY,IAAI,CAAC+Q,IAAI,GAAGA,IAAI;IAChB,OAAO/Q,IAAI;AACb,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}