{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"Schema.js","sources":["file:///Users/david/src/5.%20Semester/SoftwareEngineering-Project/node_modules/.pnpm/effect%403.10.3/node_modules/effect/src/Schema.ts"],"sourcesContent":["/**\n * @since 3.10.0\n */\n\nimport type { ArbitraryAnnotation, ArbitraryGenerationContext, LazyArbitrary } from \"./Arbitrary.js\"\nimport * as array_ from \"./Array.js\"\nimport * as bigDecimal_ from \"./BigDecimal.js\"\nimport * as bigInt_ from \"./BigInt.js\"\nimport * as boolean_ from \"./Boolean.js\"\nimport type { Brand } from \"./Brand.js\"\nimport * as cause_ from \"./Cause.js\"\nimport * as chunk_ from \"./Chunk.js\"\nimport * as config_ from \"./Config.js\"\nimport * as configError_ from \"./ConfigError.js\"\nimport * as data_ from \"./Data.js\"\nimport * as dateTime from \"./DateTime.js\"\nimport * as duration_ from \"./Duration.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as either_ from \"./Either.js\"\nimport * as Encoding from \"./Encoding.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport * as exit_ from \"./Exit.js\"\nimport * as fastCheck_ from \"./FastCheck.js\"\nimport * as fiberId_ from \"./FiberId.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as hashMap_ from \"./HashMap.js\"\nimport * as hashSet_ from \"./HashSet.js\"\nimport * as errors_ from \"./internal/schema/errors.js\"\nimport * as filters_ from \"./internal/schema/filters.js\"\nimport * as util_ from \"./internal/schema/util.js\"\nimport * as list_ from \"./List.js\"\nimport * as number_ from \"./Number.js\"\nimport * as option_ from \"./Option.js\"\nimport type * as Order from \"./Order.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as pretty_ from \"./Pretty.js\"\nimport * as record_ from \"./Record.js\"\nimport * as redacted_ from \"./Redacted.js\"\nimport * as Request from \"./Request.js\"\nimport type { ParseOptions } from \"./SchemaAST.js\"\nimport * as AST from \"./SchemaAST.js\"\nimport * as sortedSet_ from \"./SortedSet.js\"\nimport * as string_ from \"./String.js\"\nimport * as struct_ from \"./Struct.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 3.10.0\n */\nexport type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n/**\n * @since 3.10.0\n */\nexport type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Schema\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly Context: R\n  readonly ast: AST.AST\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   */\n  annotations(annotations: Annotations.Schema<A>): Schema<A, I, R>\n}\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const make = <A, I = A, R = never>(ast: AST.AST): SchemaClass<A, I, R> => (class SchemaClass {\n  [TypeId] = variance\n  static Type: A\n  static Encoded: I\n  static Context: R\n  static [TypeId] = variance\n  static ast = ast\n  static annotations(annotations: Annotations.Schema<A>) {\n    return make<A, I, R>(mergeSchemaAnnotations(this.ast, annotations))\n  }\n  static pipe() {\n    return pipeArguments(this, arguments)\n  }\n  static toString() {\n    return String(ast)\n  }\n})\n\nconst variance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _I: (_: any) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\ninterface AllAnnotations<A, TypeParameters extends ReadonlyArray<any>>\n  extends Annotations.Schema<A, TypeParameters>, PropertySignature.Annotations<A>\n{}\n\nconst builtInAnnotations = {\n  schemaId: AST.SchemaIdAnnotationId,\n  message: AST.MessageAnnotationId,\n  missingMessage: AST.MissingMessageAnnotationId,\n  identifier: AST.IdentifierAnnotationId,\n  title: AST.TitleAnnotationId,\n  description: AST.DescriptionAnnotationId,\n  examples: AST.ExamplesAnnotationId,\n  default: AST.DefaultAnnotationId,\n  documentation: AST.DocumentationAnnotationId,\n  jsonSchema: AST.JSONSchemaAnnotationId,\n  arbitrary: AST.ArbitraryAnnotationId,\n  pretty: AST.PrettyAnnotationId,\n  equivalence: AST.EquivalenceAnnotationId,\n  concurrency: AST.ConcurrencyAnnotationId,\n  batching: AST.BatchingAnnotationId,\n  parseIssueTitle: AST.ParseIssueTitleAnnotationId,\n  parseOptions: AST.ParseOptionsAnnotationId,\n  decodingFallback: AST.DecodingFallbackAnnotationId\n}\n\nconst toASTAnnotations = <A, TypeParameters extends ReadonlyArray<any>>(\n  annotations?: AllAnnotations<A, TypeParameters>\n): AST.Annotations => {\n  if (!annotations) {\n    return {}\n  }\n  const out: Types.Mutable<AST.Annotations> = { ...annotations }\n\n  for (const key in builtInAnnotations) {\n    if (key in annotations) {\n      const id = builtInAnnotations[key as keyof typeof builtInAnnotations]\n      out[id] = annotations[key as keyof typeof annotations]\n      delete out[key]\n    }\n  }\n\n  return out\n}\n\nconst mergeSchemaAnnotations = <A>(ast: AST.AST, annotations: Annotations.Schema<A>): AST.AST =>\n  AST.annotations(ast, toASTAnnotations(annotations))\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotable {\n  /**\n   * @since 3.10.0\n   */\n  export type Self<S extends All> = ReturnType<S[\"annotations\"]>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Annotable<any, any, any, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSchema = <S extends Schema.All>(\n  schema: S\n): Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>> => schema as any\n\n/**\n * @category formatting\n * @since 3.10.0\n */\nexport const format = <S extends Schema.All>(schema: S): string => String(schema.ast)\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Schema {\n  /**\n   * @since 3.10.0\n   */\n  export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type ToAsserts<S extends AnyNoContext> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>\n\n  /**\n   * Any schema, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type Any = Schema<any, any, unknown>\n\n  /**\n   * Any schema with `Context = never`, except for `never`.\n   *\n   * @since 3.10.0\n   */\n  export type AnyNoContext = Schema<any, any, never>\n\n  /**\n   * Any schema, including `never`.\n   *\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>\n\n  /**\n   * Type-level counterpart of `Schema.asSchema` function.\n   *\n   * @since 3.10.0\n   */\n  export type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>\n}\n\n/**\n * The `encodedSchema` function allows you to extract the `Encoded` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without retaining any refinements or transformations that\n * were applied previously.\n *\n * @since 3.10.0\n */\nexport const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> => make(AST.encodedAST(schema.ast))\n\n/**\n * The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\n * the refinements up to the first transformation point in the original schema.\n *\n * @since 3.10.0\n */\nexport const encodedBoundSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> =>\n  make(AST.encodedBoundAST(schema.ast))\n\n/**\n * The `typeSchema` function allows you to extract the `Type` portion of a\n * schema, creating a new schema that conforms to the properties defined in the\n * original schema without considering the initial encoding or transformation\n * processes.\n *\n * @since 3.10.0\n */\nexport const typeSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<A> => make(AST.typeAST(schema.ast))\n\n/* c8 ignore start */\nexport {\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  asserts,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeSync,\n  /**\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category decoding\n   * @since 3.10.0\n   */\n  decodeUnknownSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeSync,\n  /**\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownOption,\n  /**\n   * @throws `ParseError`\n   * @category encoding\n   * @since 3.10.0\n   */\n  encodeUnknownSync,\n  /**\n   * By default the option `exact` is set to `true`.\n   *\n   * @category validation\n   * @since 3.10.0\n   */\n  is,\n  /**\n   * @category validation\n   * @since 3.10.0\n   */\n  validateOption,\n  /**\n   * @throws `ParseError`\n   * @category validation\n   * @since 3.10.0\n   */\n  validateSync\n} from \"./ParseResult.js\"\n/* c8 ignore end */\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const encodeUnknown = ParseResult.encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>\n    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>\n    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = encodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither\n\n/**\n * @category encoding\n * @since 3.10.0\n */\nexport const encodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknown = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const decodeUnknown = ParseResult.decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownEither = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeUnknownPromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = decodeUnknown(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decode: <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodeEither: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither\n\n/**\n * @category decoding\n * @since 3.10.0\n */\nexport const decodePromise: <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validate = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validate = ParseResult.validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>\n    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validateEither = <A, I, R>(\n  schema: Schema<A, I, R>,\n  options?: ParseOptions\n) => {\n  const validateEither = ParseResult.validateEither(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>\n    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)\n}\n\n/**\n * @category validation\n * @since 3.10.0\n */\nexport const validatePromise = <A, I>(\n  schema: Schema<A, I, never>,\n  options?: ParseOptions\n) => {\n  const parser = validate(schema, options)\n  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))\n}\n\n/**\n * Tests if a value is a `Schema`.\n *\n * @category guards\n * @since 3.10.0\n */\nexport const isSchema = (u: unknown): u is Schema.Any =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}\n\nconst getDefaultLiteralAST = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals\n) =>\n  AST.isMembers(literals)\n    ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))\n    : new AST.Literal(literals[0])\n\nconst makeLiteralClass = <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  literals: Literals,\n  ast: AST.AST = getDefaultLiteralAST(literals)\n): Literal<Literals> => (class LiteralClass extends make<Literals[number]>(ast) {\n  static override annotations(annotations: Annotations.Schema<Literals[number]>): Literal<Literals> {\n    return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations))\n  }\n  static literals = [...literals] as Literals\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Literal<Literals>\nexport function Literal(): Never\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]>\nexport function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(\n  ...literals: Literals\n): Schema<Literals[number]> | Never {\n  return array_.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never\n}\n\n/**\n * Creates a new `Schema` from a literal schema.\n *\n * @example\n * import * as Schema from \"effect/Schema\"\n * import { Either } from \"effect\"\n *\n * const schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n *\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\n * assert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\n * assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const pickLiteral =\n  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>\n  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): SchemaClass<S> => make(new AST.UniqueSymbol(symbol))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}\n\n/**\n * @since 3.10.0\n */\nexport type EnumsDefinition = { [x: string]: string | number }\n\nconst getDefaultEnumsAST = <A extends EnumsDefinition>(enums: A) =>\n  new AST.Enums(\n    Object.keys(enums).filter(\n      (key) => typeof enums[enums[key]] !== \"number\"\n    ).map((key) => [key, enums[key]])\n  )\n\nconst makeEnumsClass = <A extends EnumsDefinition>(\n  enums: A,\n  ast: AST.AST = getDefaultEnumsAST(enums)\n): Enums<A> => (class EnumsClass extends make<A[keyof A]>(ast) {\n  static override annotations(annotations: Annotations.Schema<A[keyof A]>) {\n    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static enums = { ...enums }\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Enums = <A extends EnumsDefinition>(enums: A): Enums<A> => makeEnumsClass(enums)\n\ntype Join<Params> = Params extends [infer Head, ...infer Tail] ?\n  `${(Head extends Schema<infer A> ? A : Head) & (AST.LiteralValue)}${Join<Tail>}`\n  : \"\"\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteral<A> extends SchemaClass<A> {}\n\ntype TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteral = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParameter>>(\n  ...[head, ...tail]: Params\n): TemplateLiteral<Join<Params>> => {\n  let astOrs: ReadonlyArray<AST.TemplateLiteral | string> = getTemplateLiterals(\n    getTemplateLiteralParameterAST(head)\n  )\n  for (const span of tail) {\n    astOrs = array_.flatMap(\n      astOrs,\n      (a) => getTemplateLiterals(getTemplateLiteralParameterAST(span)).map((b) => combineTemplateLiterals(a, b))\n    )\n  }\n  return make(AST.Union.make(astOrs.map((astOr) => Predicate.isString(astOr) ? new AST.Literal(astOr) : astOr)))\n}\n\nconst getTemplateLiteralParameterAST = (span: TemplateLiteralParameter): AST.AST =>\n  isSchema(span) ? span.ast : new AST.Literal(String(span))\n\nconst combineTemplateLiterals = (\n  a: AST.TemplateLiteral | string,\n  b: AST.TemplateLiteral | string\n): AST.TemplateLiteral | string => {\n  if (Predicate.isString(a)) {\n    return Predicate.isString(b) ?\n      a + b :\n      new AST.TemplateLiteral(a + b.head, b.spans)\n  }\n  if (Predicate.isString(b)) {\n    return new AST.TemplateLiteral(\n      a.head,\n      array_.modifyNonEmptyLast(\n        a.spans,\n        (span) => new AST.TemplateLiteralSpan(span.type, span.literal + b)\n      )\n    )\n  }\n  return new AST.TemplateLiteral(\n    a.head,\n    array_.appendAll(\n      array_.modifyNonEmptyLast(\n        a.spans,\n        (span) => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.head))\n      ),\n      b.spans\n    )\n  )\n}\n\nconst getTemplateLiterals = (\n  ast: AST.AST\n): ReadonlyArray<AST.TemplateLiteral | string> => {\n  switch (ast._tag) {\n    case \"Literal\":\n      return [String(ast.literal)]\n    case \"NumberKeyword\":\n    case \"StringKeyword\":\n      return [new AST.TemplateLiteral(\"\", [new AST.TemplateLiteralSpan(ast, \"\")])]\n    case \"Union\":\n      return array_.flatMap(ast.types, getTemplateLiterals)\n  }\n  throw new Error(errors_.getSchemaUnsupportedLiteralSpanErrorMessage(ast))\n}\n\ntype TemplateLiteralParserParameters = Schema.Any | AST.LiteralValue\n\ntype TemplateLiteralParserParametersType<T> = T extends [infer Head, ...infer Tail] ?\n  readonly [Head extends Schema<infer A, infer _I, infer _R> ? A : Head, ...TemplateLiteralParserParametersType<Tail>]\n  : []\n\ntype TemplateLiteralParserParametersEncoded<T> = T extends [infer Head, ...infer Tail] ? `${\n    & (Head extends Schema<infer _A, infer I, infer _R> ? I : Head)\n    & (AST.LiteralValue)}${TemplateLiteralParserParametersEncoded<Tail>}`\n  : \"\"\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>\n  extends\n    Schema<\n      TemplateLiteralParserParametersType<Params>,\n      TemplateLiteralParserParametersEncoded<Params>,\n      Schema.Context<Params[number]>\n    >\n{\n  readonly params: Params\n}\n\n/**\n * @category template literal\n * @since 3.10.0\n */\nexport const TemplateLiteralParser = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>(\n  ...params: Params\n): TemplateLiteralParser<Params> => {\n  const encodedSchemas: Array<Schema.Any> = []\n  const typeSchemas: Array<Schema.Any> = []\n  const numbers: Array<number> = []\n  for (let i = 0; i < params.length; i++) {\n    const p = params[i]\n    if (isSchema(p)) {\n      const encoded = encodedSchema(p)\n      if (AST.isNumberKeyword(encoded.ast)) {\n        numbers.push(i)\n      }\n      encodedSchemas.push(encoded)\n      typeSchemas.push(p)\n    } else {\n      const literal = Literal(p)\n      encodedSchemas.push(literal)\n      typeSchemas.push(literal)\n    }\n  }\n  const from = TemplateLiteral(...encodedSchemas as any)\n  const re = AST.getTemplateLiteralCapturingRegExp(from.ast as AST.TemplateLiteral)\n  return class TemplateLiteralParserClass extends transform(from, Tuple(...typeSchemas), {\n    strict: false,\n    decode: (s) => {\n      const out: Array<number | string> = re.exec(s)!.slice(1, params.length + 1)\n      for (let i = 0; i < numbers.length; i++) {\n        const index = numbers[i]\n        out[index] = Number(out[index])\n      }\n      return out\n    },\n    encode: (tuple) => tuple.join(\"\")\n  }) {\n    static params = params.slice()\n  } as any\n}\n\nconst declareConstructor = <\n  const TypeParameters extends ReadonlyArray<Schema.Any>,\n  I,\n  A\n>(\n  typeParameters: TypeParameters,\n  options: {\n    readonly decode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n    readonly encode: (\n      ...typeParameters: {\n        readonly [K in keyof TypeParameters]: Schema<\n          Schema.Type<TypeParameters[K]>,\n          Schema.Encoded<TypeParameters[K]>,\n          never\n        >\n      }\n    ) => (\n      input: unknown,\n      options: ParseOptions,\n      ast: AST.Declaration\n    ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n  },\n  annotations?: Annotations.Schema<A, TypeParameters>\n): SchemaClass<A, I, Schema.Context<TypeParameters[number]>> =>\n  make(\n    new AST.Declaration(\n      typeParameters.map((tp) => tp.ast),\n      (...typeParameters) => options.decode(...typeParameters.map(make) as any),\n      (...typeParameters) => options.encode(...typeParameters.map(make) as any),\n      toASTAnnotations(annotations)\n    )\n  )\n\nconst declarePrimitive = <A>(\n  is: (input: unknown) => input is A,\n  annotations?: Annotations.Schema<A>\n): SchemaClass<A> => {\n  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>\n    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))\n  const encodeUnknown = decodeUnknown\n  return make(new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))\n}\n\n/**\n * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const declare: {\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): SchemaClass<A>\n  /**\n   * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\n   * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.\n   *\n   * @category constructors\n   * @since 3.10.0\n   */\n  <const P extends ReadonlyArray<Schema.All>, I, A>(\n    typeParameters: P,\n    options: {\n      readonly decode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<A, ParseResult.ParseIssue, never>\n      readonly encode: (\n        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }\n      ) => (\n        input: unknown,\n        options: ParseOptions,\n        ast: AST.Declaration\n      ) => Effect.Effect<I, ParseResult.ParseIssue, never>\n    },\n    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>\n  ): SchemaClass<A, I, Schema.Context<P[number]>>\n} = function() {\n  if (Array.isArray(arguments[0])) {\n    const typeParameters = arguments[0]\n    const options = arguments[1]\n    const annotations = arguments[2]\n    return declareConstructor(typeParameters, options, annotations)\n  }\n  const is = arguments[0]\n  const annotations = arguments[1]\n  return declarePrimitive(is, annotations)\n} as any\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BrandSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Brand\")\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const fromBrand = <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(\n  constructor: Brand.Constructor<C>,\n  annotations?: Annotations.Filter<C, A>\n) =>\n<I, R>(self: Schema<A, I, R>): BrandSchema<A & C, I, R> =>\n  makeBrandClass<Schema<A & C, I, R>, string | symbol>(\n    new AST.Refinement(\n      self.ast,\n      function predicate(a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> {\n        const either = constructor.either(a)\n        return either_.isLeft(either) ?\n          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(\", \"))) :\n          option_.none()\n      },\n      toASTAnnotations({\n        schemaId: BrandSchemaId,\n        [BrandSchemaId]: { constructor },\n        ...annotations\n      })\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const InstanceOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/InstanceOf\")\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface instanceOf<A> extends AnnotableClass<instanceOf<A>, A> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A,\n  annotations?: Annotations.Schema<InstanceType<A>>\n): instanceOf<InstanceType<A>> =>\n  declare(\n    (u): u is InstanceType<A> => u instanceof constructor,\n    {\n      title: constructor.name,\n      description: `an instance of ${constructor.name}`,\n      pretty: (): pretty_.Pretty<InstanceType<A>> => String,\n      schemaId: InstanceOfSchemaId,\n      [InstanceOfSchemaId]: { constructor },\n      ...annotations\n    }\n  )\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Undefined extends make<undefined>(AST.undefinedKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Void extends make<void>(AST.voidKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Null extends make<null>(AST.null) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Never extends make<never>(AST.neverKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Unknown extends make<unknown>(AST.unknownKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class Any extends make<any>(AST.anyKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class BigIntFromSelf extends make<bigint>(AST.bigIntKeyword) {}\n\n/**\n * @category primitives\n * @since 3.10.0\n */\nexport class SymbolFromSelf extends make<symbol>(AST.symbolKeyword) {}\n\n/** @ignore */\nclass String$ extends make<string>(AST.stringKeyword) {}\n\n/** @ignore */\nclass Number$ extends make<number>(AST.numberKeyword) {}\n\n/** @ignore */\nclass Boolean$ extends make<boolean>(AST.booleanKeyword) {}\n\n/** @ignore */\nclass Object$ extends make<object>(AST.objectKeyword) {}\n\nexport {\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Boolean$ as Boolean,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Number$ as Number,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  Object$ as Object,\n  /**\n   * @category primitives\n   * @since 3.10.0\n   */\n  String$ as String\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Union<Members extends ReadonlyArray<Schema.All>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n  annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members>\n}\n\nconst getDefaultUnionAST = <Members extends AST.Members<Schema.All>>(members: Members): AST.AST =>\n  AST.Union.make(members.map((m) => m.ast))\n\nconst makeUnionClass = <Members extends AST.Members<Schema.All>>(\n  members: Members,\n  ast: AST.AST = getDefaultUnionAST(members)\n): Union<\n  Members\n> => (class UnionClass\n  extends make<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>(ast)\n{\n  static override annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members> {\n    return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static members = [...members]\n})\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport function Union<Members extends AST.Members<Schema.All>>(...members: Members): Union<Members>\nexport function Union<Member extends Schema.All>(member: Member): Member\nexport function Union(): typeof Never\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>\nexport function Union<Members extends ReadonlyArray<Schema.All>>(\n  ...members: Members\n) {\n  return AST.isMembers(members)\n    ? makeUnionClass(members)\n    : array_.isNonEmptyReadonlyArray(members)\n    ? members[0]\n    : Never\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullOr = <S extends Schema.All>(self: S): NullOr<S> => Union(self, Null)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const UndefinedOr = <S extends Schema.All>(self: S): UndefinedOr<S> => Union(self, Undefined)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const NullishOr = <S extends Schema.All>(self: S): NullishOr<S> => Union(self, Null, Undefined)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const keyof = <A, I, R>(self: Schema<A, I, R>): SchemaClass<keyof A> => make<keyof A>(AST.keyof(self.ast))\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Element {\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"\" | \"?\"\n}\n\n/**\n * @category API interface\n * @since 3.10.0\n */\nexport interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}\n\n/**\n * @since 3.10.0\n */\nexport const element = <S extends Schema.Any>(self: S): Element<S, \"\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, false), self)\n\n/**\n * @since 3.10.0\n */\nexport const optionalElement = <S extends Schema.Any>(self: S): Element<S, \"?\"> =>\n  new ElementImpl(new AST.OptionalType(self.ast, true), self)\n\nclass ElementImpl<S extends Schema.Any, Token extends Element.Token> implements Element<S, Token> {\n  readonly [TypeId]!: Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>[TypeId]\n  readonly _Token!: Token\n  constructor(\n    readonly ast: AST.OptionalType,\n    readonly from: S\n  ) {}\n  annotations(\n    annotations: Annotations.Schema<Schema.Type<S>>\n  ): ElementImpl<S, Token> {\n    return new ElementImpl(\n      new AST.OptionalType(\n        this.ast.type,\n        this.ast.isOptional,\n        { ...this.ast.annotations, ...toASTAnnotations(annotations) }\n      ),\n      this.from\n    )\n  }\n  toString() {\n    return `${this.ast.type}${this.ast.isOptional ? \"?\" : \"\"}`\n  }\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TupleType {\n  type ElementsType<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>\n    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>\n    : Out\n\n  type ElementsEncoded<\n    Elements,\n    Out extends ReadonlyArray<any> = readonly []\n  > = Elements extends readonly [infer Head, ...infer Tail] ?\n    Head extends Element<infer T, \"?\"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>\n    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>\n    : Out\n\n  /**\n   * @since 3.10.0\n   */\n  export type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, \"\">>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}\n\nconst getDefaultTupleTypeAST = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest\n) =>\n  new AST.TupleType(\n    elements.map((el) => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast),\n    rest.map((el) => isSchema(el) ? new AST.Type(el.ast) : el.ast),\n    true\n  )\n\nconst makeTupleTypeClass = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(\n  elements: Elements,\n  rest: Rest,\n  ast: AST.AST = getDefaultTupleTypeAST(elements, rest)\n) => (class TupleTypeClass extends make<\n  TupleType.Type<Elements, Rest>,\n  TupleType.Encoded<Elements, Rest>,\n  Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n>(ast) {\n  static override annotations(\n    annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>\n  ): TupleType<Elements, Rest> {\n    return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static elements = [...elements] as any as Elements\n\n  static rest = [...rest] as any as Rest\n})\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Tuple<\n  const Elements extends TupleType.Elements,\n  Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>\n>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>\nexport function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>\nexport function Tuple(...args: ReadonlyArray<any>): any {\n  return Array.isArray(args[0])\n    ? makeTupleTypeClass(args[0], args.slice(1))\n    : makeTupleTypeClass(args, [])\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}\n\nconst makeArrayClass = <Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): Array$<Value> => (class ArrayClass extends makeTupleTypeClass<[], [Value]>([], [value], ast) {\n  static override annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {\n    return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static value = value\n})\n\nconst Array$ = <Value extends Schema.Any>(value: Value): Array$<Value> => makeArrayClass(value)\n\nexport {\n  /**\n   * @category constructors\n   * @since 3.10.0\n   */\n  Array$ as Array\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArray<Value extends Schema.Any> extends TupleType<[Value], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>): NonEmptyArray<Value>\n}\n\nconst makeNonEmptyArrayClass = <Value extends Schema.Any>(\n  value: Value,\n  ast?: AST.AST\n): NonEmptyArray<\n  Value\n> => (class NonEmptyArrayClass extends makeTupleTypeClass<[Value], [Value]>([value], [value], ast) {\n  static override annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {\n    return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static value = value\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>\n  makeNonEmptyArrayClass(value)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ArrayEnsure<Value extends Schema.Any> extends\n  AnnotableClass<\n    ArrayEnsure<Value>,\n    ReadonlyArray<Schema.Type<Value>>,\n    Schema.Encoded<Value> | ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const ArrayEnsure = <Value extends Schema.Any>(value: Value): ArrayEnsure<Value> => {\n  const value_ = asSchema(value)\n  return class ArrayEnsureClass extends transform(Union(value_, Array$(value_)), Array$(typeSchema(value_)), {\n    strict: true,\n    decode: array_.ensure,\n    encode: (arr) => arr.length === 1 ? arr[0] : arr\n  }) {}\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyArrayEnsure<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyArrayEnsure<Value>,\n    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,\n    Schema.Encoded<Value> | array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const NonEmptyArrayEnsure = <Value extends Schema.Any>(value: Value): NonEmptyArrayEnsure<Value> => {\n  const value_ = asSchema(value)\n  return class NonEmptyArrayEnsureClass\n    extends transform(Union(value_, NonEmptyArray(value_)), NonEmptyArray(typeSchema(value_)), {\n      strict: true,\n      decode: array_.ensure as any,\n      encode: (arr) => arr.length === 1 ? arr[0] : arr\n    })\n  {}\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace PropertySignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Token = \"?:\" | \":\"\n\n  /**\n   * @since 3.10.0\n   */\n  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<\n    Token,\n    any,\n    Key,\n    Token,\n    any,\n    boolean,\n    unknown\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type All<Key extends PropertyKey = PropertyKey> =\n    | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>\n    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>\n    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type AST =\n    | PropertySignatureDeclaration\n    | PropertySignatureTransformation\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }\n}\n\nconst formatPropertySignatureToken = (isOptional: boolean): string => isOptional ? \"\\\"?:\\\"\" : \"\\\":\\\"\"\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureDeclaration extends AST.OptionalType {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureDeclaration\"\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    const token = formatPropertySignatureToken(this.isOptional)\n    const type = String(this.type)\n    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class FromPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class ToPropertySignature extends AST.OptionalType {\n  constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) {\n    super(type, isOptional, annotations)\n  }\n}\n\nconst formatPropertyKey = (p: PropertyKey | undefined): string => {\n  if (p === undefined) {\n    return \"never\"\n  }\n  if (Predicate.isString(p)) {\n    return JSON.stringify(p)\n  }\n  return String(p)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport class PropertySignatureTransformation {\n  /**\n   * @since 3.10.0\n   */\n  readonly _tag = \"PropertySignatureTransformation\"\n  constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) {}\n  /**\n   * @since 3.10.0\n   */\n  toString() {\n    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${\n      formatPropertyKey(this.from.fromKey)\n    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`\n  }\n}\n\nconst mergeSignatureAnnotations = (\n  ast: PropertySignature.AST,\n  annotations: AST.Annotations\n): PropertySignature.AST => {\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return new PropertySignatureDeclaration(\n        ast.type,\n        ast.isOptional,\n        ast.isReadonly,\n        { ...ast.annotations, ...annotations },\n        ast.defaultValue\n      )\n    }\n    case \"PropertySignatureTransformation\": {\n      return new PropertySignatureTransformation(\n        new FromPropertySignature(\n          ast.from.type,\n          ast.from.isOptional,\n          ast.from.isReadonly,\n          ast.from.annotations\n        ),\n        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {\n          ...ast.to.annotations,\n          ...annotations\n        }, ast.to.defaultValue),\n        ast.decode,\n        ast.encode\n      )\n    }\n  }\n}\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const PropertySignatureTypeId: unique symbol = Symbol.for(\"effect/PropertySignature\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type PropertySignatureTypeId = typeof PropertySignatureTypeId\n\n/**\n * @since 3.10.0\n * @category guards\n */\nexport const isPropertySignature = (u: unknown): u is PropertySignature.All =>\n  Predicate.hasProperty(u, PropertySignatureTypeId)\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}\n\nclass PropertySignatureImpl<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]\n  readonly [PropertySignatureTypeId] = null\n  readonly _TypeToken!: TypeToken\n  readonly _Key!: Key\n  readonly _EncodedToken!: EncodedToken\n  readonly _HasDefault!: HasDefault\n\n  constructor(\n    readonly ast: PropertySignature.AST\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)))\n  }\n\n  toString() {\n    return String(this.ast)\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const makePropertySignature = <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n>(ast: PropertySignature.AST) =>\n  new PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>(ast)\n\nclass PropertySignatureWithFromImpl<\n  From extends Schema.All,\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n  constructor(ast: PropertySignature.AST, readonly from: From) {\n    super(ast)\n  }\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignatureWithFromImpl<From, TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {\n    return new PropertySignatureWithFromImpl(\n      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)),\n      this.from\n    )\n  }\n}\n\n/**\n * @category API interface\n * @since 1.0.0\n */\nexport interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}\n\n/**\n * Lifts a `Schema` into a `PropertySignature`.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const propertySignature = <S extends Schema.All>(\n  self: S\n): propertySignature<S> =>\n  new PropertySignatureWithFromImpl(\n    new PropertySignatureDeclaration(self.ast, false, true, {}, undefined),\n    self\n  )\n\n/**\n * Enhances a property signature with a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withConstructorDefault: {\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    TypeToken extends PropertySignature.Token,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n  /**\n   * Enhances a property signature with a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    Key extends PropertyKey,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>\n} = dual(2, <\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  R\n>(\n  self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue)\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue),\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\nconst applyDefaultValue = <A>(o: option_.Option<A>, defaultValue: () => A) =>\n  option_.match(o, {\n    onNone: () => option_.some(defaultValue()),\n    onSome: (value) => option_.some(value === undefined ? defaultValue() : value)\n  })\n\n/**\n * Enhances a property signature with a default decoding value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDecodingDefault: {\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(defaultValue: () => Types.NoInfer<Type>): <\n    Key extends PropertyKey,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, HasDefault, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, HasDefault, R>\n  /**\n   * Enhances a property signature with a default decoding value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, HasDefault, R>,\n    defaultValue: () => Types.NoInfer<Type>\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n  defaultValue: () => Types.NoInfer<Type>\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast,\n          new ToPropertySignature(AST.typeAST(ast.type), false, true, {}, undefined),\n          (o) => applyDefaultValue(o, defaultValue),\n          identity\n        )\n      )\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          ast.from,\n          new ToPropertySignature(ast.to.type, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue),\n          (o) => applyDefaultValue(ast.decode(o), defaultValue),\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Enhances a property signature with a default decoding value and a default constructor value.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const withDefaults: {\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Type>(\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Type>\n    }\n  ): <\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>\n  ) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n  /**\n   * Enhances a property signature with a default decoding value and a default constructor value.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    Key extends PropertyKey,\n    Encoded,\n    R\n  >(\n    self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n    defaults: {\n      constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n      decoding: () => Types.NoInfer<Type>\n    }\n  ): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>\n} = dual(2, <\n  Type,\n  Key extends PropertyKey,\n  Encoded,\n  R\n>(\n  self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>,\n  defaults: {\n    constructor: () => Types.NoInfer<Exclude<Type, undefined>>\n    decoding: () => Types.NoInfer<Type>\n  }\n): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R> =>\n  self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)))\n\n/**\n * Enhances a property signature by specifying a different key for it in the Encoded type.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const fromKey: {\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <Key extends PropertyKey>(key: Key): <\n    TypeToken extends PropertySignature.Token,\n    Type,\n    EncodedToken extends PropertySignature.Token,\n    Encoded,\n    HasDefault extends boolean,\n    R\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>\n  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n  /**\n   * Enhances a property signature by specifying a different key for it in the Encoded type.\n   *\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <\n    Type,\n    TypeToken extends PropertySignature.Token,\n    Encoded,\n    EncodedToken extends PropertySignature.Token,\n    HasDefault extends boolean,\n    R,\n    Key extends PropertyKey\n  >(\n    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n    key: Key\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n} = dual(2, <\n  Type,\n  TypeToken extends PropertySignature.Token,\n  Encoded,\n  EncodedToken extends PropertySignature.Token,\n  HasDefault extends boolean,\n  R,\n  Key extends PropertyKey\n>(\n  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,\n  key: Key\n): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> => {\n  const ast = self.ast\n  switch (ast._tag) {\n    case \"PropertySignatureDeclaration\": {\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.type,\n            ast.isOptional,\n            ast.isReadonly,\n            ast.annotations,\n            key\n          ),\n          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue),\n          identity,\n          identity\n        )\n      )\n    }\n    case \"PropertySignatureTransformation\":\n      return makePropertySignature(\n        new PropertySignatureTransformation(\n          new FromPropertySignature(\n            ast.from.type,\n            ast.from.isOptional,\n            ast.from.isReadonly,\n            ast.from.annotations,\n            key\n          ),\n          ast.to,\n          ast.decode,\n          ast.encode\n        )\n      )\n  }\n})\n\n/**\n * Converts an optional property to a required one through a transformation `Option -> Type`.\n *\n * - `decode`: `none` as argument means the value is missing in the input.\n * - `encode`: `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToRequired = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => TI\n    readonly encode: (ti: TI) => option_.Option<FA>\n  }\n): PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, false, true, {}, undefined),\n      (o) => option_.some(options.decode(o)),\n      option_.flatMap(options.encode)\n    )\n  )\n\n/**\n * Converts an optional property to a required one through a transformation `Type -> Option`.\n *\n * - `decode`: `none` as return value means the value will be missing in the output.\n * - `encode`: `none` as argument means the value is missing in the input.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const requiredToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (fa: FA) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => FA\n  }\n): PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, false, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      option_.flatMap(options.decode),\n      (o) => option_.some(options.encode(o))\n    )\n  )\n\n/**\n * Converts an optional property to another optional property through a transformation `Option -> Option`.\n *\n * - `decode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n * - `encode`:\n *   - `none` as argument means the value is missing in the input.\n *   - `none` as return value means the value will be missing in the output.\n *\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalToOptional = <FA, FI, FR, TA, TI, TR>(\n  from: Schema<FA, FI, FR>,\n  to: Schema<TA, TI, TR>,\n  options: {\n    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>\n    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>\n  }\n): PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR> =>\n  makePropertySignature(\n    new PropertySignatureTransformation(\n      new FromPropertySignature(from.ast, true, true, {}, undefined),\n      new ToPropertySignature(to.ast, true, true, {}, undefined),\n      options.decode,\n      options.encode\n    )\n  )\n\n/**\n * @since 3.10.0\n */\nexport type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface optionalWith<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWith<S, Options>\n}\n\nconst optionalPropertySignatureAST = <A, I, R>(\n  self: Schema<A, I, R>,\n  options?: {\n    readonly exact?: true\n    readonly default?: () => A\n    readonly nullable?: true\n    readonly as?: \"Option\"\n    readonly onNoneEncoding?: () => option_.Option<never>\n  }\n): PropertySignature.AST => {\n  const isExact = options?.exact\n  const defaultValue = options?.default\n  const isNullable = options?.nullable\n  const asOption = options?.as == \"Option\"\n  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity\n\n  if (isExact) {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            self,\n            typeSchema(self),\n            { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotNull<A | null>),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          self,\n          OptionFromSelf(typeSchema(self)),\n          { decode: identity, encode: identity }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullOr(self),\n          typeSchema(self),\n          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined)\n      }\n    }\n  } else {\n    if (defaultValue) {\n      if (isNullable) {\n        return withConstructorDefault(\n          optionalToRequired(\n            NullishOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      } else {\n        return withConstructorDefault(\n          optionalToRequired(\n            UndefinedOr(self),\n            typeSchema(self),\n            {\n              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),\n              encode: option_.some\n            }\n          ),\n          defaultValue\n        ).ast\n      }\n    } else if (asOption) {\n      if (isNullable) {\n        return optionalToRequired(\n          NullishOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter<A | null | undefined, A>((a): a is A => a != null),\n            encode: asOptionEncode\n          }\n        ).ast\n      } else {\n        return optionalToRequired(\n          UndefinedOr(self),\n          OptionFromSelf(typeSchema(self)),\n          {\n            decode: option_.filter(Predicate.isNotUndefined<A | undefined>),\n            encode: asOptionEncode\n          }\n        ).ast\n      }\n    } else {\n      if (isNullable) {\n        return optionalToOptional(\n          NullishOr(self),\n          UndefinedOr(typeSchema(self)),\n          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }\n        ).ast\n      } else {\n        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined)\n      }\n    }\n  }\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optional = <S extends Schema.All>(self: S): optional<S> => {\n  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword\n    ? AST.undefinedKeyword\n    : UndefinedOr(self).ast\n  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self)\n}\n\n/**\n * @category PropertySignature\n * @since 3.10.0\n */\nexport const optionalWith: {\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    options: Options\n  ): (self: S) => optionalWith<S, Options>\n  /**\n   * @category PropertySignature\n   * @since 3.10.0\n   */\n  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(\n    self: S,\n    options: Options\n  ): optionalWith<S, Options>\n} = dual((args) => isSchema(args[0]), (self, options) => {\n  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self)\n})\n\n/**\n * @since 3.10.0\n */\nexport declare namespace Struct {\n  /**\n   * @since 3.10.0\n   */\n  export type Fields = {\n    readonly [x: PropertyKey]:\n      | Schema.All\n      | PropertySignature.All\n  }\n\n  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :\n    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :\n    K\n\n  type EncodedTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, any, PropertyKey, \"?:\", never, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", any, boolean, unknown>\n      | PropertySignature<PropertySignature.Token, never, PropertyKey, \"?:\", never, boolean, unknown> ? K\n      : never\n  }[keyof Fields]\n\n  type TypeTokenKeys<Fields extends Struct.Fields> = {\n    [K in keyof Fields]: Fields[K] extends OptionalPropertySignature ? K : never\n  }[keyof Fields]\n\n  type OptionalPropertySignature =\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", any, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, any, boolean, unknown>\n    | PropertySignature<\"?:\", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<F extends Fields> =\n    & { readonly [K in Exclude<keyof F, EncodedTokenKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedTokenKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<F extends Fields> = Schema.Context<F[keyof F]>\n\n  type PropertySignatureWithDefault =\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown>\n    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<F extends Fields> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalPropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace IndexSignature {\n  /**\n   * @since 3.10.0\n   */\n  export type Record = { readonly key: Schema.All; readonly value: Schema.All }\n\n  /**\n   * @since 3.10.0\n   */\n  export type Records = ReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Type<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<\n    Records extends IndexSignature.Records\n  > = Types.UnionToIntersection<\n    {\n      [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }[number]\n  >\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<Records extends IndexSignature.Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TypeLiteral {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Type<Fields>\n    & IndexSignature.Type<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>\n\n  /**\n   * @since 3.10.0\n   */\n  export type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> =\n    & Struct.Constructor<Fields>\n    & IndexSignature.Type<Records>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}\n\nconst getDefaultTypeLiteralAST = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(fields: Fields, records: Records) => {\n  const ownKeys = util_.ownKeys(fields)\n  const pss: Array<AST.PropertySignature> = []\n  if (ownKeys.length > 0) {\n    const from: Array<AST.PropertySignature> = []\n    const to: Array<AST.PropertySignature> = []\n    const transformations: Array<AST.PropertySignatureTransformation> = []\n    for (let i = 0; i < ownKeys.length; i++) {\n      const key = ownKeys[i]\n      const field = fields[key]\n      if (isPropertySignature(field)) {\n        const ast: PropertySignature.AST = field.ast\n        switch (ast._tag) {\n          case \"PropertySignatureDeclaration\": {\n            const type = ast.type\n            const isOptional = ast.isOptional\n            const toAnnotations = ast.annotations\n            from.push(new AST.PropertySignature(key, type, isOptional, true))\n            to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))\n            pss.push(\n              new AST.PropertySignature(key, type, isOptional, true, toAnnotations)\n            )\n            break\n          }\n          case \"PropertySignatureTransformation\": {\n            const fromKey = ast.from.fromKey ?? key\n            from.push(\n              new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)\n            )\n            to.push(\n              new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)\n            )\n            transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))\n            break\n          }\n        }\n      } else {\n        from.push(new AST.PropertySignature(key, field.ast, false, true))\n        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))\n        pss.push(new AST.PropertySignature(key, field.ast, false, true))\n      }\n    }\n    if (array_.isNonEmptyReadonlyArray(transformations)) {\n      const issFrom: Array<AST.IndexSignature> = []\n      const issTo: Array<AST.IndexSignature> = []\n      for (const r of records) {\n        const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n        propertySignatures.forEach((ps) => {\n          from.push(ps)\n          to.push(\n            new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)\n          )\n        })\n        indexSignatures.forEach((is) => {\n          issFrom.push(is)\n          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))\n        })\n      }\n      return new AST.Transformation(\n        new AST.TypeLiteral(from, issFrom, { [AST.TitleAnnotationId]: \"Struct (Encoded side)\" }),\n        new AST.TypeLiteral(to, issTo, { [AST.TitleAnnotationId]: \"Struct (Type side)\" }),\n        new AST.TypeLiteralTransformation(transformations)\n      )\n    }\n  }\n  const iss: Array<AST.IndexSignature> = []\n  for (const r of records) {\n    const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)\n    propertySignatures.forEach((ps) => pss.push(ps))\n    indexSignatures.forEach((is) => iss.push(is))\n  }\n  return new AST.TypeLiteral(pss, iss)\n}\n\nconst lazilyMergeDefaults = (\n  fields: Struct.Fields,\n  out: Record<PropertyKey, unknown>\n): { [x: string | symbol]: unknown } => {\n  const ownKeys = util_.ownKeys(fields)\n  for (const key of ownKeys) {\n    const field = fields[key]\n    if (out[key] === undefined && isPropertySignature(field)) {\n      const ast = field.ast\n      const defaultValue = ast._tag === \"PropertySignatureDeclaration\" ? ast.defaultValue : ast.to.defaultValue\n      if (defaultValue !== undefined) {\n        out[key] = defaultValue()\n      }\n    }\n  }\n  return out\n}\n\nconst makeTypeLiteralClass = <\n  Fields extends Struct.Fields,\n  const Records extends IndexSignature.Records\n>(\n  fields: Fields,\n  records: Records,\n  ast: AST.AST = getDefaultTypeLiteralAST(fields, records)\n): TypeLiteral<Fields, Records> => {\n  return class TypeLiteralClass extends make<\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >(ast) {\n    static override annotations(\n      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n    ): TypeLiteral<Fields, Records> {\n      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations))\n    }\n\n    static fields = { ...fields }\n\n    static records = [...records] as Records\n\n    static make = (\n      props: Simplify<TypeLiteral.Constructor<Fields, Records>>,\n      options?: MakeOptions\n    ): Simplify<TypeLiteral.Type<Fields, Records>> => {\n      const propsWithDefaults: any = lazilyMergeDefaults(fields, { ...props as any })\n      return getDisableValidationMakeOption(options)\n        ? propsWithDefaults\n        : ParseResult.validateSync(this)(propsWithDefaults)\n    }\n\n    static pick(...keys: Array<keyof Fields>): Struct<Simplify<Pick<Fields, typeof keys[number]>>> {\n      return Struct(struct_.pick(fields, ...keys) as any)\n    }\n\n    static omit(...keys: Array<keyof Fields>): Struct<Simplify<Omit<Fields, typeof keys[number]>>> {\n      return Struct(struct_.omit(fields, ...keys) as any)\n    }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records>\nexport function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>\nexport function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(\n  fields: Fields,\n  ...records: Records\n): TypeLiteral<Fields, Records> {\n  return makeTypeLiteralClass(fields, records)\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}\n\n/**\n * Returns a property signature that represents a tag.\n * A tag is a literal value that is used to distinguish between different types of objects.\n * The tag is optional when using the `make` method.\n *\n * @see {@link TaggedStruct}\n *\n * @example\n * import { Schema } from \"effect\"\n *\n * const User = Schema.Struct({\n *   _tag: Schema.tag(\"User\"),\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n *\n * @since 3.10.0\n */\nexport const tag = <Tag extends AST.LiteralValue>(tag: Tag): tag<Tag> =>\n  Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>\n\n/**\n * A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n *\n * The tag is optional when using the `make` method.\n *\n * @example\n * import { Schema } from \"effect\"\n *\n * const User = Schema.TaggedStruct(\"User\", {\n *   name: Schema.String,\n *   age: Schema.Number\n * })\n *\n * assert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const TaggedStruct = <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(\n  value: Tag,\n  fields: Fields\n): TaggedStruct<Tag, Fields> => Struct({ _tag: tag(value), ...fields })\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Record$<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{ key: K; value: V }]> {\n  readonly key: K\n  readonly value: V\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ): Record$<K, V>\n}\n\nconst makeRecordClass = <K extends Schema.All, V extends Schema.All>(\n  key: K,\n  value: V,\n  ast?: AST.AST\n): Record$<K, V> => (class RecordClass extends makeTypeLiteralClass({}, [{ key, value }], ast) {\n  static override annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ) {\n    return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static key = key\n\n  static value = value\n})\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const Record = <K extends Schema.All, V extends Schema.All>(\n  options: { readonly key: K; readonly value: V }\n): Record$<K, V> => makeRecordClass(options.key, options.value)\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R> => make(AST.pick(self.ast, keys))\n\n/**\n * @category struct transformations\n * @since 3.10.0\n */\nexport const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>\n<R>(\n  self: Schema<A, I, R>\n): SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R> => make(AST.omit(self.ast, keys))\n\n/**\n * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n *\n * @example\n * import * as Schema from \"effect/Schema\"\n *\n * // ---------------------------------------------\n * // use case: pull out a single field from a\n * // struct through a transformation\n * // ---------------------------------------------\n *\n * const mytable = Schema.Struct({\n *   column1: Schema.NumberFromString,\n *   column2: Schema.Number\n * })\n *\n * // const pullOutColumn: S.Schema<number, {\n * //     readonly column1: string;\n * // }, never>\n * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n *\n * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n *\n * @category struct transformations\n * @since 3.10.0\n */\nexport const pluck: {\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, K extends keyof A & keyof I>(\n    key: K\n  ): <R>(schema: Schema<A, I, R>) => Schema<A[K], { readonly [P in K]: I[P] }, R>\n  /**\n   * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n   * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n   *\n   * @example\n   * import * as Schema from \"effect/Schema\"\n   *\n   * // ---------------------------------------------\n   * // use case: pull out a single field from a\n   * // struct through a transformation\n   * // ---------------------------------------------\n   *\n   * const mytable = Schema.Struct({\n   *   column1: Schema.NumberFromString,\n   *   column2: Schema.Number\n   * })\n   *\n   * // const pullOutColumn: S.Schema<number, {\n   * //     readonly column1: string;\n   * // }, never>\n   * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n   *\n   * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n   * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n   *\n   * @category struct transformations\n   * @since 3.10.0\n   */\n  <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): Schema<A[K], { readonly [P in K]: I[P] }, R>\n} = dual(\n  2,\n  <A, I, R, K extends keyof A & keyof I>(\n    schema: Schema<A, I, R>,\n    key: K\n  ): Schema<A[K], Pick<I, K>, R> => {\n    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)\n    const value = make<\n      /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      A[K], /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      A[K], /**\n       * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\n       * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.\n       *\n       * @example\n       * import * as Schema from \"effect/Schema\"\n       *\n       * // ---------------------------------------------\n       * // use case: pull out a single field from a\n       * // struct through a transformation\n       * // ---------------------------------------------\n       *\n       * const mytable = Schema.Struct({\n       *   column1: Schema.NumberFromString,\n       *   column2: Schema.Number\n       * })\n       *\n       * // const pullOutColumn: S.Schema<number, {\n       * //     readonly column1: string;\n       * // }, never>\n       * const pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n       *\n       * console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n       * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n       *\n       * @category struct transformations\n       * @since 3.10.0\n       */\n      R\n    >(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)\n    return transform(\n      schema.pipe(pick(key)),\n      value,\n      {\n        strict: true,\n        decode: (a: any) => a[key],\n        encode: (ak) => ps.isOptional && ak === undefined ? {} : { [key]: ak } as any\n      }\n    )\n  }\n)\n\n/**\n * @category branding\n * @since 3.10.0\n */\nexport interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}\n\nconst makeBrandClass = <S extends Schema.Any, B extends string | symbol>(\n  ast: AST.AST\n): brand<S, B> => (class BrandClass extends make<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>(ast) {\n  static override annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B> {\n    return makeBrandClass(mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static make = (a: Brand.Unbranded<Schema.Type<S> & Brand<B>>, options?: MakeOptions): Schema.Type<S> & Brand<B> => {\n    return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n  }\n})\n\n/**\n * Returns a nominal branded schema by applying a brand to a given schema.\n *\n * ```\n * Schema<A> + B -> Schema<A & Brand<B>>\n * ```\n *\n * @param self - The input schema to be combined with the brand.\n * @param brand - The brand to apply.\n *\n * @example\n * import * as Schema from \"effect/Schema\"\n *\n * const Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\n * type Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n *\n * @category branding\n * @since 3.10.0\n */\nexport const brand = <S extends Schema.AnyNoContext, B extends string | symbol>(\n  brand: B,\n  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>\n) =>\n(self: S): brand<S, B> => {\n  const annotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {\n    onNone: () => [brand],\n    onSome: (brands) => [...brands, brand]\n  })\n  const ast = AST.annotations(\n    self.ast,\n    toASTAnnotations({\n      // add a default title annotation containing the brand\n      title: String(self.ast) + ` & Brand<${util_.formatUnknown(brand)}>`,\n      ...annotations,\n      [AST.BrandAnnotationId]: annotation\n    })\n  )\n  return makeBrandClass(ast)\n}\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partial = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]?: A[K] | undefined }, { [K in keyof I]?: I[K] | undefined }, R> =>\n  make(AST.partial(self.ast))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const partialWith: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <const Options extends { readonly exact: true }>(options: Options): <A, I, R>(\n    self: Schema<A, I, R>\n  ) => SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, const Options extends { readonly exact: true } | undefined>(\n    self: Schema<A, I, R>,\n    options: Options\n  ): SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>\n} = dual((args) => isSchema(args[0]), <A, I, R>(\n  self: Schema<A, I, R>,\n  options: { readonly exact: true }\n): SchemaClass<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const required = <A, I, R>(\n  self: Schema<A, I, R>\n): SchemaClass<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}\n\n/**\n * Creates a new schema with shallow mutability applied to its properties.\n *\n * @param schema - The original schema to make properties mutable (shallowly).\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))\n\nconst intersectTypeLiterals = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.TypeLiteral => {\n  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {\n    const propertySignatures = [...x.propertySignatures]\n    for (const ps of y.propertySignatures) {\n      const name = ps.name\n      const i = propertySignatures.findIndex((ps) => ps.name === name)\n      if (i === -1) {\n        propertySignatures.push(ps)\n      } else {\n        const { isOptional, type } = propertySignatures[i]\n        propertySignatures[i] = new AST.PropertySignature(\n          name,\n          extendAST(type, ps.type, path.concat(name)),\n          isOptional,\n          true\n        )\n      }\n    }\n    return new AST.TypeLiteral(\n      propertySignatures,\n      x.indexSignatures.concat(y.indexSignatures)\n    )\n  }\n  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n}\n\nconst preserveRefinementAnnotations = AST.blackListAnnotations([\n  AST.IdentifierAnnotationId\n])\n\nconst addRefinementToMembers = (refinement: AST.Refinement, asts: ReadonlyArray<AST.AST>): Array<AST.Refinement> =>\n  asts.map((ast) => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)))\n\nconst extendAST = (\n  x: AST.AST,\n  y: AST.AST,\n  path: ReadonlyArray<PropertyKey>\n): AST.AST => AST.Union.make(intersectUnionMembers([x], [y], path))\n\nconst getTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => AST.isUnion(ast) ? ast.types : [ast]\n\nconst intersectUnionMembers = (\n  xs: ReadonlyArray<AST.AST>,\n  ys: ReadonlyArray<AST.AST>,\n  path: ReadonlyArray<PropertyKey>\n): Array<AST.AST> =>\n  array_.flatMap(xs, (x) =>\n    array_.flatMap(ys, (y) => {\n      switch (y._tag) {\n        case \"Literal\": {\n          if (\n            (Predicate.isString(y.literal) && AST.isStringKeyword(x) ||\n              (Predicate.isNumber(y.literal) && AST.isNumberKeyword(x)) ||\n              (Predicate.isBoolean(y.literal) && AST.isBooleanKeyword(x)))\n          ) {\n            return [y]\n          }\n          break\n        }\n        case \"StringKeyword\": {\n          if (y === AST.stringKeyword) {\n            if (AST.isStringKeyword(x) || (AST.isLiteral(x) && Predicate.isString(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.stringKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"NumberKeyword\": {\n          if (y === AST.numberKeyword) {\n            if (AST.isNumberKeyword(x) || (AST.isLiteral(x) && Predicate.isNumber(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.numberKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"BooleanKeyword\": {\n          if (y === AST.booleanKeyword) {\n            if (AST.isBooleanKeyword(x) || (AST.isLiteral(x) && Predicate.isBoolean(x.literal))) {\n              return [x]\n            } else if (AST.isRefinement(x)) {\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            }\n          } else if (x === AST.booleanKeyword) {\n            return [y]\n          }\n          break\n        }\n        case \"Union\":\n          return intersectUnionMembers(getTypes(x), y.types, path)\n        case \"Suspend\":\n          return [new AST.Suspend(() => extendAST(x, y.f(), path))]\n        case \"Refinement\":\n          return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path))\n        case \"TypeLiteral\": {\n          switch (x._tag) {\n            case \"Union\":\n              return intersectUnionMembers(x.types, [y], path)\n            case \"Suspend\":\n              return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n            case \"Refinement\":\n              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n            case \"TypeLiteral\":\n              return [intersectTypeLiterals(x, y, path)]\n            case \"Transformation\": {\n              if (AST.isTypeLiteralTransformation(x.transformation)) {\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x.from, y, path),\n                    intersectTypeLiterals(x.to, AST.typeAST(y), path),\n                    new AST.TypeLiteralTransformation(\n                      x.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              }\n              break\n            }\n          }\n          break\n        }\n        case \"Transformation\": {\n          if (AST.isTypeLiteralTransformation(y.transformation)) {\n            switch (x._tag) {\n              case \"Union\":\n                return intersectUnionMembers(x.types, [y], path)\n              case \"Suspend\":\n                return [new AST.Suspend(() => extendAST(x.f(), y, path))]\n              case \"Refinement\":\n                return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))\n              case \"TypeLiteral\":\n                return [\n                  new AST.Transformation(\n                    intersectTypeLiterals(x, y.from, path),\n                    intersectTypeLiterals(AST.typeAST(x), y.to, path),\n                    new AST.TypeLiteralTransformation(\n                      y.transformation.propertySignatureTransformations\n                    )\n                  )\n                ]\n              case \"Transformation\":\n                {\n                  if (AST.isTypeLiteralTransformation(x.transformation)) {\n                    return [\n                      new AST.Transformation(\n                        intersectTypeLiterals(x.from, y.from, path),\n                        intersectTypeLiterals(x.to, y.to, path),\n                        new AST.TypeLiteralTransformation(\n                          y.transformation.propertySignatureTransformations.concat(\n                            x.transformation.propertySignatureTransformations\n                          )\n                        )\n                      )\n                    ]\n                  }\n                }\n                break\n            }\n          }\n          break\n        }\n      }\n      throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))\n    }))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}\n\n/**\n * Extends a schema with another schema.\n *\n * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n *\n * Possible extensions include:\n * - `Schema.String` with another `Schema.String` refinement or a string literal\n * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n * - A struct with another struct where overlapping fields support extension\n * - A struct with in index signature\n * - A struct with a union of supported schemas\n * - A refinement of a struct with a supported schema\n * - A suspend of a struct with a supported schema\n *\n * @example\n * import * as Schema from \"effect/Schema\"\n *\n * const schema = Schema.Struct({\n *   a: Schema.String,\n *   b: Schema.String\n * })\n *\n * // const extended: Schema<\n * //   {\n * //     readonly a: string\n * //     readonly b: string\n * //   } & {\n * //     readonly c: string\n * //   } & {\n * //     readonly [x: string]: string\n * //   }\n * // >\n * const extended = Schema.asSchema(schema.pipe(\n *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n * ))\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const extend: {\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   *\n   * @example\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>\n  /**\n   * Extends a schema with another schema.\n   *\n   * Not all extensions are supported, and their support depends on the nature of the involved schemas.\n   *\n   * Possible extensions include:\n   * - `Schema.String` with another `Schema.String` refinement or a string literal\n   * - `Schema.Number` with another `Schema.Number` refinement or a number literal\n   * - `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n   * - A struct with another struct where overlapping fields support extension\n   * - A struct with in index signature\n   * - A struct with a union of supported schemas\n   * - A refinement of a struct with a supported schema\n   * - A suspend of a struct with a supported schema\n   *\n   * @example\n   * import * as Schema from \"effect/Schema\"\n   *\n   * const schema = Schema.Struct({\n   *   a: Schema.String,\n   *   b: Schema.String\n   * })\n   *\n   * // const extended: Schema<\n   * //   {\n   * //     readonly a: string\n   * //     readonly b: string\n   * //   } & {\n   * //     readonly c: string\n   * //   } & {\n   * //     readonly [x: string]: string\n   * //   }\n   * // >\n   * const extended = Schema.asSchema(schema.pipe(\n   *   Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n   *   Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n   * ))\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>\n} = dual(\n  2,\n  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That) => make(extendAST(self.ast, that.ast, []))\n)\n\n/**\n * @category combinators\n * @since 3.10.0\n */\nexport const compose: {\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C extends B, R2, B>(to: Schema<D, C, R2>): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C, R2>(to: Schema<D, C, R2>): <B extends C, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <C, B, R2>(\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): <A, R1>(from: Schema<B, A, R1>) => SchemaClass<C, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <D, C, R2>(\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): <B, A, R1>(from: Schema<B, A, R1>) => SchemaClass<D, A, R1 | R2>\n\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, D, C extends B, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B extends C, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<C, B, R2>,\n    options?: { readonly strict: true }\n  ): SchemaClass<C, A, R1 | R2>\n  /**\n   * @category combinators\n   * @since 3.10.0\n   */\n  <B, A, R1, D, C, R2>(\n    from: Schema<B, A, R1>,\n    to: Schema<D, C, R2>,\n    options: { readonly strict: false }\n  ): SchemaClass<D, A, R1 | R2>\n} = dual(\n  (args) => isSchema(args[1]),\n  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2> =>\n    make(AST.compose(from.ast, to.ast))\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}\n\n/**\n * @category constructors\n * @since 3.10.0\n */\nexport const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const RefineSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Refine\")\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport type RefineSchemaId = typeof RefineSchemaId\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  readonly [RefineSchemaId]: From // required for `type HasFields = ...`\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}\n\nconst makeRefineClass = <From extends Schema.Any, A>(\n  from: From,\n  filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>,\n  ast: AST.AST\n): refine<A, From> => (class RefineClass extends make<A, Schema.Encoded<From>, Schema.Context<From>>(ast) {\n  static override annotations(annotations: Annotations.Schema<A>): refine<A, From> {\n    return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations))\n  }\n\n  static [RefineSchemaId] = from\n\n  static from = from\n\n  static filter = filter\n\n  static make = (a: Schema.Type<From>, options?: MakeOptions): A => {\n    return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)\n  }\n})\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}\n\nconst fromFilterPredicateReturnTypeItem = (\n  item: FilterOutput,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (Predicate.isBoolean(item)) {\n    return item\n      ? option_.none()\n      : option_.some(new ParseResult.Type(ast, input))\n  }\n  if (Predicate.isString(item)) {\n    return option_.some(new ParseResult.Type(ast, input, item))\n  }\n  if (item !== undefined) {\n    if (\"_tag\" in item) {\n      return option_.some(item)\n    }\n    const issue = new ParseResult.Type(ast, input, item.message)\n    return option_.some(\n      array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue\n    )\n  }\n  return option_.none()\n}\n\nconst toFilterParseIssue = (\n  out: FilterReturnType,\n  ast: AST.Refinement | AST.Transformation,\n  input: unknown\n): option_.Option<ParseResult.ParseIssue> => {\n  if (util_.isSingle(out)) {\n    return fromFilterPredicateReturnTypeItem(out, ast, input)\n  }\n  if (array_.isNonEmptyReadonlyArray(out)) {\n    const issues = array_.filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input))\n    if (array_.isNonEmptyReadonlyArray(issues)) {\n      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues))\n    }\n  }\n  return option_.none()\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue\n\ntype FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>\n\n/**\n * @category filtering\n * @since 3.10.0\n */\nexport function filter<C extends A, B extends A, A = C>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<C & B, C>\n): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>\nexport function filter<A, B extends A>(\n  refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B,\n  annotations?: Annotations.Filter<B, A>\n): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>\nexport function filter<S extends Schema.Any>(\n  predicate: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>\n): (self: S) => filter<S>\nexport function filter<A>(\n  predicate: (\n    a: A,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => FilterReturnType,\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => refine<A, Schema<A, I, R>> {\n  return <I, R>(self: Schema<A, I, R>) => {\n    function filter(input: A, options: AST.ParseOptions, ast: AST.Refinement) {\n      return toFilterParseIssue(predicate(input, options, ast), ast, input)\n    }\n    const ast = new AST.Refinement(\n      self.ast,\n      filter,\n      toASTAnnotations(annotations)\n    )\n    return makeRefineClass(self, filter, ast)\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}\n\n/**\n * @category transformations\n * @since 3.10.0\n */\nexport const filterEffect: {\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, FD>(\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, FD>\n  ): (self: S) => filterEffect<S, FD>\n  /**\n   * @category transformations\n   * @since 3.10.0\n   */\n  <S extends Schema.Any, RD>(\n    self: S,\n    f: (\n      a: Types.NoInfer<Schema.Type<S>>,\n      options: ParseOptions,\n      self: AST.Transformation\n    ) => Effect.Effect<FilterReturnType, never, RD>\n  ): filterEffect<S, RD>\n} = dual(2, <S extends Schema.Any, FD>(\n  self: S,\n  f: (\n    a: Types.NoInfer<Schema.Type<S>>,\n    options: ParseOptions,\n    self: AST.Transformation\n  ) => Effect.Effect<FilterReturnType, never, FD>\n): filterEffect<S, FD> =>\n  transformOrFail(\n    self,\n    typeSchema(self),\n    {\n      strict: true,\n      decode: (a, options, ast) =>\n        ParseResult.flatMap(\n          f(a, options, ast),\n          (filterReturnType) =>\n            option_.match(toFilterParseIssue(filterReturnType, ast, a), {\n              onNone: () => ParseResult.succeed(a),\n              onSome: ParseResult.fail\n            })\n        ),\n      encode: ParseResult.succeed\n    }\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformOrFail<From extends Schema.Any, To extends Schema.Any, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}\n\nconst makeTransformationClass = <From extends Schema.Any, To extends Schema.Any, R>(\n  from: From,\n  to: To,\n  ast: AST.AST\n): transformOrFail<\n  From,\n  To,\n  R\n> => (class TransformationClass\n  extends make<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>(ast)\n{\n  static override annotations(annotations: Annotations.Schema<Schema.Type<To>>) {\n    return makeTransformationClass<From, To, R>(\n      this.from,\n      this.to,\n      mergeSchemaAnnotations(this.ast, annotations)\n    )\n  }\n\n  static from = from\n\n  static to = to\n})\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided decoding functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transformOrFail: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): (from: From) => transformOrFail<From, To, RD | RE>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided decoding functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any, RD, RE>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>\n      readonly strict?: true\n    } | {\n      readonly decode: (\n        fromA: Schema.Type<From>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        fromI: Schema.Encoded<From>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>\n      readonly encode: (\n        toI: Schema.Encoded<To>,\n        options: ParseOptions,\n        ast: AST.Transformation,\n        toA: Schema.Type<To>\n      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>\n      readonly strict: false\n    }\n  ): transformOrFail<From, To, RD | RE>\n} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(\n  from: Schema<FromA, FromI, FromR>,\n  to: Schema<ToA, ToI, ToR>,\n  options: {\n    readonly decode: (\n      fromA: FromA,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      fromI: FromI\n    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>\n    readonly encode: (\n      toI: ToI,\n      options: ParseOptions,\n      ast: AST.Transformation,\n      toA: ToA\n    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>\n  }\n): Schema<ToA, FromI, FromR | ToR | RD | RE> =>\n  makeTransformationClass(\n    from,\n    to,\n    new AST.Transformation(\n      from.ast,\n      to.ast,\n      new AST.FinalTransformation(options.decode, options.encode)\n    )\n  ))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transform<From extends Schema.Any, To extends Schema.Any> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}\n\n/**\n * Create a new `Schema` by transforming the input and output of an existing `Schema`\n * using the provided mapping functions.\n *\n * @category transformations\n * @since 3.10.0\n */\nexport const transform: {\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): (from: From) => transform<From, To>\n  /**\n   * Create a new `Schema` by transforming the input and output of an existing `Schema`\n   * using the provided mapping functions.\n   *\n   * @category transformations\n   * @since 3.10.0\n   */\n  <To extends Schema.Any, From extends Schema.Any>(\n    from: From,\n    to: To,\n    options: {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>\n      readonly strict?: true\n    } | {\n      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown\n      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown\n      readonly strict: false\n    }\n  ): transform<From, To>\n} = dual(\n  (args) => isSchema(args[0]) && isSchema(args[1]),\n  <FromA, FromI, FromR, ToA, ToI, ToR>(\n    from: Schema<FromA, FromI, FromR>,\n    to: Schema<ToA, ToI, ToR>,\n    options: {\n      readonly decode: (fromA: FromA, fromI: FromI) => ToI\n      readonly encode: (toI: ToI, toA: ToA) => FromA\n    }\n  ): Schema<ToA, FromI, FromR | ToR> =>\n    transformOrFail(\n      from,\n      to,\n      {\n        strict: true,\n        decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),\n        encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))\n      }\n    )\n)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface transformLiteral<Type, Encoded> extends Annotable<transformLiteral<Type, Encoded>, Type, Encoded> {}\n\n/**\n * Creates a new `Schema` which transforms literal values.\n *\n * @example\n * import * as S from \"effect/Schema\"\n *\n * const schema = S.transformLiteral(0, \"a\")\n *\n * assert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n *\n * @category constructors\n * @since 3.10.0\n */\nexport const transformLiteral = <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  from: Encoded,\n  to: Type\n): transformLiteral<Type, Encoded> =>\n  transform(Literal(from), Literal(to), { strict: true, decode: () => to, encode: () => from })\n\n/**\n * Creates a new `Schema` which maps between corresponding literal values.\n *\n * @example\n * import * as S from \"effect/Schema\"\n *\n * const Animal = S.transformLiterals(\n *   [0, \"cat\"],\n *   [1, \"dog\"],\n *   [2, \"cow\"]\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n *\n * @category constructors\n * @since 3.10.0\n */\nexport function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(\n  ...pairs: A\n): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>\nexport function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(\n  pairs: [Encoded, Type]\n): transformLiteral<Type, Encoded>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]>\nexport function transformLiterals<\n  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>\n>(...pairs: A): Schema<A[number][1], A[number][0]> {\n  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)))\n}\n\n/**\n * Attaches a property signature with the specified key and value to the schema.\n * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n *\n * @param self - The input schema.\n * @param key - The name of the property to add to the schema.\n * @param value - The value of the property to add to the schema.\n *\n * @example\n * import * as S from \"effect/Schema\"\n * import { pipe } from \"effect/Function\"\n *\n * const Circle = S.Struct({ radius: S.Number })\n * const Square = S.Struct({ sideLength: S.Number })\n * const Shape = S.Union(\n *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n * )\n *\n * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n *   kind: \"circle\",\n *   radius: 10\n * })\n *\n * @category combinators\n * @since 3.10.0\n */\nexport const attachPropertySignature: {\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @param self - The input schema.\n   * @param key - The name of the property to add to the schema.\n   * @param value - The value of the property to add to the schema.\n   *\n   * @example\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): <I, R>(\n    schema: SchemaClass<A, I, R>\n  ) => SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n  /**\n   * Attaches a property signature with the specified key and value to the schema.\n   * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\n   * but rather maps to another schema, for example when you want to add a discriminant to a simple union.\n   *\n   * @param self - The input schema.\n   * @param key - The name of the property to add to the schema.\n   * @param value - The value of the property to add to the schema.\n   *\n   * @example\n   * import * as S from \"effect/Schema\"\n   * import { pipe } from \"effect/Function\"\n   *\n   * const Circle = S.Struct({ radius: S.Number })\n   * const Square = S.Struct({ sideLength: S.Number })\n   * const Shape = S.Union(\n   *   Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n   *   Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n   * )\n   *\n   * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n   *   kind: \"circle\",\n   *   radius: 10\n   * })\n   *\n   * @category combinators\n   * @since 3.10.0\n   */\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(\n    schema: Schema<A, I, R>,\n    key: K,\n    value: V,\n    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>\n  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R> => {\n    const ast = extend(\n      typeSchema(schema),\n      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })\n    ).ast\n    return make(\n      new AST.Transformation(\n        schema.ast,\n        annotations ? mergeSchemaAnnotations(ast, annotations) : ast,\n        new AST.TypeLiteralTransformation(\n          [\n            new AST.PropertySignatureTransformation(\n              key,\n              key,\n              () => option_.some(value),\n              () => option_.none()\n            )\n          ]\n        )\n      )\n    )\n  }\n)\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport declare namespace Annotations {\n  /**\n   * @category annotations\n   * @since 3.10.0\n   */\n  export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly schemaId?: AST.SchemaIdAnnotation\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: ArbitraryAnnotation<A, TypeParameters>\n    readonly pretty?: pretty_.PrettyAnnotation<A, TypeParameters>\n    readonly equivalence?: AST.EquivalenceAnnotation<A, TypeParameters>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n    readonly parseOptions?: AST.ParseOptions\n    readonly decodingFallback?: AST.DecodingFallbackAnnotation<A>\n  }\n\n  /**\n   * @since 3.10.0\n   */\n  export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}\n}\n\n/**\n * Merges a set of new annotations with existing ones, potentially overwriting\n * any duplicates.\n *\n * @category annotations\n * @since 3.10.0\n */\nexport const annotations: {\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(annotations: Annotations.Schema<Schema.Type<S>>): (self: S) => Annotable.Self<S>\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   *\n   * @category annotations\n   * @since 3.10.0\n   */\n  <S extends Annotable.All>(self: S, annotations: Annotations.Schema<Schema.Type<S>>): Annotable.Self<S>\n} = dual(\n  2,\n  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.Schema<A>): Schema<A, I, R> => self.annotations(annotations)\n)\n\ntype Rename<A, M> = {\n  [\n    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]\n      : never\n      : K\n  ]: A[K]\n}\n\n/**\n * @category renaming\n * @since 3.10.0\n */\nexport const rename: {\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>\n  /**\n   * @category renaming\n   * @since 3.10.0\n   */\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>\n} = dual(\n  2,\n  <\n    A,\n    I,\n    R,\n    const M extends\n      & { readonly [K in keyof A]?: PropertyKey }\n      & { readonly [K in Exclude<keyof M, keyof A>]: never }\n  >(\n    self: Schema<A, I, R>,\n    mapping: M\n  ): SchemaClass<Simplify<Rename<A, M>>, I, R> => make(AST.rename(self.ast, mapping))\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const TrimmedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Trimmed\")\n\n/**\n * Verifies that a string contains no leading or trailing whitespaces.\n *\n * Note. This combinator does not make any transformations, it only validates.\n * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const trimmed =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.trim(), {\n        schemaId: TrimmedSchemaId,\n        description: \"a string with no leading or trailing whitespace\",\n        jsonSchema: { pattern: \"^\\\\S[\\\\s\\\\S]*\\\\S$|^\\\\S$|^$\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxLengthSchemaId: unique symbol = filters_.MaxLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxLengthSchemaId = typeof MaxLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const maxLength = <A extends string>(\n  maxLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length <= maxLength,\n      {\n        schemaId: MaxLengthSchemaId,\n        description: `a string at most ${maxLength} character(s) long`,\n        jsonSchema: { maxLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinLengthSchemaId: unique symbol = filters_.MinLengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinLengthSchemaId = typeof MinLengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const minLength = <A extends string>(\n  minLength: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.length >= minLength,\n      {\n        schemaId: MinLengthSchemaId,\n        description: `a string at least ${minLength} character(s) long`,\n        jsonSchema: { minLength },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PatternSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Pattern\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const pattern = <A extends string>(\n  regex: RegExp,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const pattern = regex.source\n  return self.pipe(\n    filter(\n      (a): a is A => {\n        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag\n        regex.lastIndex = 0\n        return regex.test(a)\n      },\n      {\n        schemaId: PatternSchemaId,\n        [PatternSchemaId]: { regex },\n        description: `a string matching the pattern ${pattern}`,\n        jsonSchema: { pattern },\n        arbitrary: () => (fc) => fc.stringMatching(regex) as any,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const StartsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/StartsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const startsWith = <A extends string>(\n  startsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.startsWith(startsWith),\n      {\n        schemaId: StartsWithSchemaId,\n        [StartsWithSchemaId]: { startsWith },\n        description: `a string starting with ${JSON.stringify(startsWith)}`,\n        jsonSchema: { pattern: `^${startsWith}` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const EndsWithSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/EndsWith\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const endsWith = <A extends string>(\n  endsWith: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.endsWith(endsWith),\n      {\n        schemaId: EndsWithSchemaId,\n        [EndsWithSchemaId]: { endsWith },\n        description: `a string ending with ${JSON.stringify(endsWith)}`,\n        jsonSchema: { pattern: `^.*${endsWith}$` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IncludesSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Includes\")\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const includes = <A extends string>(\n  searchString: string,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter(\n      (a) => a.includes(searchString),\n      {\n        schemaId: IncludesSchemaId,\n        [IncludesSchemaId]: { includes: searchString },\n        description: `a string including ${JSON.stringify(searchString)}`,\n        jsonSchema: { pattern: `.*${searchString}.*` },\n        ...annotations\n      }\n    )\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LowercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Lowercased\")\n\n/**\n * Verifies that a string is lowercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const lowercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toLowerCase(), {\n        schemaId: LowercasedSchemaId,\n        description: \"a lowercase string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Lowercased extends String$.pipe(\n  lowercased({ identifier: \"Lowercased\", title: \"Lowercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const CapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Capitalized\")\n\n/**\n * Verifies that a string is capitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const capitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toUpperCase() === a[0], {\n        schemaId: CapitalizedSchemaId,\n        description: \"a capitalized string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Capitalized extends String$.pipe(\n  capitalized({ identifier: \"Capitalized\", title: \"Capitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UncapitalizedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uncapitalized\")\n\n/**\n * Verifies that a string is uncapitalized.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uncapitalized =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a[0]?.toLowerCase() === a[0], {\n        schemaId: UncapitalizedSchemaId,\n        description: \"a uncapitalized string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uncapitalized extends String$.pipe(\n  uncapitalized({ identifier: \"Uncapitalized\", title: \"Uncapitalized\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UppercasedSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Uppercased\")\n\n/**\n * Verifies that a string is uppercased.\n *\n * @category string filters\n * @since 3.10.0\n */\nexport const uppercased =\n  <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a === a.toUpperCase(), {\n        schemaId: UppercasedSchemaId,\n        description: \"an uppercase string\",\n        ...annotations\n      })\n    )\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Uppercased extends String$.pipe(\n  uppercased({ identifier: \"Uppercased\", title: \"Uppercased\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LengthSchemaId: unique symbol = filters_.LengthSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LengthSchemaId = typeof LengthSchemaId\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const length = <A extends string>(\n  length: number | { readonly min: number; readonly max: number },\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> => {\n  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))\n  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength\n  if (minLength !== maxLength) {\n    return self.pipe(\n      filter((a) => a.length >= minLength && a.length <= maxLength, {\n        schemaId: LengthSchemaId,\n        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,\n        jsonSchema: { minLength, maxLength },\n        ...annotations\n      })\n    )\n  }\n  return self.pipe(\n    filter((a) => a.length === minLength, {\n      schemaId: LengthSchemaId,\n      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,\n      jsonSchema: { minLength, maxLength: minLength },\n      ...annotations\n    })\n  )\n}\n\n/**\n * A schema representing a single character.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class Char extends String$.pipe(length(1, { identifier: \"Char\" })) {}\n\n/**\n * @category string filters\n * @since 3.10.0\n */\nexport const nonEmptyString = <A extends string>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> =>\n  minLength(1, {\n    description: \"a non empty string\",\n    ...annotations\n  })\n\n/**\n * This schema converts a string to lowercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Lowercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to lowercase\" }),\n  Lowercased,\n  { strict: true, decode: (s) => s.toLowerCase(), encode: identity }\n).annotations({ identifier: \"Lowercase\" }) {}\n\n/**\n * This schema converts a string to uppercase.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uppercase extends transform(\n  String$.annotations({ description: \"a string that will be converted to uppercase\" }),\n  Uppercased,\n  { strict: true, decode: (s) => s.toUpperCase(), encode: identity }\n).annotations({ identifier: \"Uppercase\" }) {}\n\n/**\n * This schema converts a string to capitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Capitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to a capitalized format\" }),\n  Capitalized,\n  { strict: true, decode: (s) => string_.capitalize(s), encode: identity }\n).annotations({ identifier: \"Capitalize\" }) {}\n\n/**\n * This schema converts a string to uncapitalized one.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Uncapitalize extends transform(\n  String$.annotations({ description: \"a string that will be converted to an uncapitalized format\" }),\n  Uncapitalized,\n  { strict: true, decode: (s) => string_.uncapitalize(s), encode: identity }\n).annotations({ identifier: \"Uncapitalize\" }) {}\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class Trimmed extends String$.pipe(\n  trimmed({ identifier: \"Trimmed\", title: \"Trimmed\" })\n) {}\n\n/**\n * Useful for validating strings that must contain meaningful characters without\n * leading or trailing whitespace.\n *\n * @example\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\n * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyTrimmedString extends Trimmed.pipe(\n  nonEmptyString({ identifier: \"NonEmptyTrimmedString\", title: \"NonEmptyTrimmedString\" })\n) {}\n\n/**\n * This schema allows removing whitespaces from the beginning and end of a string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport class Trim extends transform(\n  String$.annotations({ description: \"a string that will be trimmed\" }),\n  Trimmed,\n  { strict: true, decode: (s) => s.trim(), encode: identity }\n).annotations({ identifier: \"Trim\" }) {}\n\n/**\n * Returns a schema that allows splitting a string into an array of strings.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const split = (separator: string): transform<typeof String$, Array$<typeof String$>> =>\n  transform(\n    String$.annotations({ description: \"a string that will be split\" }),\n    Array$(String$),\n    { strict: true, decode: string_.split(separator), encode: array_.join(separator) }\n  )\n\n/**\n * @since 3.10.0\n */\nexport type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}\n\nconst JsonString = String$.annotations({\n  [AST.IdentifierAnnotationId]: \"JsonString\",\n  [AST.TitleAnnotationId]: \"JsonString\",\n  [AST.DescriptionAnnotationId]: \"a JSON string\"\n})\n\nconst getParseJsonTransformation = (options?: ParseJsonOptions) =>\n  transformOrFail(\n    JsonString,\n    Unknown,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.parse(s, options?.reviver),\n          catch: (e: any) => new ParseResult.Type(ast, s, e.message)\n        }),\n      encode: (u, _, ast) =>\n        ParseResult.try({\n          try: () => JSON.stringify(u, options?.replacer, options?.space),\n          catch: (e: any) => new ParseResult.Type(ast, u, e.message)\n        })\n    }\n  ).annotations({ schemaId: AST.ParseJsonSchemaId })\n\n/**\n * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n *\n * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n *\n * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n *\n * @example\n * import * as Schema from \"effect/Schema\"\n *\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const parseJson: {\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): SchemaClass<A, string, R>\n  /**\n   * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\n   * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n   *\n   * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n   *\n   * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.\n   *\n   * @example\n   * import * as Schema from \"effect/Schema\"\n   *\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\n   * assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n   *\n   * @category string transformations\n   * @since 3.10.0\n   */\n  (options?: ParseJsonOptions): SchemaClass<unknown, string>\n} = <A, I, R>(schemaOrOptions?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) =>\n  isSchema(schemaOrOptions)\n    ? compose(parseJson(o), schemaOrOptions) as any\n    : getParseJsonTransformation(schemaOrOptions as ParseJsonOptions | undefined)\n\n/**\n * @category string constructors\n * @since 3.10.0\n */\nexport class NonEmptyString extends String$.pipe(\n  nonEmptyString({ identifier: \"NonEmptyString\", title: \"NonEmptyString\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const UUIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/UUID\")\n\nconst uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i\n\n/**\n * Represents a Universally Unique Identifier (UUID).\n *\n * This schema ensures that the provided string adheres to the standard UUID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class UUID extends String$.pipe(\n  pattern(uuidRegexp, {\n    schemaId: UUIDSchemaId,\n    identifier: \"UUID\",\n    title: \"UUID\",\n    description: \"a Universally Unique Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()\n  })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ULIDSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ULID\")\n\nconst ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i\n\n/**\n * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n *\n * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\n * This schema ensures that the provided string adheres to the standard ULID format.\n *\n * @category string constructors\n * @since 3.10.0\n */\nexport class ULID extends String$.pipe(\n  pattern(ulidRegexp, {\n    schemaId: ULIDSchemaId,\n    identifier: \"ULID\",\n    title: \"ULID\",\n    description: \"a Universally Unique Lexicographically Sortable Identifier\",\n    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()\n  })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const FiniteSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/Finite\")\n\n/**\n * Ensures that the provided value is a finite number.\n *\n * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const finite =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => Number.isFinite(a), {\n        schemaId: FiniteSchemaId,\n        description: \"a finite number\",\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanSchemaId: unique symbol = filters_.GreaterThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanSchemaId = typeof GreaterThanSchemaId\n\n/**\n * This filter checks whether the provided number is greater than the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThan = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanSchemaId,\n      description: min === 0 ? \"a positive number\" : `a number greater than ${min}`,\n      jsonSchema: { exclusiveMinimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToSchemaId: unique symbol = filters_.GreaterThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId\n\n/**\n * This filter checks whether the provided number is greater than or equal to the specified minimum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualTo = <A extends number>(\n  min: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToSchemaId,\n      description: min === 0 ? \"a non-negative number\" : `a number greater than or equal to ${min}`,\n      jsonSchema: { minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MultipleOfSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/MultipleOf\")\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const multipleOf = <A extends number>(\n  divisor: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => number_.remainder(a, divisor) === 0, {\n      schemaId: MultipleOfSchemaId,\n      description: `a number divisible by ${divisor}`,\n      jsonSchema: { multipleOf: Math.abs(divisor) }, // spec requires positive divisor\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const IntSchemaId: unique symbol = filters_.IntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type IntSchemaId = typeof IntSchemaId\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const int =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => Number.isSafeInteger(a), {\n        schemaId: IntSchemaId,\n        title: \"integer\",\n        description: \"an integer\",\n        jsonSchema: { type: \"integer\" },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanSchemaId: unique symbol = filters_.LessThanSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanSchemaId = typeof LessThanSchemaId\n\n/**\n * This filter checks whether the provided number is less than the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThan =\n  <A extends number>(max: number, annotations?: Annotations.Filter<A>) =>\n  <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => a < max, {\n        schemaId: LessThanSchemaId,\n        description: max === 0 ? \"a negative number\" : `a number less than ${max}`,\n        jsonSchema: { exclusiveMaximum: max },\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToSchemaId: unique symbol = filters_.LessThanOrEqualToSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId\n\n/**\n * This schema checks whether the provided number is less than or equal to the specified maximum.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualTo = <A extends number>(\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanOrEqualToSchemaId,\n      description: max === 0 ? \"a non-positive number\" : `a number less than or equal to ${max}`,\n      jsonSchema: { maximum: max },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenSchemaId: unique symbol = filters_.BetweenSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenSchemaId = typeof BetweenSchemaId\n\n/**\n * This filter checks whether the provided number falls within the specified minimum and maximum values.\n *\n * @category number filters\n * @since 3.10.0\n */\nexport const between = <A extends number>(\n  min: number,\n  max: number,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      schemaId: BetweenSchemaId,\n      description: `a number between ${min} and ${max}`,\n      jsonSchema: { maximum: max, minimum: min },\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNaNSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/NonNaN\")\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNaN =\n  <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a), {\n        schemaId: NonNaNSchemaId,\n        description: \"a number excluding NaN\",\n        ...annotations\n      })\n    )\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const positive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThan(0, annotations)\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const negative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThan(0, annotations)\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonPositive = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanOrEqualTo(0, annotations)\n\n/**\n * @category number filters\n * @since 3.10.0\n */\nexport const nonNegative = <A extends number>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanOrEqualTo(0, annotations)\n\n/**\n * Clamps a number between a minimum and a maximum value.\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const clamp =\n  (minimum: number, maximum: number) =>\n  <A extends number, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, between(minimum, maximum)),\n      { strict: false, decode: (self) => number_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * Transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number transformations\n * @since 3.10.0\n */\nexport const parseNumber = <A extends string, I, R>(\n  self: Schema<A, I, R>\n): transformOrFail<Schema<A, I, R>, typeof Number$> =>\n  transformOrFail(\n    self,\n    Number$,\n    {\n      strict: false,\n      decode: (s, _, ast) => ParseResult.fromOption(number_.parse(s), () => new ParseResult.Type(ast, s)),\n      encode: (n) => ParseResult.succeed(String(n))\n    }\n  )\n\n/**\n * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n *\n * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n *\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category number constructors\n * @since 3.10.0\n */\nexport class NumberFromString extends parseNumber(String$.annotations({\n  description: \"a string that will be parsed into a number\"\n})).annotations({ identifier: \"NumberFromString\" }) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Finite extends Number$.pipe(finite({ identifier: \"Finite\", title: \"Finite\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Int extends Number$.pipe(int({ identifier: \"Int\", title: \"Int\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNaN extends Number$.pipe(nonNaN({ identifier: \"NonNaN\", title: \"NonNaN\" })) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Positive extends Number$.pipe(\n  positive({ identifier: \"Positive\", title: \"Positive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class Negative extends Number$.pipe(\n  negative({ identifier: \"Negative\", title: \"Negative\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonPositive extends Number$.pipe(\n  nonPositive({ identifier: \"NonPositive\", title: \"NonPositive\" })\n) {}\n\n/**\n * @category number constructors\n * @since 3.10.0\n */\nexport class NonNegative extends Number$.pipe(\n  nonNegative({ identifier: \"NonNegative\", title: \"NonNegative\" })\n) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const JsonNumberSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/JsonNumber\")\n\n/**\n * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\n * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\n * format.\n *\n * @example\n * import * as Schema from \"effect/Schema\"\n *\n * const is = Schema.is(S.JsonNumber)\n *\n * assert.deepStrictEqual(is(42), true)\n * assert.deepStrictEqual(is(Number.NaN), false)\n * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\n * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n *\n * @category number constructors\n * @since 3.10.0\n */\nexport class JsonNumber extends Number$.pipe(\n  filter((n) => !Number.isNaN(n) && Number.isFinite(n), {\n    schemaId: JsonNumberSchemaId,\n    identifier: \"JsonNumber\",\n    title: \"JSON-compatible number\",\n    description: \"a JSON-compatible number, excluding NaN, +Infinity, and -Infinity\",\n    jsonSchema: { type: \"number\" }\n  })\n) {}\n\n/**\n * @category boolean transformations\n * @since 3.10.0\n */\nexport class Not extends transform(Boolean$.annotations({ description: \"a boolean that will be negated\" }), Boolean$, {\n  strict: true,\n  decode: boolean_.not,\n  encode: boolean_.not\n}) {}\n\n/** @ignore */\nclass Symbol$ extends transform(\n  String$.annotations({ description: \"a string that will be converted to a symbol\" }),\n  SymbolFromSelf,\n  { strict: false, decode: (s) => Symbol.for(s), encode: (sym) => sym.description }\n).annotations({ identifier: \"symbol\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `symbol`.\n   *\n   * @category symbol transformations\n   * @since 3.10.0\n   */\n  Symbol$ as Symbol\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigIntSchemaId: unique symbol = filters_.GreaterThanBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanBigIntSchemaId,\n      [GreaterThanBigIntSchemaId]: { min },\n      description: min === 0n ? \"a positive bigint\" : `a bigint greater than ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigIntSchemaId: unique symbol = filters_.GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigInt = <A extends bigint>(\n  min: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToBigIntSchemaId,\n      [GreaterThanOrEqualToBigIntSchemaId]: { min },\n      description: min === 0n\n        ? \"a non-negative bigint\"\n        : `a bigint greater than or equal to ${min}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigIntSchemaId: unique symbol = filters_.LessThanBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanBigIntSchemaId,\n      [LessThanBigIntSchemaId]: { max },\n      description: max === 0n ? \"a negative bigint\" : `a bigint less than ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigIntSchemaId: unique symbol = filters_.LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigInt = <A extends bigint>(\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanOrEqualToBigIntSchemaId,\n      [LessThanOrEqualToBigIntSchemaId]: { max },\n      description: max === 0n ? \"a non-positive bigint\" : `a bigint less than or equal to ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigIntSchemaId: unique symbol = filters_.BetweenBigintSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const betweenBigInt = <A extends bigint>(\n  min: bigint,\n  max: bigint,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min && a <= max, {\n      schemaId: BetweenBigIntSchemaId,\n      [BetweenBigIntSchemaId]: { max, min },\n      description: `a bigint between ${min}n and ${max}n`,\n      ...annotations\n    })\n  )\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const positiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const negativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonNegativeBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => greaterThanOrEqualToBigInt(0n, annotations)\n\n/**\n * @category bigint filters\n * @since 3.10.0\n */\nexport const nonPositiveBigInt = <A extends bigint>(\n  annotations?: Annotations.Filter<A>\n): <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>> => lessThanOrEqualToBigInt(0n, annotations)\n\n/**\n * Clamps a bigint between a minimum and a maximum value.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport const clampBigInt =\n  (minimum: bigint, maximum: bigint) =>\n  <A extends bigint, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigInt(minimum, maximum)),\n      { strict: false, decode: (self) => bigInt_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/** @ignore */\nclass BigInt$ extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) => ParseResult.fromOption(bigInt_.fromString(s), () => new ParseResult.Type(ast, s)),\n    encode: (n) => ParseResult.succeed(String(n))\n  }\n).annotations({ identifier: \"bigint\" }) {}\n\nexport {\n  /**\n   * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n   *\n   * It returns an error if the value can't be converted (for example when non-numeric characters are provided).\n   *\n   * @category bigint transformations\n   * @since 3.10.0\n   */\n  BigInt$ as BigInt\n}\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  positiveBigInt({ identifier: \"PositiveBigintFromSelf\", title: \"PositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const PositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  positiveBigInt({ identifier: \"PositiveBigint\", title: \"PositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  negativeBigInt({ identifier: \"NegativeBigintFromSelf\", title: \"NegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  negativeBigInt({ identifier: \"NegativeBigint\", title: \"NegativeBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigintFromSelf\", title: \"NonPositiveBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonPositiveBigInt({ identifier: \"NonPositiveBigint\", title: \"NonPositiveBigint\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigintFromSelf\", title: \"NonNegativeBigintFromSelf\" })\n)\n\n/**\n * @category bigint constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(\n  nonNegativeBigInt({ identifier: \"NonNegativeBigint\", title: \"NonNegativeBigint\" })\n)\n\n/**\n * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n *\n * It returns an error if the value can't be safely encoded as a `number` due to being out of range.\n *\n * @category bigint transformations\n * @since 3.10.0\n */\nexport class BigIntFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a bigint\" }),\n  BigIntFromSelf,\n  {\n    strict: true,\n    decode: (n, _, ast) =>\n      ParseResult.fromOption(\n        bigInt_.fromNumber(n),\n        () => new ParseResult.Type(ast, n)\n      ),\n    encode: (b, _, ast) => ParseResult.fromOption(bigInt_.toNumber(b), () => new ParseResult.Type(ast, b))\n  }\n).annotations({ identifier: \"BigintFromNumber\" }) {}\n\nconst redactedArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<redacted_.Redacted<A>> => (fc) =>\n  value(fc).map(redacted_.make)\n\nconst toComposite = <A, R, B>(\n  eff: Effect.Effect<A, ParseResult.ParseIssue, R>,\n  onSuccess: (a: A) => B,\n  ast: AST.AST,\n  actual: unknown\n): Effect.Effect<B, ParseResult.Composite, R> =>\n  ParseResult.mapBoth(eff, {\n    onFailure: (e) => new ParseResult.Composite(ast, actual, e),\n    onSuccess\n  })\n\nconst redactedParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<redacted_.Redacted<A>, R> =>\n(u, options, ast) =>\n  redacted_.isRedacted(u) ?\n    toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) :\n    ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Redacted constructors\n * @since 3.10.0\n */\nexport const RedactedFromSelf = <Value extends Schema.Any>(\n  value: Value\n): RedactedFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (value) => redactedParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => redactedParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: \"Redacted(<redacted>)\",\n      pretty: () => () => \"Redacted(<redacted>)\",\n      arbitrary: redactedArbitrary,\n      equivalence: redacted_.getEquivalence\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Redacted<Value extends Schema.Any> extends\n  AnnotableClass<\n    Redacted<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    Schema.Encoded<Value>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * A schema that transforms any type `A` into a `Redacted<A>`.\n *\n * @category Redacted transformations\n * @since 3.10.0\n */\nexport const Redacted = <Value extends Schema.Any>(\n  value: Value\n): Redacted<Value> => {\n  return transform(\n    value,\n    RedactedFromSelf(typeSchema(value)),\n    {\n      strict: true,\n      decode: (value) => redacted_.make(value),\n      encode: (value) => redacted_.value(value)\n    }\n  )\n}\n\n/**\n * @category Duration constructors\n * @since 3.10.0\n */\nexport class DurationFromSelf extends declare(\n  duration_.isDuration,\n  {\n    identifier: \"DurationFromSelf\",\n    pretty: (): pretty_.Pretty<duration_.Duration> => String,\n    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>\n      fc.oneof(\n        fc.constant(duration_.infinity),\n        fc.bigUint().map((_) => duration_.nanos(_)),\n        fc.bigUint().map((_) => duration_.micros(_)),\n        fc.maxSafeNat().map((_) => duration_.millis(_)),\n        fc.maxSafeNat().map((_) => duration_.seconds(_)),\n        fc.maxSafeNat().map((_) => duration_.minutes(_)),\n        fc.maxSafeNat().map((_) => duration_.hours(_)),\n        fc.maxSafeNat().map((_) => duration_.days(_)),\n        fc.maxSafeNat().map((_) => duration_.weeks(_))\n      ),\n    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence\n  }\n) {}\n\n/**\n * A schema that transforms a `bigint` tuple into a `Duration`.\n * Treats the value as the number of nanoseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromNanos extends transformOrFail(\n  BigIntFromSelf.annotations({ description: \"a bigint that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: (nanos) => ParseResult.succeed(duration_.nanos(nanos)),\n    encode: (duration, _, ast) =>\n      option_.match(duration_.toNanos(duration), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, duration)),\n        onSome: (val) => ParseResult.succeed(val)\n      })\n  }\n).annotations({ identifier: \"DurationFromNanos\" }) {}\n\n/**\n * A schema that transforms a `number` tuple into a `Duration`.\n * Treats the value as the number of milliseconds.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class DurationFromMillis extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  { strict: true, decode: (ms) => duration_.millis(ms), encode: (n) => duration_.toMillis(n) }\n).annotations({ identifier: \"DurationFromMillis\" }) {}\n\nconst hrTime: Schema<readonly [seconds: number, nanos: number]> = Tuple(\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"seconds\",\n      [AST.DescriptionAnnotationId]: \"seconds\"\n    })\n  ),\n  NonNegative.pipe(\n    finite({\n      [AST.TitleAnnotationId]: \"nanos\",\n      [AST.DescriptionAnnotationId]: \"nanos\"\n    })\n  )\n)\n\n/**\n * A schema that transforms a `[number, number]` tuple into a `Duration`.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport class Duration extends transform(\n  hrTime.annotations({ description: \"a tuple of seconds and nanos that will be parsed into a Duration\" }),\n  DurationFromSelf,\n  {\n    strict: true,\n    decode: ([seconds, nanos]) => duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)),\n    encode: (duration) => duration_.toHrTime(duration)\n  }\n).annotations({ identifier: \"Duration\" }) {}\n\n/**\n * Clamps a `Duration` between a minimum and a maximum value.\n *\n * @category Duration transformations\n * @since 3.10.0\n */\nexport const clampDuration =\n  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>\n  <A extends duration_.Duration, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenDuration(minimum, maximum)),\n      { strict: false, decode: (self) => duration_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThan(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      description: `a Duration less than ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDuration = <A extends duration_.Duration>(\n  max: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanDurationSchemaId,\n      [LessThanDurationSchemaId]: { max },\n      description: `a Duration less than or equal to ${duration_.decode(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThan(a, min), {\n      schemaId: GreaterThanDurationSchemaId,\n      [GreaterThanDurationSchemaId]: { min },\n      description: `a Duration greater than ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDuration\"\n)\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDuration = <A extends duration_.Duration>(\n  min: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToDurationSchemaId,\n      [GreaterThanOrEqualToDurationSchemaId]: { min },\n      description: `a Duration greater than or equal to ${duration_.decode(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDurationSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDuration\")\n\n/**\n * @category Duration filters\n * @since 3.10.0\n */\nexport const betweenDuration = <A extends duration_.Duration>(\n  minimum: duration_.DurationInput,\n  maximum: duration_.DurationInput,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => duration_.between(a, { minimum, maximum }), {\n      schemaId: BetweenDurationSchemaId,\n      [BetweenDurationSchemaId]: { maximum, minimum },\n      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category Uint8Array constructors\n * @since 3.10.0\n */\nexport const Uint8ArrayFromSelf: Schema<Uint8Array> = declare(\n  Predicate.isUint8Array,\n  {\n    identifier: \"Uint8ArrayFromSelf\",\n    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,\n    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),\n    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any\n  }\n)\n\nconst Uint8Array$: Schema<Uint8Array, ReadonlyArray<number>> = transform(\n  Array$(Number$.pipe(\n    between(0, 255, {\n      title: \"8-bit unsigned integer\",\n      description: \"a 8-bit unsigned integer\"\n    })\n  )).annotations({ description: \"an array of 8-bit unsigned integers that will be parsed into a Uint8Array\" }),\n  Uint8ArrayFromSelf,\n  { strict: true, decode: (numbers) => Uint8Array.from(numbers), encode: (uint8Array) => Array.from(uint8Array) }\n).annotations({ identifier: \"Uint8Array\" })\n\nexport {\n  /**\n   * A schema that transforms an array of numbers into a `Uint8Array`.\n   *\n   * @category Uint8Array transformations\n   * @since 3.10.0\n   */\n  Uint8Array$ as Uint8Array\n}\n\nconst makeUint8ArrayTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,\n  encode: (u: Uint8Array) => string\n) =>\n  transformOrFail(\n    String$.annotations({ description: \"a string that will be parsed into a Uint8Array\" }),\n    Uint8ArrayFromSelf,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: id })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64\",\n  Encoding.decodeBase64,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromBase64Url: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromBase64Url\",\n  Encoding.decodeBase64Url,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a `Uint8Array`.\n *\n * @category Uint8Array transformations\n * @since 3.10.0\n */\nexport const Uint8ArrayFromHex: Schema<Uint8Array, string> = makeUint8ArrayTransformation(\n  \"Uint8ArrayFromHex\",\n  Encoding.decodeHex,\n  Encoding.encodeHex\n)\n\nconst makeEncodingTransformation = (\n  id: string,\n  decode: (s: string) => either_.Either<string, Encoding.DecodeException>,\n  encode: (u: string) => string\n) =>\n  transformOrFail(\n    String$.annotations({\n      description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`\n    }),\n    String$,\n    {\n      strict: true,\n      decode: (s, _, ast) =>\n        either_.mapLeft(\n          decode(s),\n          (decodeException) => new ParseResult.Type(ast, s, decodeException.message)\n        ),\n      encode: (u) => ParseResult.succeed(encode(u))\n    }\n  ).annotations({ identifier: `StringFrom${id}` })\n\n/**\n * Decodes a base64 (RFC4648) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64: Schema<string> = makeEncodingTransformation(\n  \"Base64\",\n  Encoding.decodeBase64String,\n  Encoding.encodeBase64\n)\n\n/**\n * Decodes a base64 (URL) encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromBase64Url: Schema<string> = makeEncodingTransformation(\n  \"Base64Url\",\n  Encoding.decodeBase64UrlString,\n  Encoding.encodeBase64Url\n)\n\n/**\n * Decodes a hex encoded string into a UTF-8 string.\n *\n * @category string transformations\n * @since 3.10.0\n */\nexport const StringFromHex: Schema<string> = makeEncodingTransformation(\n  \"Hex\",\n  Encoding.decodeHexString,\n  Encoding.encodeHex\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MinItemsSchemaId: unique symbol = filters_.MinItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MinItemsSchemaId = typeof MinItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const minItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> => {\n  const minItems = Math.floor(n)\n  if (minItems < 1) {\n    throw new Error(\n      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)\n    )\n  }\n  return self.pipe(\n    filter(\n      (a) => a.length >= minItems,\n      {\n        schemaId: MinItemsSchemaId,\n        description: `an array of at least ${minItems} items`,\n        jsonSchema: { minItems },\n        [AST.StableFilterAnnotationId]: true,\n        ...annotations\n      }\n    )\n  )\n}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const MaxItemsSchemaId: unique symbol = filters_.MaxItemsSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type MaxItemsSchemaId = typeof MaxItemsSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const maxItems = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length <= n, {\n      schemaId: MaxItemsSchemaId,\n      description: `an array of at most ${n} items`,\n      jsonSchema: { maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ItemsCountSchemaId: unique symbol = filters_.ItemsCountSchemaId\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport type ItemsCountSchemaId = typeof ItemsCountSchemaId\n\n/**\n * @category ReadonlyArray filters\n * @since 3.10.0\n */\nexport const itemsCount = <A>(\n  n: number,\n  annotations?: Annotations.Filter<ReadonlyArray<A>>\n) =>\n<I, R>(self: Schema<ReadonlyArray<A>, I, R>): filter<Schema<ReadonlyArray<A>, I, R>> =>\n  self.pipe(\n    filter((a) => a.length === n, {\n      schemaId: ItemsCountSchemaId,\n      description: `an array of exactly ${n} item(s)`,\n      jsonSchema: { minItems: n, maxItems: n },\n      [AST.StableFilterAnnotationId]: true,\n      ...annotations\n    })\n  )\n\n/**\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(\n  self: Schema<A, I, R>\n): SchemaClass<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const head = <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>): SchemaClass<option_.Option<A>, I, R> =>\n  transform(\n    self,\n    OptionFromSelf(getNumberIndexedAccess(typeSchema(self))),\n    { strict: true, decode: array_.head, encode: option_.match({ onNone: () => [], onSome: array_.of }) }\n  )\n\n/**\n * Retrieves the first element of a `ReadonlyArray`.\n *\n * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n *\n * @category ReadonlyArray transformations\n * @since 3.10.0\n */\nexport const headOrElse: {\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<A, I, R>\n  /**\n   * Retrieves the first element of a `ReadonlyArray`.\n   *\n   * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.\n   *\n   * @category ReadonlyArray transformations\n   * @since 3.10.0\n   */\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R>\n} = dual(\n  (args) => isSchema(args[0]),\n  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R> =>\n    transformOrFail(\n      self,\n      getNumberIndexedAccess(typeSchema(self)),\n      {\n        strict: true,\n        decode: (as, _, ast) =>\n          as.length > 0\n            ? ParseResult.succeed(as[0])\n            : fallback\n            ? ParseResult.succeed(fallback())\n            : ParseResult.fail(new ParseResult.Type(ast, as)),\n        encode: (a) => ParseResult.succeed(array_.of(a))\n      }\n    )\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const ValidDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/ValidDate\")\n\n/**\n * Defines a filter that specifically rejects invalid dates, such as `new\n * Date(\"Invalid Date\")`. This filter ensures that only properly formatted and\n * valid date objects are accepted, enhancing data integrity by preventing\n * erroneous date values from being processed.\n *\n * @category Date filters\n * @since 3.10.0\n */\nexport const validDate =\n  (annotations?: Annotations.Filter<Date>) => <I, R>(self: Schema<Date, I, R>): filter<Schema<Date, I, R>> =>\n    self.pipe(\n      filter((a) => !Number.isNaN(a.getTime()), {\n        schemaId: ValidDateSchemaId,\n        description: \"a valid Date\",\n        ...annotations\n      })\n    )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanDate = <A extends Date>(\n  max: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a < max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      description: `a date before ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToDate = <A extends Date>(\n  max: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= max, {\n      schemaId: LessThanDateSchemaId,\n      [LessThanDateSchemaId]: { max },\n      description: `a date before or equal to ${util_.formatDate(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanDate = <A extends Date>(\n  min: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a > min, {\n      schemaId: GreaterThanDateSchemaId,\n      [GreaterThanDateSchemaId]: { min },\n      description: `a date after ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToDateSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToDate\"\n)\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToDate = <A extends Date>(\n  min: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a >= min, {\n      schemaId: GreaterThanOrEqualToDateSchemaId,\n      [GreaterThanOrEqualToDateSchemaId]: { min },\n      description: `a date after or equal to ${util_.formatDate(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenDateSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenDate\")\n\n/**\n * @category Date filters\n * @since 3.10.0\n */\nexport const betweenDate = <A extends Date>(\n  minimum: Date,\n  maximum: Date,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a <= maximum && a >= minimum, {\n      schemaId: BetweenDateSchemaId,\n      [BetweenDateSchemaId]: { maximum, minimum },\n      description: `a date between ${util_.formatDate(minimum)} and ${util_.formatDate(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * Describes a schema that accommodates potentially invalid `Date` instances,\n * such as `new Date(\"Invalid Date\")`, without rejection.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class DateFromSelf extends declare(\n  Predicate.isDate,\n  {\n    identifier: \"DateFromSelf\",\n    description: \"a potentially invalid Date instance\",\n    pretty: (): pretty_.Pretty<Date> => (date) => `new Date(${JSON.stringify(date)})`,\n    arbitrary: (): LazyArbitrary<Date> => (fc) => fc.date({ noInvalidDate: false }),\n    equivalence: () => Equivalence.Date\n  }\n) {}\n\n/**\n * Defines a schema that ensures only valid dates are accepted. This schema\n * rejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\n * instance, represents an invalid date. Such stringent validation ensures that\n * all date objects processed through this schema are properly formed and\n * represent real dates.\n *\n * @category Date constructors\n * @since 3.10.0\n */\nexport class ValidDateFromSelf extends DateFromSelf.pipe(\n  validDate({\n    identifier: \"ValidDateFromSelf\",\n    description: \"a valid Date instance\"\n  })\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `Date` object using\n * the `new Date` constructor. This conversion is lenient, meaning it does not\n * reject strings that do not form valid dates (e.g., using `new Date(\"Invalid\n * Date\")` results in a `Date` object, despite being invalid).\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromString extends transform(\n  String$.annotations({ description: \"a string that will be parsed into a Date\" }),\n  DateFromSelf,\n  { strict: true, decode: (s) => new Date(s), encode: (d) => util_.formatDate(d) }\n).annotations({ identifier: \"DateFromString\" }) {}\n\n/** @ignore */\nclass Date$ extends DateFromString.pipe(\n  validDate({ identifier: \"Date\" })\n) {}\n\nexport {\n  /**\n   * This schema converts a `string` into a `Date` object using the `new Date`\n   * constructor. It ensures that only valid date strings are accepted,\n   * rejecting any strings that would result in an invalid date, such as `new\n   * Date(\"Invalid Date\")`.\n   *\n   * @category Date transformations\n   * @since 3.10.0\n   */\n  Date$ as Date\n}\n\n/**\n * Defines a schema that converts a `number` into a `Date` object using the `new\n * Date` constructor. This schema does not validate the numerical input,\n * allowing potentially invalid values such as `NaN`, `Infinity`, and\n * `-Infinity` to be converted into `Date` objects. During the encoding process,\n * any invalid `Date` object will be encoded to `NaN`.\n *\n * @category Date transformations\n * @since 3.10.0\n */\nexport class DateFromNumber extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a Date\" }),\n  DateFromSelf,\n  { strict: true, decode: (n) => new Date(n), encode: (d) => d.getTime() }\n).annotations({ identifier: \"DateFromNumber\" }) {}\n\n/**\n * Describes a schema that represents a `DateTime.Utc` instance.\n *\n * @category DateTime.Utc constructors\n * @since 3.10.0\n */\nexport class DateTimeUtcFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isUtc(u),\n  {\n    identifier: \"DateTimeUtcFromSelf\",\n    description: \"a DateTime.Utc instance\",\n    pretty: (): pretty_.Pretty<dateTime.Utc> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Utc> => (fc) => fc.date().map((date) => dateTime.unsafeFromDate(date)),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\nconst decodeDateTime = <A extends dateTime.DateTime.Input>(input: A, _: ParseOptions, ast: AST.AST) =>\n  ParseResult.try({\n    try: () => dateTime.unsafeMake(input),\n    catch: () => new ParseResult.Type(ast, input)\n  })\n\n/**\n * Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtcFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: decodeDateTime,\n    encode: (dt) => ParseResult.succeed(dateTime.toEpochMillis(dt))\n  }\n).annotations({ identifier: \"DateTimeUtcFromNumber\" }) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.\n *\n * @category DateTime.Utc transformations\n * @since 3.10.0\n */\nexport class DateTimeUtc extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a DateTime.Utc\" }),\n  DateTimeUtcFromSelf,\n  {\n    strict: true,\n    decode: decodeDateTime,\n    encode: (dt) => ParseResult.succeed(dateTime.formatIso(dt))\n  }\n).annotations({ identifier: \"DateTimeUtc\" }) {}\n\nconst timeZoneOffsetArbitrary = (): LazyArbitrary<dateTime.TimeZone.Offset> => (fc) =>\n  fc.integer({ min: -12 * 60 * 60 * 1000, max: 12 * 60 * 60 * 1000 }).map(dateTime.zoneMakeOffset)\n\n/**\n * Describes a schema that represents a `TimeZone.Offset` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneOffsetFromSelf extends declare(\n  dateTime.isTimeZoneOffset,\n  {\n    identifier: \"TimeZoneOffsetFromSelf\",\n    description: \"a TimeZone.Offset instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Offset> => (zone) => zone.toString(),\n    arbitrary: timeZoneOffsetArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneOffset extends transform(\n  Number$.annotations({ description: \"a number that will be parsed into a TimeZone.Offset\" }),\n  TimeZoneOffsetFromSelf,\n  { strict: true, decode: dateTime.zoneMakeOffset, encode: (tz) => tz.offset }\n).annotations({ identifier: \"TimeZoneOffset\" }) {}\n\nconst timeZoneNamedArbitrary = (): LazyArbitrary<dateTime.TimeZone.Named> => (fc) =>\n  fc.constantFrom(...Intl.supportedValuesOf(\"timeZone\")).map(dateTime.zoneUnsafeMakeNamed)\n\n/**\n * Describes a schema that represents a `TimeZone.Named` instance.\n *\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport class TimeZoneNamedFromSelf extends declare(\n  dateTime.isTimeZoneNamed,\n  {\n    identifier: \"TimeZoneNamedFromSelf\",\n    description: \"a TimeZone.Named instance\",\n    pretty: (): pretty_.Pretty<dateTime.TimeZone.Named> => (zone) => zone.toString(),\n    arbitrary: timeZoneNamedArbitrary\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZoneNamed extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a TimeZone.Named\" }),\n  TimeZoneNamedFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      ParseResult.try({\n        try: () => dateTime.zoneUnsafeMakeNamed(s),\n        catch: () => new ParseResult.Type(ast, s)\n      }),\n    encode: (tz) => ParseResult.succeed(tz.id)\n  }\n).annotations({ identifier: \"TimeZoneNamed\" }) {}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TimeZoneFromSelf extends Union<[typeof TimeZoneOffsetFromSelf, typeof TimeZoneNamedFromSelf]> {\n  annotations(annotations: Annotations.Schema<dateTime.TimeZone>): TimeZoneFromSelf\n}\n\n/**\n * @category TimeZone constructors\n * @since 3.10.0\n */\nexport const TimeZoneFromSelf: TimeZoneFromSelf = Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)\n\n/**\n * Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.\n *\n * @category TimeZone transformations\n * @since 3.10.0\n */\nexport class TimeZone extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a TimeZone\" }),\n  TimeZoneFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      option_.match(dateTime.zoneFromString(s), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (tz) => ParseResult.succeed(dateTime.zoneToString(tz))\n  }\n).annotations({ identifier: \"TimeZone\" }) {}\n\nconst timeZoneArbitrary: LazyArbitrary<dateTime.TimeZone> = (fc) =>\n  fc.oneof(\n    timeZoneOffsetArbitrary()(fc),\n    timeZoneNamedArbitrary()(fc)\n  )\n\n/**\n * Describes a schema that represents a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned constructors\n * @since 3.10.0\n */\nexport class DateTimeZonedFromSelf extends declare(\n  (u) => dateTime.isDateTime(u) && dateTime.isZoned(u),\n  {\n    identifier: \"DateTimeZonedFromSelf\",\n    description: \"a DateTime.Zoned instance\",\n    pretty: (): pretty_.Pretty<dateTime.Zoned> => (dateTime) => dateTime.toString(),\n    arbitrary: (): LazyArbitrary<dateTime.Zoned> => (fc) =>\n      fc.date().chain((date) => timeZoneArbitrary(fc).map((timeZone) => dateTime.unsafeMakeZoned(date, { timeZone }))),\n    equivalence: () => dateTime.Equivalence\n  }\n) {}\n\n/**\n * Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.\n *\n * @category DateTime.Zoned transformations\n * @since 3.10.0\n */\nexport class DateTimeZoned extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a DateTime.Zoned\" }),\n  DateTimeZonedFromSelf,\n  {\n    strict: true,\n    decode: (s, _, ast) =>\n      option_.match(dateTime.makeZonedFromString(s), {\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),\n        onSome: ParseResult.succeed\n      }),\n    encode: (dt) => ParseResult.succeed(dateTime.formatIsoZoned(dt))\n  }\n).annotations({ identifier: \"DateTimeZoned\" }) {}\n\n/**\n * @category Option utils\n * @since 3.10.0\n */\nexport type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }\n\nconst OptionNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ description: \"NoneEncoded\" })\n\nconst optionSomeEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Struct({\n    _tag: Literal(\"Some\"),\n    value\n  }).annotations({ description: `SomeEncoded<${format(value)}>` })\n\nconst optionEncoded = <A, I, R>(value: Schema<A, I, R>) =>\n  Union(\n    OptionNoneEncoded,\n    optionSomeEncoded(value)\n  ).annotations({\n    description: `OptionEncoded<${format(value)}>`\n  })\n\nconst optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>\n  input._tag === \"None\" ? option_.none() : option_.some(input.value)\n\nconst optionArbitrary =\n  <A>(value: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<option_.Option<A>> => (fc) =>\n    fc.oneof(\n      ctx,\n      fc.record({ _tag: fc.constant(\"None\" as const) }),\n      fc.record({ _tag: fc.constant(\"Some\" as const), value: value(fc) })\n    ).map(optionDecode)\n\nconst optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>\n  option_.match({\n    onNone: () => \"none()\",\n    onSome: (a) => `some(${value(a)})`\n  })\n\nconst optionParse =\n  <A, R>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>\n  (u, options, ast) =>\n    option_.isOption(u) ?\n      option_.isNone(u) ?\n        ParseResult.succeed(option_.none())\n        : toComposite(decodeUnknown(u.value, options), option_.some, ast, u)\n      : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromSelf = <Value extends Schema.Any>(\n  value: Value\n): OptionFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),\n      encode: (value) => optionParse(ParseResult.encodeUnknown(value))\n    },\n    {\n      description: `Option<${format(value)}>`,\n      pretty: optionPretty,\n      arbitrary: optionArbitrary,\n      equivalence: option_.getEquivalence\n    }\n  )\n}\n\nconst makeNoneEncoded = {\n  _tag: \"None\"\n} as const\nconst makeSomeEncoded = <A>(value: A) => ({\n  _tag: \"Some\",\n  value\n} as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Option<Value extends Schema.Any> extends\n  AnnotableClass<\n    Option<Value>,\n    option_.Option<Schema.Type<Value>>,\n    OptionEncoded<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const Option = <Value extends Schema.Any>(value: Value): Option<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    optionEncoded(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: optionDecode,\n      encode: option_.match({\n        onNone: () => makeNoneEncoded,\n        onSome: makeSomeEncoded\n      })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNullOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromNullOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(NullOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrNull\n  })\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromNullishOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromNullishOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | null | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNullishOr = <Value extends Schema.Any>(\n  value: Value,\n  onNoneEncoding: null | undefined\n): OptionFromNullishOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NullishOr(value_),\n    OptionFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: option_.fromNullable,\n      encode: onNoneEncoding === null ? option_.getOrNull : option_.getOrUndefined\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface OptionFromUndefinedOr<Value extends Schema.Any> extends\n  AnnotableClass<\n    OptionFromUndefinedOr<Value>,\n    option_.Option<Schema.Type<Value>>,\n    Schema.Encoded<Value> | undefined,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromUndefinedOr = <Value extends Schema.Any>(\n  value: Value\n): OptionFromUndefinedOr<Value> => {\n  const value_ = asSchema(value)\n  return transform(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {\n    strict: true,\n    decode: option_.fromNullable,\n    encode: option_.getOrUndefined\n  })\n}\n\n/**\n * Transforms strings into an Option type, effectively filtering out empty or\n * whitespace-only strings by trimming them and checking their length. Returns\n * `none` for invalid inputs and `some` for valid non-empty strings.\n *\n * @example\n * import { Schema } from \"effect\"\n *\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\n * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n *\n * @category Option transformations\n * @since 3.10.0\n */\nexport const OptionFromNonEmptyTrimmedString = transform(String$, OptionFromSelf(NonEmptyTrimmedString), {\n  strict: true,\n  decode: (s) => {\n    const out = s.trim()\n    return out.length === 0 ? option_.none() : option_.some(out)\n  },\n  encode: option_.getOrElse(() => \"\")\n})\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}\n\n/**\n * @category Either utils\n * @since 3.10.0\n */\nexport type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>\n\nconst rightEncoded = <RA, RI, RR>(right: Schema<RA, RI, RR>): Schema<RightEncoded<RA>, RightEncoded<RI>, RR> =>\n  Struct({\n    _tag: Literal(\"Right\"),\n    right\n  }).annotations({ description: `RightEncoded<${format(right)}>` })\n\nconst leftEncoded = <LA, LI, LR>(left: Schema<LA, LI, LR>): Schema<LeftEncoded<LA>, LeftEncoded<LI>, LR> =>\n  Struct({\n    _tag: Literal(\"Left\"),\n    left\n  }).annotations({ description: `LeftEncoded<${format(left)}>` })\n\nconst eitherEncoded = <RA, RI, RR, LA, LI, LR>(\n  right: Schema<RA, RI, RR>,\n  left: Schema<LA, LI, LR>\n) =>\n  Union(rightEncoded(right), leftEncoded(left)).annotations({\n    description: `EitherEncoded<${format(left)}, ${format(right)}>`\n  })\n\nconst eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>\n  input._tag === \"Left\" ? either_.left(input.left) : either_.right(input.right)\n\nconst eitherArbitrary = <R, L>(\n  right: LazyArbitrary<R>,\n  left: LazyArbitrary<L>\n): LazyArbitrary<either_.Either<R, L>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Left\" as const), left: left(fc) }),\n    fc.record({ _tag: fc.constant(\"Right\" as const), right: right(fc) })\n  ).map(eitherDecode)\n\nconst eitherPretty = <R, L>(\n  right: pretty_.Pretty<R>,\n  left: pretty_.Pretty<L>\n): pretty_.Pretty<either_.Either<R, L>> =>\n  either_.match({\n    onLeft: (e) => `left(${left(e)})`,\n    onRight: (a) => `right(${right(a)})`\n  })\n\nconst eitherParse = <RR, R, LR, L>(\n  parseRight: ParseResult.DecodeUnknown<R, RR>,\n  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>\n): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>\n(u, options, ast) =>\n  either_.isEither(u) ?\n    either_.match(u, {\n      onLeft: (left) => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),\n      onRight: (right) => toComposite(parseRight(right, options), either_.right, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromSelf = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromSelf<R, L> => {\n  return declare(\n    [right, left],\n    {\n      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),\n      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))\n    },\n    {\n      description: `Either<${format(right)}, ${format(left)}>`,\n      pretty: eitherPretty,\n      arbitrary: eitherArbitrary,\n      equivalence: (right, left) => either_.getEquivalence({ left, right })\n    }\n  )\n}\n\nconst makeLeftEncoded = <E>(left: E) => (({\n  _tag: \"Left\",\n  left\n}) as const)\nconst makeRightEncoded = <A>(right: A) => (({\n  _tag: \"Right\",\n  right\n}) as const)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Either<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    Either<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    EitherEncoded<Schema.Encoded<R>, Schema.Encoded<L>>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @category Either transformations\n * @since 3.10.0\n */\nexport const Either = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): Either<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  return transform(\n    eitherEncoded(right_, left_),\n    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),\n    {\n      strict: true,\n      decode: eitherDecode,\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface EitherFromUnion<R extends Schema.All, L extends Schema.All> extends\n  AnnotableClass<\n    EitherFromUnion<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    Schema.Encoded<R> | Schema.Encoded<L>,\n    Schema.Context<R> | Schema.Context<L>\n  >\n{}\n\n/**\n * @example\n * import * as Schema from \"effect/Schema\"\n *\n * // Schema<string | number, Either<string, number>>\n * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n *\n * @category Either transformations\n * @since 3.10.0\n */\nexport const EitherFromUnion = <R extends Schema.All, L extends Schema.All>({ left, right }: {\n  readonly left: L\n  readonly right: R\n}): EitherFromUnion<R, L> => {\n  const right_ = asSchema(right)\n  const left_ = asSchema(left)\n  const toright = typeSchema(right_)\n  const toleft = typeSchema(left_)\n  const fromRight = transform(right_, rightEncoded(toright), {\n    strict: true,\n    decode: makeRightEncoded,\n    encode: (r) => r.right\n  })\n  const fromLeft = transform(left_, leftEncoded(toleft), {\n    strict: true,\n    decode: makeLeftEncoded,\n    encode: (l) => l.left\n  })\n  return transform(\n    Union(fromRight, fromLeft),\n    EitherFromSelf({ left: toleft, right: toright }),\n    {\n      strict: true,\n      decode: (from) => from._tag === \"Left\" ? either_.left(from.left) : either_.right(from.right),\n      encode: either_.match({ onLeft: makeLeftEncoded, onRight: makeRightEncoded })\n    }\n  )\n}\n\nconst mapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<Map<K, V>> => {\n  return (fc) => {\n    const items = fc.array(fc.tuple(key(fc), value(fc)))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Map(as))\n  }\n}\n\nconst readonlyMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<ReadonlyMap<K, V>> =>\n(map) =>\n  `new Map([${\n    Array.from(map.entries())\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst readonlyMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<ReadonlyMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))\n}\n\nconst readonlyMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>\n(u, options, ast) =>\n  Predicate.isMap(u) ?\n    toComposite(decodeUnknown(Array.from(u.entries()), options), (as) => new Map(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(\n  key: K,\n  value: V,\n  description: string\n): ReadonlyMapFromSelf<K, V> =>\n  declare(\n    [key, value],\n    {\n      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),\n      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))\n    },\n    {\n      description,\n      pretty: readonlyMapPretty,\n      arbitrary: mapArbitrary,\n      equivalence: readonlyMapEquivalence\n    }\n  )\n\n/**\n * @category ReadonlyMap\n * @since 3.10.0\n */\nexport const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category Map\n * @since 3.10.0\n */\nexport const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlyMap$<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): ReadonlyMap$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    ReadonlyMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Map$<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    Map$<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\nconst map = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): Map$<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    MapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => new Map(as), encode: (map) => Array.from(map.entries()) }\n  )\n}\n\nexport {\n  /**\n   * @category Map transformations\n   * @since 3.10.0\n   */\n  map as Map\n}\n\n/**\n * @category ReadonlyMap transformations\n * @since 3.10.0\n */\nexport const ReadonlyMapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<ReadonlyMap<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record that will be parsed into a ReadonlyMap\"\n    }),\n    ReadonlyMapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (record) => new Map(Object.entries(record)),\n      encode: record_.fromEntries\n    }\n  )\n\n/**\n * @category Map transformations\n * @since 3.10.0\n */\nexport const MapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {\n  key: Schema<KA, string, KR>\n  value: Schema<VA, VI, VR>\n}): Schema<Map<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>\n  transform(\n    Record({ key: encodedBoundSchema(key), value }).annotations({\n      description: \"a record that will be parsed into a Map\"\n    }),\n    MapFromSelf({ key, value: typeSchema(value) }),\n    {\n      strict: true,\n      decode: (record) => new Map(Object.entries(record)),\n      encode: record_.fromEntries\n    }\n  )\n\nconst setArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<ReadonlySet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Set(as))\n  }\n\nconst readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>\n  `new Set([${Array.from(set.values()).map((a) => item(a)).join(\", \")}])`\n\nconst readonlySetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<ReadonlySet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))\n}\n\nconst readonlySetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>\n(u, options, ast) =>\n  Predicate.isSet(u) ?\n    toComposite(decodeUnknown(Array.from(u.values()), options), (as) => new Set(as), ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>\n  declare(\n    [value],\n    {\n      decode: (item) => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description,\n      pretty: readonlySetPretty,\n      arbitrary: setArbitrary,\n      equivalence: readonlySetEquivalence\n    }\n  )\n\n/**\n * @category ReadonlySet\n * @since 3.10.0\n */\nexport const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>\n  setFromSelf_(value, `ReadonlySet<${format(value)}>`)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Set\n * @since 3.10.0\n */\nexport const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>\n  setFromSelf_(value, `Set<${format(value)}>`) as any\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ReadonlySet$<Value extends Schema.Any> extends\n  AnnotableClass<\n    ReadonlySet$<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category ReadonlySet transformations\n * @since 3.10.0\n */\nexport const ReadonlySet = <Value extends Schema.Any>(value: Value): ReadonlySet$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ReadonlySetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Set$<Value extends Schema.Any> extends\n  AnnotableClass<\n    Set$<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst set = <Value extends Schema.Any>(value: Value): Set$<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    SetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => new Set(as), encode: (set) => Array.from(set) }\n  )\n}\n\nexport {\n  /**\n   * @category Set transformations\n   * @since 3.10.0\n   */\n  set as Set\n}\n\nconst bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>\n  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`\n\nconst bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>\n  fc.tuple(fc.bigInt(), fc.integer()).map(([value, scale]) => bigDecimal_.make(value, scale))\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport class BigDecimalFromSelf extends declare(\n  bigDecimal_.isBigDecimal,\n  {\n    identifier: \"BigDecimalFromSelf\",\n    pretty: bigDecimalPretty,\n    arbitrary: bigDecimalArbitrary,\n    equivalence: () => bigDecimal_.Equivalence\n  }\n) {}\n\n/**\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimal extends transformOrFail(\n  String$.annotations({ description: \"a string that will be parsed into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num, _, ast) =>\n      bigDecimal_.fromString(num).pipe(option_.match({\n        onNone: () => ParseResult.fail(new ParseResult.Type(ast, num)),\n        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))\n      })),\n    encode: (val) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(val)))\n  }\n).annotations({ identifier: \"BigDecimal\" }) {}\n\n/**\n * A schema that transforms a `number` into a `BigDecimal`.\n * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport class BigDecimalFromNumber extends transformOrFail(\n  Number$.annotations({ description: \"a number that will be parsed into a BigDecimal\" }),\n  BigDecimalFromSelf,\n  {\n    strict: true,\n    decode: (num) => ParseResult.succeed(bigDecimal_.fromNumber(num)),\n    encode: (val) => ParseResult.succeed(bigDecimal_.unsafeToNumber(val))\n  }\n).annotations({ identifier: \"BigDecimalFromNumber\" }) {}\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/GreaterThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.greaterThan(a, min), {\n      schemaId: GreaterThanBigDecimalSchemaId,\n      [GreaterThanBigDecimalSchemaId]: { min },\n      description: `a BigDecimal greater than ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const GreaterThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/GreaterThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const greaterThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  min: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.greaterThanOrEqualTo(a, min), {\n      schemaId: GreaterThanOrEqualToBigDecimalSchemaId,\n      [GreaterThanOrEqualToBigDecimalSchemaId]: { min },\n      description: `a BigDecimal greater than or equal to ${bigDecimal_.format(min)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/LessThanBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.lessThan(a, max), {\n      schemaId: LessThanBigDecimalSchemaId,\n      [LessThanBigDecimalSchemaId]: { max },\n      description: `a BigDecimal less than ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const LessThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/LessThanOrEqualToBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const lessThanOrEqualToBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  max: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.lessThanOrEqualTo(a, max), {\n      schemaId: LessThanOrEqualToBigDecimalSchemaId,\n      [LessThanOrEqualToBigDecimalSchemaId]: { max },\n      description: `a BigDecimal less than or equal to ${bigDecimal_.format(max)}`,\n      ...annotations\n    })\n  )\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const PositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/PositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const positiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isPositive(a), {\n      schemaId: PositiveBigDecimalSchemaId,\n      description: `a positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  positiveBigDecimal({\n    identifier: \"PositiveBigDecimalFromSelf\",\n    title: \"PositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonNegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonNegativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value >= 0n, {\n      schemaId: NonNegativeBigDecimalSchemaId,\n      description: `a non-negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonNegativeBigDecimal({\n    identifier: \"NonNegativeBigDecimalFromSelf\",\n    title: \"NonNegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NegativeBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NegativeBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const negativeBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.isNegative(a), {\n      schemaId: NegativeBigDecimalSchemaId,\n      description: `a negative BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  negativeBigDecimal({\n    identifier: \"NegativeBigDecimalFromSelf\",\n    title: \"NegativeBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalSchemaId: unique symbol = Symbol.for(\n  \"effect/schema/NonPositiveBigDecimal\"\n)\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const nonPositiveBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => a.value <= 0n, {\n      schemaId: NonPositiveBigDecimalSchemaId,\n      description: `a non-positive BigDecimal`,\n      ...annotations\n    })\n  )\n\n/**\n * @category BigDecimal constructors\n * @since 3.10.0\n */\nexport const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(\n  nonPositiveBigDecimal({\n    identifier: \"NonPositiveBigDecimalFromSelf\",\n    title: \"NonPositiveBigDecimalFromSelf\"\n  })\n)\n\n/**\n * @category schema id\n * @since 3.10.0\n */\nexport const BetweenBigDecimalSchemaId: unique symbol = Symbol.for(\"effect/SchemaId/BetweenBigDecimal\")\n\n/**\n * @category BigDecimal filters\n * @since 3.10.0\n */\nexport const betweenBigDecimal = <A extends bigDecimal_.BigDecimal>(\n  minimum: bigDecimal_.BigDecimal,\n  maximum: bigDecimal_.BigDecimal,\n  annotations?: Annotations.Filter<A>\n) =>\n<I, R>(self: Schema<A, I, R>): filter<Schema<A, I, R>> =>\n  self.pipe(\n    filter((a) => bigDecimal_.between(a, { minimum, maximum }), {\n      schemaId: BetweenBigDecimalSchemaId,\n      [BetweenBigDecimalSchemaId]: { maximum, minimum },\n      description: `a BigDecimal between ${bigDecimal_.format(minimum)} and ${bigDecimal_.format(maximum)}`,\n      ...annotations\n    })\n  )\n\n/**\n * Clamps a `BigDecimal` between a minimum and a maximum value.\n *\n * @category BigDecimal transformations\n * @since 3.10.0\n */\nexport const clampBigDecimal =\n  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>\n  <A extends bigDecimal_.BigDecimal, I, R>(self: Schema<A, I, R>): transform<Schema<A, I, R>, filter<Schema<A>>> =>\n    transform(\n      self,\n      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),\n      { strict: false, decode: (self) => bigDecimal_.clamp(self, { minimum, maximum }), encode: identity }\n    )\n\nconst chunkArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<chunk_.Chunk<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(chunk_.fromIterable)\n  }\n\nconst chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>\n  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst chunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) ?\n    chunk_.isEmpty(u) ?\n      ParseResult.succeed(chunk_.empty())\n      : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => chunkParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => chunkParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `Chunk<${format(value)}>`,\n      pretty: chunkPretty,\n      arbitrary: chunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Chunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    Chunk<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport const Chunk = <Value extends Schema.Any>(value: Value): Chunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ChunkFromSelf(typeSchema(value_)),\n    {\n      strict: true,\n      decode: (as) => as.length === 0 ? chunk_.empty() : chunk_.fromIterable(as),\n      encode: chunk_.toReadonlyArray\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\nconst nonEmptyChunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.NonEmptyChunk<A>> => (fc) =>\n  fastCheck_.array(item(fc), { minLength: 1 }).map((as) => chunk_.unsafeFromNonEmptyArray(as as any))\n\nconst nonEmptyChunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.NonEmptyChunk<A>> => (c) =>\n  `NonEmptyChunk(${chunk_.toReadonlyArray(c).map(item).join(\", \")})`\n\nconst nonEmptyChunkParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<array_.NonEmptyReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<chunk_.NonEmptyChunk<A>, R> =>\n(u, options, ast) =>\n  chunk_.isChunk(u) && chunk_.isNonEmpty(u)\n    ? toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.unsafeFromNonEmptyArray, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Chunk\n * @since 3.10.0\n */\nexport const NonEmptyChunkFromSelf = <Value extends Schema.Any>(value: Value): NonEmptyChunkFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),\n      encode: (item) => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))\n    },\n    {\n      description: `NonEmptyChunk<${format(value)}>`,\n      pretty: nonEmptyChunkPretty,\n      arbitrary: nonEmptyChunkArbitrary,\n      equivalence: chunk_.getEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface NonEmptyChunk<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyChunk<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category Chunk transformations\n * @since 3.10.0\n */\nexport const NonEmptyChunk = <Value extends Schema.Any>(value: Value): NonEmptyChunk<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    NonEmptyArray(value_),\n    NonEmptyChunkFromSelf(typeSchema(value_)),\n    { strict: true, decode: chunk_.unsafeFromNonEmptyArray, encode: chunk_.toReadonlyArray }\n  )\n}\n\nconst toData = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(a: A): A =>\n  Array.isArray(a) ? data_.array(a) : data_.struct(a)\n\nconst dataArbitrary = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: LazyArbitrary<A>\n): LazyArbitrary<A> =>\n(fc) => item(fc).map(toData)\n\nconst dataPretty = <A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  item: pretty_.Pretty<A>\n): pretty_.Pretty<A> =>\n(d) => `Data(${item(d)})`\n\nconst dataParse = <R, A extends Readonly<Record<string, any>> | ReadonlyArray<any>>(\n  decodeUnknown: ParseResult.DecodeUnknown<A, R>\n): ParseResult.DeclarationDecodeUnknown<A, R> =>\n(u, options, ast) =>\n  Equal.isEqual(u) ?\n    toComposite(decodeUnknown(u, options), toData, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category Data transformations\n * @since 3.10.0\n */\nexport const DataFromSelf = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  declare(\n    [item],\n    {\n      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),\n      encode: (item) => dataParse(ParseResult.encodeUnknown(item))\n    },\n    {\n      description: `Data<${format(item)}>`,\n      pretty: dataPretty,\n      arbitrary: dataArbitrary\n    }\n  )\n\n/**\n * @category Data transformations\n * @since 3.10.0\n */\nexport const Data = <\n  R,\n  I extends Readonly<Record<string, any>> | ReadonlyArray<any>,\n  A extends Readonly<Record<string, any>> | ReadonlyArray<any>\n>(\n  item: Schema<A, I, R>\n): SchemaClass<A, I, R> =>\n  transform(\n    item,\n    DataFromSelf(typeSchema(item)),\n    { strict: false, decode: toData, encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a) }\n  )\n\ntype MissingSelfGeneric<Usage extends string, Params extends string = \"\"> =\n  `Missing \\`Self\\` generic - use \\`class Self extends ${Usage}<Self>()(${Params}{ ... })\\``\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Omit<Inherited, keyof Fields> & Proto\n\n  /** @since 3.10.0 */\n  readonly ast: AST.Transformation\n\n  make<Args extends Array<any>, X>(this: { new(...args: Args): X }, ...args: Args): X\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  extend<Extended = never>(identifier: string): <newFields extends Struct.Fields>(\n    fields: newFields | HasFields<newFields>,\n    annotations?: Annotations.Schema<Extended>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & newFields,\n      I & Struct.Encoded<newFields>,\n      R | Struct.Context<newFields>,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n\n  transformOrFail<Transformed = never>(identifier: string): <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFail\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    newFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: newFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<newFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<newFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: Annotations.Schema<Transformed>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFailFrom\">\n    : Class<\n      Transformed,\n      Fields & newFields,\n      I,\n      R | Struct.Context<newFields> | R2 | R3,\n      C & Struct.Constructor<newFields>,\n      Self,\n      Proto\n    >\n}\n\ntype HasFields<Fields extends Struct.Fields> = Struct<Fields> | {\n  readonly [RefineSchemaId]: HasFields<Fields>\n}\n\nconst isField = (u: unknown) => isSchema(u) || isPropertySignature(u)\n\nconst isFields = <Fields extends Struct.Fields>(fields: object): fields is Fields =>\n  util_.ownKeys(fields).every((key) => isField((fields as any)[key]))\n\nconst getFields = <Fields extends Struct.Fields>(hasFields: HasFields<Fields>): Fields =>\n  \"fields\" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId])\n\nconst getSchemaFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Schema.Any =>\n  isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr))\n\nconst getFieldsFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Fields =>\n  isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr)\n\n/**\n * @category classes\n * @since 3.10.0\n */\nexport const Class = <Self = never>(identifier: string) =>\n<Fields extends Struct.Fields>(\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"Class\">\n  : Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Fields>,\n    {},\n    {}\n  > =>\n  makeClass({\n    kind: \"Class\",\n    identifier,\n    schema: getSchemaFromFieldsOr(fieldsOr),\n    fields: getFieldsFromFieldsOr(fieldsOr),\n    Base: data_.Class,\n    annotations\n  })\n\n/** @internal */\nexport const getClassTag = <Tag extends string>(tag: Tag) =>\n  withConstructorDefault(propertySignature(Literal(tag)), () => tag)\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedClass = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `>\n  : TaggedClass<Self, Tag, { readonly _tag: tag<Tag> } & Fields> =>\n{\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedClass extends makeClass({\n    kind: \"TaggedClass\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base: data_.Class,\n    annotations\n  }) {\n    static _tag = tag\n  } as any\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedError = <Self = never>(identifier?: string) =>\n<Tag extends string, Fields extends Struct.Fields>(\n  tag: Tag,\n  fieldsOr: Fields | HasFields<Fields>,\n  annotations?: Annotations.Schema<Self>\n): [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `>\n  : TaggedErrorClass<\n    Self,\n    Tag,\n    { readonly _tag: tag<Tag> } & Fields\n  > =>\n{\n  class Base extends data_.Error {}\n  ;(Base.prototype as any).name = tag\n  const fields = getFieldsFromFieldsOr(fieldsOr)\n  const schema = getSchemaFromFieldsOr(fieldsOr)\n  const newFields = { _tag: getClassTag(tag) }\n  const taggedFields = extendFields(newFields, fields)\n  return class TaggedErrorClass extends makeClass({\n    kind: \"TaggedError\",\n    identifier: identifier ?? tag,\n    schema: extend(schema, Struct(newFields)),\n    fields: taggedFields,\n    Base,\n    annotations,\n    disableToString: true\n  }) {\n    static _tag = tag\n    get message(): string {\n      return `{ ${\n        util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n          .join(\", \")\n      } }`\n    }\n  } as any\n}\n\nconst extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {\n  const out = { ...a }\n  for (const key of util_.ownKeys(b)) {\n    if (key in a) {\n      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key))\n    }\n    out[key] = b[key]\n  }\n  return out\n}\n\n// does not overwrite existing title annotation\nconst orElseTitleAnnotation = <A, I, R>(schema: Schema<A, I, R>, title: string): Schema<A, I, R> => {\n  const annotation = AST.getTitleAnnotation(schema.ast)\n  if (option_.isNone(annotation)) {\n    return schema.annotations({ title })\n  }\n  return schema\n}\n\ntype MakeOptions = boolean | {\n  readonly disableValidation?: boolean\n}\n\nconst getDisableValidationMakeOption = (options: MakeOptions | undefined): boolean =>\n  Predicate.isBoolean(options) ? options : options?.disableValidation ?? false\n\nconst makeClass = ({ Base, annotations, disableToString, fields, identifier, kind, schema }: {\n  kind: \"Class\" | \"TaggedClass\" | \"TaggedError\" | \"TaggedRequest\"\n  identifier: string\n  schema: Schema.Any\n  fields: Struct.Fields\n  Base: new(...args: ReadonlyArray<any>) => any\n  annotations?: Annotations.Schema<any> | undefined\n  disableToString?: boolean | undefined\n}): any => {\n  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`)\n  const validateSchema = orElseTitleAnnotation(schema, `${identifier} (Constructor)`)\n  const encodedSide: Schema.Any = orElseTitleAnnotation(schema, `${identifier} (Encoded side)`)\n  const typeSide = orElseTitleAnnotation(typeSchema(schema), `${identifier} (Type side)`)\n  const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u)\n  const klass = class extends Base {\n    constructor(\n      props: { [x: string | symbol]: unknown } = {},\n      options: MakeOptions = false\n    ) {\n      props = { ...props }\n      if (kind !== \"Class\") {\n        delete props[\"_tag\"]\n      }\n      props = lazilyMergeDefaults(fields, props)\n      if (!getDisableValidationMakeOption(options)) {\n        props = ParseResult.validateSync(validateSchema)(props)\n      }\n      super(props, true)\n    }\n\n    // ----------------\n    // Schema interface\n    // ----------------\n\n    static [TypeId] = variance\n\n    static get ast() {\n      const declaration: Schema.Any = declare(\n        [typeSide],\n        {\n          decode: () => (input, _, ast) =>\n            input instanceof this || fallbackInstanceOf(input)\n              ? ParseResult.succeed(input)\n              : ParseResult.fail(new ParseResult.Type(ast, input)),\n          encode: () => (input, options) =>\n            input instanceof this\n              ? ParseResult.succeed(input)\n              : ParseResult.map(\n                ParseResult.encodeUnknown(typeSide)(input, options),\n                (props) => new this(props, true)\n              )\n        },\n        {\n          identifier,\n          title: identifier,\n          description: `an instance of ${identifier}`,\n          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,\n          // @ts-expect-error\n          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),\n          equivalence: identity,\n          [AST.SurrogateAnnotationId]: typeSide.ast,\n          ...annotations\n        }\n      )\n      const transformation = transform(\n        encodedSide,\n        declaration,\n        { strict: true, decode: (input) => new this(input, true), encode: identity }\n      ).annotations({ [AST.SurrogateAnnotationId]: schema.ast })\n      return transformation.ast\n    }\n\n    static pipe() {\n      return pipeArguments(this, arguments)\n    }\n\n    static annotations(annotations: Annotations.Schema<any>) {\n      return make(this.ast).annotations(annotations)\n    }\n\n    static toString() {\n      return `(${String(encodedSide)} <-> ${identifier})`\n    }\n\n    // ----------------\n    // Class interface\n    // ----------------\n\n    static make(...args: Array<any>) {\n      return new this(...args)\n    }\n\n    static fields = { ...fields }\n\n    static identifier = identifier\n\n    static extend<Extended>(identifier: string) {\n      return (newFieldsOr: Struct.Fields | HasFields<Struct.Fields>, annotations?: Annotations.Schema<Extended>) => {\n        const newFields = getFieldsFromFieldsOr(newFieldsOr)\n        const newSchema = getSchemaFromFieldsOr(newFieldsOr)\n        const extendedFields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: extend(schema, newSchema),\n          fields: extendedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFail<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            schema,\n            typeSchema(Struct(transformedFields)),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    static transformOrFailFrom<Transformed>(identifier: string) {\n      return (newFields: Struct.Fields, options: any, annotations?: Annotations.Schema<Transformed>) => {\n        const transformedFields: Struct.Fields = extendFields(fields, newFields)\n        return makeClass({\n          kind,\n          identifier,\n          schema: transformOrFail(\n            encodedSchema(schema),\n            Struct(transformedFields),\n            options\n          ),\n          fields: transformedFields,\n          Base: this,\n          annotations\n        })\n      }\n    }\n\n    // ----------------\n    // other\n    // ----------------\n\n    get [classSymbol]() {\n      return classSymbol\n    }\n  }\n  if (disableToString !== true) {\n    Object.defineProperty(klass.prototype, \"toString\", {\n      value() {\n        return `${identifier}({ ${\n          util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)\n            .join(\", \")\n        } })`\n      },\n      configurable: true\n    })\n  }\n  return klass\n}\n\n/**\n * @category FiberId\n * @since 3.10.0\n */\nexport type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }\n\nconst FiberIdNoneEncoded = Struct({\n  _tag: Literal(\"None\")\n}).annotations({ identifier: \"FiberIdNoneEncoded\" })\n\nconst FiberIdRuntimeEncoded = Struct({\n  _tag: Literal(\"Runtime\"),\n  id: Int.annotations({\n    title: \"id\",\n    description: \"id\"\n  }),\n  startTimeMillis: Int.annotations({\n    title: \"startTimeMillis\",\n    description: \"startTimeMillis\"\n  })\n}).annotations({ identifier: \"FiberIdRuntimeEncoded\" })\n\nconst FiberIdCompositeEncoded = Struct({\n  _tag: Literal(\"Composite\"),\n  left: suspend(() => FiberIdEncoded),\n  right: suspend(() => FiberIdEncoded)\n}).annotations({ identifier: \"FiberIdCompositeEncoded\" })\n\nconst FiberIdEncoded: Schema<FiberIdEncoded> = Union(\n  FiberIdNoneEncoded,\n  FiberIdRuntimeEncoded,\n  FiberIdCompositeEncoded\n).annotations({ identifier: \"FiberIdEncoded\" })\n\nconst fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>\n  fc.letrec((tie) => ({\n    None: fc.record({ _tag: fc.constant(\"None\" as const) }),\n    Runtime: fc.record({ _tag: fc.constant(\"Runtime\" as const), id: fc.integer(), startTimeMillis: fc.integer() }),\n    Composite: fc.record({ _tag: fc.constant(\"Composite\" as const), left: tie(\"FiberId\"), right: tie(\"FiberId\") }),\n    FiberId: fc.oneof(tie(\"None\"), tie(\"Runtime\"), tie(\"Composite\")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>\n  })).FiberId.map(fiberIdDecode)\n\nconst fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {\n  switch (fiberId._tag) {\n    case \"None\":\n      return \"FiberId.none\"\n    case \"Runtime\":\n      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`\n    case \"Composite\":\n      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`\n  }\n}\n\n/**\n * @category FiberId constructors\n * @since 3.10.0\n */\nexport class FiberIdFromSelf extends declare(\n  fiberId_.isFiberId,\n  {\n    identifier: \"FiberIdFromSelf\",\n    pretty: () => fiberIdPretty,\n    arbitrary: () => fiberIdArbitrary\n  }\n) {}\n\nconst fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {\n  switch (input._tag) {\n    case \"None\":\n      return fiberId_.none\n    case \"Runtime\":\n      return fiberId_.runtime(input.id, input.startTimeMillis)\n    case \"Composite\":\n      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))\n  }\n}\n\nconst fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {\n  switch (input._tag) {\n    case \"None\":\n      return { _tag: \"None\" }\n    case \"Runtime\":\n      return { _tag: \"Runtime\", id: input.id, startTimeMillis: input.startTimeMillis }\n    case \"Composite\":\n      return {\n        _tag: \"Composite\",\n        left: fiberIdEncode(input.left),\n        right: fiberIdEncode(input.right)\n      }\n  }\n}\n\n/**\n * @category FiberId transformations\n * @since 3.10.0\n */\nexport class FiberId extends transform(\n  FiberIdEncoded,\n  FiberIdFromSelf,\n  { strict: true, decode: fiberIdDecode, encode: fiberIdEncode }\n).annotations({ identifier: \"FiberId\" }) {}\n\n/**\n * @category Cause utils\n * @since 3.10.0\n */\nexport type CauseEncoded<E, D> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: D\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n\nconst causeDieEncoded = <D, DI, R>(defect: Schema<D, DI, R>) =>\n  Struct({\n    _tag: Literal(\"Die\"),\n    defect\n  })\n\nconst CauseEmptyEncoded = Struct({\n  _tag: Literal(\"Empty\")\n})\n\nconst causeFailEncoded = <E, EI, R>(error: Schema<E, EI, R>) =>\n  Struct({\n    _tag: Literal(\"Fail\"),\n    error\n  })\n\nconst CauseInterruptEncoded = Struct({\n  _tag: Literal(\"Interrupt\"),\n  fiberId: FiberIdEncoded\n})\n\nconst causeParallelEncoded = <E, EI, D, DI, R>(causeEncoded: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R>) =>\n  Struct({\n    _tag: Literal(\"Parallel\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeSequentialEncoded = <E, EI, D, DI, R>(causeEncoded: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R>) =>\n  Struct({\n    _tag: Literal(\"Sequential\"),\n    left: causeEncoded,\n    right: causeEncoded\n  })\n\nconst causeEncoded = <E, EI, D, DI, R1, R2>(\n  error: Schema<E, EI, R1>,\n  defect: Schema<D, DI, R2>\n): Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R1 | R2> => {\n  const recur = suspend(() => out)\n  const out: Schema<CauseEncoded<E, D>, CauseEncoded<EI, DI>, R1 | R2> = Union(\n    CauseEmptyEncoded,\n    causeFailEncoded(error),\n    causeDieEncoded(defect),\n    CauseInterruptEncoded,\n    causeSequentialEncoded(recur),\n    causeParallelEncoded(recur)\n  ).annotations({ title: `CauseEncoded<${format(error)}>` })\n  return out\n}\n\nconst causeArbitrary = <E>(\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<cause_.Cause<E>> =>\n(fc) =>\n  fc.letrec((tie) => ({\n    Empty: fc.record({ _tag: fc.constant(\"Empty\" as const) }),\n    Fail: fc.record({ _tag: fc.constant(\"Fail\" as const), error: error(fc) }),\n    Die: fc.record({ _tag: fc.constant(\"Die\" as const), defect: defect(fc) }),\n    Interrupt: fc.record({ _tag: fc.constant(\"Interrupt\" as const), fiberId: fiberIdArbitrary(fc) }),\n    Sequential: fc.record({ _tag: fc.constant(\"Sequential\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Parallel: fc.record({ _tag: fc.constant(\"Parallel\" as const), left: tie(\"Cause\"), right: tie(\"Cause\") }),\n    Cause: fc.oneof(\n      tie(\"Empty\"),\n      tie(\"Fail\"),\n      tie(\"Die\"),\n      tie(\"Interrupt\"),\n      tie(\"Sequential\"),\n      tie(\"Parallel\")\n    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>\n  })).Cause.map(causeDecode)\n\nconst causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {\n  const f = (cause: cause_.Cause<E>): string => {\n    switch (cause._tag) {\n      case \"Empty\":\n        return \"Cause.empty\"\n      case \"Fail\":\n        return `Cause.fail(${error(cause.error)})`\n      case \"Die\":\n        return `Cause.die(${cause_.pretty(cause)})`\n      case \"Interrupt\":\n        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`\n      case \"Sequential\":\n        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`\n      case \"Parallel\":\n        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`\n    }\n  }\n  return f(cause)\n}\n\nconst causeParse = <A, D, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A, D>, R>\n): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>\n(u, options, ast) =>\n  cause_.isCause(u) ?\n    toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    CauseFromSelf<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const CauseFromSelf = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): CauseFromSelf<E, D> => {\n  return declare(\n    [error, defect],\n    {\n      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),\n      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))\n    },\n    {\n      title: `Cause<${error.ast}>`,\n      pretty: causePretty,\n      arbitrary: causeArbitrary\n    }\n  )\n}\n\nfunction causeDecode<E>(cause: CauseEncoded<E, unknown>): cause_.Cause<E> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return cause_.empty\n    case \"Fail\":\n      return cause_.fail(cause.error)\n    case \"Die\":\n      return cause_.die(cause.defect)\n    case \"Interrupt\":\n      return cause_.interrupt(fiberIdDecode(cause.fiberId))\n    case \"Sequential\":\n      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))\n    case \"Parallel\":\n      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))\n  }\n}\n\nfunction causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E, unknown> {\n  switch (cause._tag) {\n    case \"Empty\":\n      return { _tag: \"Empty\" }\n    case \"Fail\":\n      return { _tag: \"Fail\", error: cause.error }\n    case \"Die\":\n      return { _tag: \"Die\", defect: cause.defect }\n    case \"Interrupt\":\n      return { _tag: \"Interrupt\", fiberId: cause.fiberId }\n    case \"Sequential\":\n      return {\n        _tag: \"Sequential\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n    case \"Parallel\":\n      return {\n        _tag: \"Parallel\",\n        left: causeEncode(cause.left),\n        right: causeEncode(cause.right)\n      }\n  }\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Cause<E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    Cause<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Cause transformations\n * @since 3.10.0\n */\nexport const Cause = <E extends Schema.All, D extends Schema.All>({ defect, error }: {\n  readonly error: E\n  readonly defect: D\n}): Cause<E, D> => {\n  const error_ = asSchema(error)\n  const defect_ = asSchema(defect)\n  return transform(\n    causeEncoded(error_, defect_),\n    CauseFromSelf({ error: typeSchema(error_), defect: Unknown }),\n    { strict: false, decode: causeDecode, encode: causeEncode }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Defect extends transform<typeof Unknown, typeof Unknown> {}\n\n/**\n * Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.\n * It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),\n * or converts other values to their string representations.\n *\n * When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,\n * or other values into their string forms.\n *\n * This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.\n *\n * @category defect\n * @since 3.10.0\n */\nexport const Defect: Defect = transform(\n  Unknown,\n  Unknown,\n  {\n    strict: true,\n    decode: (u) => {\n      if (Predicate.isObject(u) && \"message\" in u && typeof u.message === \"string\") {\n        const err = new Error(u.message, { cause: u })\n        if (\"name\" in u && typeof u.name === \"string\") {\n          err.name = u.name\n        }\n        err.stack = \"stack\" in u && typeof u.stack === \"string\" ? u.stack : \"\"\n        return err\n      }\n      return String(u)\n    },\n    encode: (defect) => {\n      if (defect instanceof Error) {\n        return {\n          name: defect.name,\n          message: defect.message\n          // no stack because of security reasons\n        }\n      }\n      return String(defect)\n    }\n  }\n).annotations({ identifier: \"Defect\" })\n\n/**\n * @category Exit utils\n * @since 3.10.0\n */\nexport type ExitEncoded<A, E, D> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\nconst exitFailureEncoded = <E, EI, ER, D, DI, DR>(\n  error: Schema<E, EI, ER>,\n  defect: Schema<D, DI, DR>\n) =>\n  Struct({\n    _tag: Literal(\"Failure\"),\n    cause: causeEncoded(error, defect)\n  })\n\nconst exitSuccessEncoded = <A, I, R>(\n  value: Schema<A, I, R>\n) =>\n  Struct({\n    _tag: Literal(\"Success\"),\n    value\n  })\n\nconst exitEncoded = <A, I, R, E, EI, ER, D, DI, DR>(\n  value: Schema<A, I, R>,\n  error: Schema<E, EI, ER>,\n  defect: Schema<D, DI, DR>\n): Schema<ExitEncoded<A, E, D>, ExitEncoded<I, EI, DI>, R | ER | DR> =>\n  Union(\n    exitFailureEncoded(error, defect),\n    exitSuccessEncoded(value)\n  ).annotations({\n    title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`\n  })\n\nconst exitDecode = <A, E>(input: ExitEncoded<A, E, unknown>): exit_.Exit<A, E> => {\n  switch (input._tag) {\n    case \"Failure\":\n      return exit_.failCause(causeDecode(input.cause))\n    case \"Success\":\n      return exit_.succeed(input.value)\n  }\n}\n\nconst exitArbitrary = <A, E>(\n  value: LazyArbitrary<A>,\n  error: LazyArbitrary<E>,\n  defect: LazyArbitrary<unknown>\n): LazyArbitrary<exit_.Exit<A, E>> =>\n(fc) =>\n  fc.oneof(\n    fc.record({ _tag: fc.constant(\"Failure\" as const), cause: causeArbitrary(error, defect)(fc) }),\n    fc.record({ _tag: fc.constant(\"Success\" as const), value: value(fc) })\n  ).map(exitDecode)\n\nconst exitPretty =\n  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>\n    exit._tag === \"Failure\"\n      ? `Exit.failCause(${causePretty(error)(exit.cause)})`\n      : `Exit.succeed(${value(exit.value)})`\n\nconst exitParse = <A, R, E, ER>(\n  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,\n  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>\n): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>\n(u, options, ast) =>\n  exit_.isExit(u) ?\n    exit_.match(u, {\n      onFailure: (cause) => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),\n      onSuccess: (value) => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)\n    })\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    ExitFromSelf<A, E, D>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n    Schema.Context<A> | Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const ExitFromSelf = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): ExitFromSelf<A, E, D> =>\n  declare(\n    [success, failure, defect],\n    {\n      decode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.decodeUnknown(success),\n          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))\n        ),\n      encode: (success, failure, defect) =>\n        exitParse(\n          ParseResult.encodeUnknown(success),\n          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))\n        )\n    },\n    {\n      title: `Exit<${success.ast}, ${failure.ast}>`,\n      pretty: exitPretty,\n      arbitrary: exitArbitrary\n    }\n  )\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  AnnotableClass<\n    Exit<A, E, D>,\n    exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n    ExitEncoded<Schema.Encoded<A>, Schema.Encoded<E>, Schema.Encoded<D>>,\n    Schema.Context<A> | Schema.Context<E> | Schema.Context<D>\n  >\n{}\n\n/**\n * @category Exit transformations\n * @since 3.10.0\n */\nexport const Exit = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(\n  { defect, failure, success }: {\n    readonly failure: E\n    readonly success: A\n    readonly defect: D\n  }\n): Exit<A, E, D> => {\n  const success_ = asSchema(success)\n  const failure_ = asSchema(failure)\n  const defect_ = asSchema(defect)\n  return transform(\n    exitEncoded(success_, failure_, defect_),\n    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: Unknown }),\n    {\n      strict: false,\n      decode: exitDecode,\n      encode: (exit) =>\n        exit._tag === \"Failure\"\n          ? { _tag: \"Failure\", cause: exit.cause } as const\n          : { _tag: \"Success\", value: exit.value } as const\n    }\n  )\n}\n\nconst hashSetArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<hashSet_.HashSet<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(\n      hashSet_.fromIterable\n    )\n  }\n\nconst hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>\n  `HashSet(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst hashSetEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<hashSet_.HashSet<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>\n(u, options, ast) =>\n  hashSet_.isHashSet(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSetFromSelf = <Value extends Schema.Any>(\n  value: Value\n): HashSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => hashSetParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => hashSetParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `HashSet<${format(value)}>`,\n      pretty: hashSetPretty,\n      arbitrary: hashSetArbitrary,\n      equivalence: hashSetEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    HashSet<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category HashSet transformations\n * @since 3.10.0\n */\nexport const HashSet = <Value extends Schema.Any>(value: Value): HashSet<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    HashSetFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => hashSet_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst hashMapArbitrary = <K, V>(\n  key: LazyArbitrary<K>,\n  value: LazyArbitrary<V>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<hashMap_.HashMap<K, V>> =>\n(fc) => {\n  const items = fc.array(fc.tuple(key(fc), value(fc)))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(hashMap_.fromIterable)\n}\n\nconst hashMapPretty = <K, V>(\n  key: pretty_.Pretty<K>,\n  value: pretty_.Pretty<V>\n): pretty_.Pretty<hashMap_.HashMap<K, V>> =>\n(map) =>\n  `HashMap([${\n    Array.from(map)\n      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)\n      .join(\", \")\n  }])`\n\nconst hashMapEquivalence = <K, V>(\n  key: Equivalence.Equivalence<K>,\n  value: Equivalence.Equivalence<V>\n): Equivalence.Equivalence<hashMap_.HashMap<K, V>> => {\n  const arrayEquivalence = array_.getEquivalence(\n    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))\n  )\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst hashMapParse = <R, K, V>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>\n): ParseResult.DeclarationDecodeUnknown<hashMap_.HashMap<K, V>, R> =>\n(u, options, ast) =>\n  hashMap_.isHashMap(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), hashMap_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMapFromSelf<K, V> => {\n  return declare(\n    [key, value],\n    {\n      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),\n      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))\n    },\n    {\n      description: `HashMap<${format(key)}, ${format(value)}>`,\n      pretty: hashMapPretty,\n      arbitrary: hashMapArbitrary,\n      equivalence: hashMapEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface HashMap<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableClass<\n    HashMap<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>,\n    Schema.Context<K> | Schema.Context<V>\n  >\n{}\n\n/**\n * @category HashMap transformations\n * @since 3.10.0\n */\nexport const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {\n  readonly key: K\n  readonly value: V\n}): HashMap<K, V> => {\n  const key_ = asSchema(key)\n  const value_ = asSchema(value)\n  return transform(\n    Array$(Tuple(key_, value_)),\n    HashMapFromSelf({ key: typeSchema(key_), value: typeSchema(value_) }),\n    { strict: true, decode: (as) => hashMap_.fromIterable(as), encode: (map) => Array.from(map) }\n  )\n}\n\nconst listArbitrary =\n  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<list_.List<A>> => (fc) => {\n    const items = fc.array(item(fc))\n    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(list_.fromIterable)\n  }\n\nconst listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>\n  `List(${Array.from(set).map((a) => item(a)).join(\", \")})`\n\nconst listEquivalence = <A>(\n  item: Equivalence.Equivalence<A>\n): Equivalence.Equivalence<list_.List<A>> => {\n  const arrayEquivalence = array_.getEquivalence(item)\n  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))\n}\n\nconst listParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>\n): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>\n(u, options, ast) =>\n  list_.isList(u) ?\n    toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u)\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const ListFromSelf = <Value extends Schema.Any>(\n  value: Value\n): ListFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => listParse(ParseResult.decodeUnknown(Array$(item))),\n      encode: (item) => listParse(ParseResult.encodeUnknown(Array$(item)))\n    },\n    {\n      description: `List<${format(value)}>`,\n      pretty: listPretty,\n      arbitrary: listArbitrary,\n      equivalence: listEquivalence\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface List<Value extends Schema.Any> extends\n  AnnotableClass<\n    List<Value>,\n    list_.List<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category List transformations\n * @since 3.10.0\n */\nexport const List = <Value extends Schema.Any>(value: Value): List<Value> => {\n  const value_ = asSchema(value)\n  return transform(\n    Array$(value_),\n    ListFromSelf(typeSchema(value_)),\n    { strict: true, decode: (as) => list_.fromIterable(as), encode: (set) => Array.from(set) }\n  )\n}\n\nconst sortedSetArbitrary = <A>(\n  item: LazyArbitrary<A>,\n  ord: Order.Order<A>,\n  ctx: ArbitraryGenerationContext\n): LazyArbitrary<sortedSet_.SortedSet<A>> =>\n(fc) => {\n  const items = fc.array(item(fc))\n  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) =>\n    sortedSet_.fromIterable(as, ord)\n  )\n}\n\nconst sortedSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<sortedSet_.SortedSet<A>> => (set) =>\n  `new SortedSet([${Array.from(sortedSet_.values(set)).map((a) => item(a)).join(\", \")}])`\n\nconst sortedSetParse = <A, R>(\n  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>,\n  ord: Order.Order<A>\n): ParseResult.DeclarationDecodeUnknown<sortedSet_.SortedSet<A>, R> =>\n(u, options, ast) =>\n  sortedSet_.isSortedSet(u) ?\n    toComposite(\n      decodeUnknown(Array.from(sortedSet_.values(u)), options),\n      (as): sortedSet_.SortedSet<A> => sortedSet_.fromIterable(as, ord),\n      ast,\n      u\n    )\n    : ParseResult.fail(new ParseResult.Type(ast, u))\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSetFromSelf = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>,\n  ordI: Order.Order<Schema.Encoded<Value>>\n): SortedSetFromSelf<Value> => {\n  return declare(\n    [value],\n    {\n      decode: (item) => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),\n      encode: (item) => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)\n    },\n    {\n      description: `SortedSet<${format(value)}>`,\n      pretty: sortedSetPretty,\n      arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),\n      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()\n    }\n  )\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface SortedSet<Value extends Schema.Any> extends\n  AnnotableClass<\n    SortedSet<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    ReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{}\n\n/**\n * @category SortedSet transformations\n * @since 3.10.0\n */\nexport const SortedSet = <Value extends Schema.Any>(\n  value: Value,\n  ordA: Order.Order<Schema.Type<Value>>\n): SortedSet<Value> => {\n  const value_ = asSchema(value)\n  const to = typeSchema(value_)\n  return transform(\n    Array$(value_),\n    SortedSetFromSelf<typeof to>(to, ordA, ordA),\n    {\n      strict: true,\n      decode: (as) => sortedSet_.fromIterable(as, ordA),\n      encode: (set) => Array.from(sortedSet_.values(set))\n    }\n  )\n}\n\n/**\n * Converts an arbitrary value to a `boolean` by testing whether it is truthy.\n * Uses `!!val` to coerce the value to a `boolean`.\n *\n * @see https://developer.mozilla.org/docs/Glossary/Truthy\n * @category boolean constructors\n * @since 3.10.0\n */\nexport class BooleanFromUnknown extends transform(\n  Unknown,\n  Boolean$,\n  { strict: true, decode: Predicate.isTruthy, encode: identity }\n).annotations({ identifier: \"BooleanFromUnknown\" }) {}\n\n/**\n * @category Config validations\n * @since 3.10.0\n */\nexport const Config = <A>(name: string, schema: Schema<A, string>): config_.Config<A> => {\n  const decodeEither_ = decodeEither(schema)\n  return config_.string(name).pipe(\n    config_.mapOrFail((a) =>\n      decodeEither_(a).pipe(\n        either_.mapLeft((error) => configError_.InvalidData([], ParseResult.TreeFormatter.formatErrorSync(error)))\n      )\n    )\n  )\n}\n\n// ---------------------------------------------\n// Serializable\n// ---------------------------------------------\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolSerializable: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbol\"\n)\n\n/**\n * The `Serializable` trait allows objects to define their own schema for\n * serialization.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace Serializable {\n  /**\n   * @since 3.10.0\n   */\n  export type Type<T> = T extends Serializable<infer A, infer _I, infer _R> ? A : never\n  /**\n   * @since 3.10.0\n   */\n  export type Encoded<T> = T extends Serializable<infer _A, infer I, infer _R> ? I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends Serializable<infer _A, infer _I, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = Serializable<any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | Serializable<any, never, unknown>\n    | Serializable<never, any, unknown>\n    | Serializable<never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializable = <S extends Serializable.All>(\n  serializable: S\n): Serializable<Serializable.Type<S>, Serializable.Encoded<S>, Serializable.Context<S>> => serializable as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const serializableSchema = <A, I, R>(self: Serializable<A, I, R>): Schema<A, I, R> => self[symbolSerializable]\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serialize = <A, I, R>(self: Serializable<A, I, R>): Effect.Effect<I, ParseResult.ParseError, R> =>\n  encodeUnknown(self[symbolSerializable])(self)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserialize: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<A, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R> =>\n    decodeUnknown(self[symbolSerializable])(value)\n)\n\n/**\n * @since 3.10.0\n * @category symbol\n */\nexport const symbolWithResult: unique symbol = Symbol.for(\n  \"effect/Schema/Serializable/symbolResult\"\n)\n\n/**\n * The `WithResult` trait is designed to encapsulate the outcome of an\n * operation, distinguishing between success and failure cases. Each case is\n * associated with a schema that defines the structure and types of the success\n * or failure data.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace WithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Success<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _A : never\n  /**\n   * @since 3.10.0\n   */\n  export type SuccessEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _I : never\n  /**\n   * @since 3.10.0\n   */\n  export type Failure<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _E : never\n  /**\n   * @since 3.10.0\n   */\n  export type FailureEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _EI : never\n\n  /**\n   * @since 3.10.0\n   */\n  export type Context<T> = T extends WithResult<infer _SA, infer _SI, infer _FA, infer _FI, infer R> ? R : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = WithResult<any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | WithResult<any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asWithResult = <WR extends WithResult.All>(\n  withExit: WR\n): WithResult<\n  WithResult.Success<WR>,\n  WithResult.SuccessEncoded<WR>,\n  WithResult.Failure<WR>,\n  WithResult.FailureEncoded<WR>,\n  WithResult.Context<WR>\n> => withExit as any\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const failureSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<FA, FI, R> =>\n  self[symbolWithResult].failure\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const successSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<SA, SI, R> =>\n  self[symbolWithResult].success\n\nconst exitSchemaCache = globalValue(\n  \"effect/Schema/Serializable/exitSchemaCache\",\n  () => new WeakMap<object, Schema<any, any, any>>()\n)\n\n/**\n * @since 3.10.0\n * @category accessor\n */\nexport const exitSchema = <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>): Schema<\n  exit_.Exit<SA, FA>,\n  ExitEncoded<SI, FI, unknown>,\n  R\n> => {\n  const proto = Object.getPrototypeOf(self)\n  if (!(symbolWithResult in proto)) {\n    return Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n  }\n  let schema = exitSchemaCache.get(proto)\n  if (schema === undefined) {\n    schema = Exit({\n      failure: failureSchema(self),\n      success: successSchema(self),\n      defect: Defect\n    })\n    exitSchemaCache.set(proto, schema)\n  }\n  return schema\n}\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <FA>(value: FA): <SA, SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<FI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeFailure: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (\n    value: unknown\n  ): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<FA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<FA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].failure)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA>(value: SA): <SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SI, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R> =>\n    encode(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeSuccess: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<SA, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<SA, ParseResult.ParseError, R>\n} = dual(\n  2,\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<SA, ParseResult.ParseError, R> => decodeUnknown(self[symbolWithResult].success)(value)\n)\n\n/**\n * @since 3.10.0\n * @category encoding\n */\nexport const serializeExit: {\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, FA>(value: exit_.Exit<SA, FA>): <SI, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category encoding\n   */\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: exit_.Exit<SA, FA>\n  ): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: exit_.Exit<SA, FA>\n): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R> => encode(exitSchema(self))(value))\n\n/**\n * @since 3.10.0\n * @category decoding\n */\nexport const deserializeExit: {\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  (value: unknown): <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>\n  ) => Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n  /**\n   * @since 3.10.0\n   * @category decoding\n   */\n  <SA, SI, FA, FI, R>(\n    self: WithResult<SA, SI, FA, FI, R>,\n    value: unknown\n  ): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>\n} = dual(2, <SA, SI, FA, FI, R>(\n  self: WithResult<SA, SI, FA, FI, R>,\n  value: unknown\n): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R> => decodeUnknown(exitSchema(self))(value))\n\n// ---------------------------------------------\n// SerializableWithResult\n// ---------------------------------------------\n\n/**\n * The `SerializableWithResult` trait is specifically designed to model remote\n * procedures that require serialization of their input and output, managing\n * both successful and failed outcomes.\n *\n * This trait combines functionality from both the `Serializable` and `WithResult`\n * traits to handle data serialization and the bifurcation of operation results\n * into success or failure categories.\n *\n * @since 3.10.0\n * @category model\n */\nexport interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}\n\n/**\n * @since 3.10.0\n * @category model\n */\nexport declare namespace SerializableWithResult {\n  /**\n   * @since 3.10.0\n   */\n  export type Context<P> = P extends\n    SerializableWithResult<infer _S, infer _SI, infer SR, infer _A, infer _AI, infer _E, infer _EI, infer RR> ? SR | RR\n    : never\n  /**\n   * @since 3.10.0\n   */\n  export type Any = SerializableWithResult<any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | SerializableWithResult<any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @since 3.10.0\n */\nexport const asSerializableWithResult = <SWR extends SerializableWithResult.All>(\n  procedure: SWR\n): SerializableWithResult<\n  Serializable.Type<SWR>,\n  Serializable.Encoded<SWR>,\n  Serializable.Context<SWR>,\n  WithResult.Success<SWR>,\n  WithResult.SuccessEncoded<SWR>,\n  WithResult.Failure<SWR>,\n  WithResult.FailureEncoded<SWR>,\n  WithResult.Context<SWR>\n> => procedure as any\n\n/**\n * @since 3.10.0\n */\nexport interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  ResultR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    ResultR\n  >\n{\n  readonly _tag: Tag\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TaggedRequest {\n  /**\n   * @since 3.10.0\n   */\n  export type Any = TaggedRequest<string, any, any, any, any, any, any, any, unknown>\n  /**\n   * @since 3.10.0\n   */\n  export type All =\n    | Any\n    | TaggedRequest<string, any, any, any, any, any, never, never, unknown>\n}\n\n/**\n * @category api interface\n * @since 3.10.0\n */\nexport interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Payload extends Struct.Fields,\n  Success extends Schema.All,\n  Failure extends Schema.All\n> extends\n  Class<\n    Self,\n    Payload,\n    Struct.Encoded<Payload>,\n    Struct.Context<Payload>,\n    Struct.Constructor<Omit<Payload, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Payload>,\n      Struct.Context<Payload>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n  readonly success: Success\n  readonly failure: Failure\n}\n\n/**\n * @category classes\n * @since 3.10.0\n */\nexport const TaggedRequest =\n  <Self = never>(identifier?: string) =>\n  <Tag extends string, Payload extends Struct.Fields, Success extends Schema.All, Failure extends Schema.All>(\n    tag: Tag,\n    options: {\n      failure: Failure\n      success: Success\n      payload: Payload\n    },\n    annotations?: Annotations.Schema<Self>\n  ): [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `>\n    : TaggedRequestClass<\n      Self,\n      Tag,\n      { readonly _tag: tag<Tag> } & Payload,\n      Success,\n      Failure\n    > =>\n  {\n    const taggedFields = extendFields({ _tag: getClassTag(tag) }, options.payload)\n    return class TaggedRequestClass extends makeClass({\n      kind: \"TaggedRequest\",\n      identifier: identifier ?? tag,\n      schema: Struct(taggedFields),\n      fields: taggedFields,\n      Base: Request.Class<any, any, { readonly _tag: string }>,\n      annotations\n    }) {\n      static _tag = tag\n      static success = options.success\n      static failure = options.failure\n      get [symbolSerializable]() {\n        return this.constructor\n      }\n      get [symbolWithResult]() {\n        return {\n          failure: options.failure,\n          success: options.success\n        }\n      }\n    } as any\n  }\n\n// -------------------------------------------------------------------------------------------------\n// Equivalence compiler\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.\n *\n * @category Equivalence\n * @since 3.10.0\n */\nexport const equivalence = <A, I, R>(schema: Schema<A, I, R>): Equivalence.Equivalence<A> => go(schema.ast, [])\n\nconst getEquivalenceAnnotation = AST.getAnnotation<AST.EquivalenceAnnotation<any, any>>(AST.EquivalenceAnnotationId)\n\nconst go = (ast: AST.AST, path: ReadonlyArray<PropertyKey>): Equivalence.Equivalence<any> => {\n  const hook = getEquivalenceAnnotation(ast)\n  if (option_.isSome(hook)) {\n    switch (ast._tag) {\n      case \"Declaration\":\n        return hook.value(...ast.typeParameters.map((tp) => go(tp, path)))\n      case \"Refinement\":\n        return hook.value(go(ast.from, path))\n      default:\n        return hook.value()\n    }\n  }\n  switch (ast._tag) {\n    case \"NeverKeyword\":\n      throw new Error(errors_.getEquivalenceUnsupportedErrorMessage(ast, path))\n    case \"Transformation\":\n      return go(ast.to, path)\n    case \"Declaration\":\n    case \"Literal\":\n    case \"StringKeyword\":\n    case \"TemplateLiteral\":\n    case \"UniqueSymbol\":\n    case \"SymbolKeyword\":\n    case \"UnknownKeyword\":\n    case \"AnyKeyword\":\n    case \"NumberKeyword\":\n    case \"BooleanKeyword\":\n    case \"BigIntKeyword\":\n    case \"UndefinedKeyword\":\n    case \"VoidKeyword\":\n    case \"Enums\":\n    case \"ObjectKeyword\":\n      return Equal.equals\n    case \"Refinement\":\n      return go(ast.from, path)\n    case \"Suspend\": {\n      const get = util_.memoizeThunk(() => go(ast.f(), path))\n      return (a, b) => get()(a, b)\n    }\n    case \"TupleType\": {\n      const elements = ast.elements.map((element, i) => go(element.type, path.concat(i)))\n      const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n      return Equivalence.make((a, b) => {\n        const len = a.length\n        if (len !== b.length) {\n          return false\n        }\n        // ---------------------------------------------\n        // handle elements\n        // ---------------------------------------------\n        let i = 0\n        for (; i < Math.min(len, ast.elements.length); i++) {\n          if (!elements[i](a[i], b[i])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle rest element\n        // ---------------------------------------------\n        if (array_.isNonEmptyReadonlyArray(rest)) {\n          const [head, ...tail] = rest\n          for (; i < len - tail.length; i++) {\n            if (!head(a[i], b[i])) {\n              return false\n            }\n          }\n          // ---------------------------------------------\n          // handle post rest elements\n          // ---------------------------------------------\n          for (let j = 0; j < tail.length; j++) {\n            i += j\n            if (!tail[j](a[i], b[i])) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"TypeLiteral\": {\n      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {\n        return Equal.equals\n      }\n      const propertySignatures = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n      const indexSignatures = ast.indexSignatures.map((is) => go(is.type, path))\n      return Equivalence.make((a, b) => {\n        const aStringKeys = Object.keys(a)\n        const aSymbolKeys = Object.getOwnPropertySymbols(a)\n        // ---------------------------------------------\n        // handle property signatures\n        // ---------------------------------------------\n        for (let i = 0; i < propertySignatures.length; i++) {\n          const ps = ast.propertySignatures[i]\n          const name = ps.name\n          const aHas = Object.prototype.hasOwnProperty.call(a, name)\n          const bHas = Object.prototype.hasOwnProperty.call(b, name)\n          if (ps.isOptional) {\n            if (aHas !== bHas) {\n              return false\n            }\n          }\n          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {\n            return false\n          }\n        }\n        // ---------------------------------------------\n        // handle index signatures\n        // ---------------------------------------------\n        let bSymbolKeys: Array<symbol> | undefined\n        let bStringKeys: Array<string> | undefined\n        for (let i = 0; i < indexSignatures.length; i++) {\n          const is = ast.indexSignatures[i]\n          const base = AST.getParameterBase(is.parameter)\n          const isSymbol = AST.isSymbolKeyword(base)\n          if (isSymbol) {\n            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b)\n            if (aSymbolKeys.length !== bSymbolKeys.length) {\n              return false\n            }\n          } else {\n            bStringKeys = bStringKeys || Object.keys(b)\n            if (aStringKeys.length !== bStringKeys.length) {\n              return false\n            }\n          }\n          const aKeys = isSymbol ? aSymbolKeys : aStringKeys\n          for (let j = 0; j < aKeys.length; j++) {\n            const key = aKeys[j]\n            if (\n              !Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])\n            ) {\n              return false\n            }\n          }\n        }\n        return true\n      })\n    }\n    case \"Union\": {\n      const searchTree = ParseResult.getSearchTree(ast.types, true)\n      const ownKeys = util_.ownKeys(searchTree.keys)\n      const len = ownKeys.length\n      return Equivalence.make((a, b) => {\n        let candidates: Array<AST.AST> = []\n        if (len > 0 && Predicate.isRecordOrArray(a)) {\n          for (let i = 0; i < len; i++) {\n            const name = ownKeys[i]\n            const buckets = searchTree.keys[name].buckets\n            if (Object.prototype.hasOwnProperty.call(a, name)) {\n              const literal = String(a[name])\n              if (Object.prototype.hasOwnProperty.call(buckets, literal)) {\n                candidates = candidates.concat(buckets[literal])\n              }\n            }\n          }\n        }\n        if (searchTree.otherwise.length > 0) {\n          candidates = candidates.concat(searchTree.otherwise)\n        }\n        const tuples = candidates.map((ast) => [go(ast, path), ParseResult.is({ ast } as any)] as const)\n        for (let i = 0; i < tuples.length; i++) {\n          const [equivalence, is] = tuples[i]\n          if (is(a) && is(b)) {\n            if (equivalence(a, b)) {\n              return true\n            }\n          }\n        }\n        return false\n      })\n    }\n  }\n}\n"],"names":["array_","bigDecimal_","bigInt_","boolean_","cause_","chunk_","config_","configError_","data_","dateTime","duration_","Effect","either_","Encoding","Equal","Equivalence","exit_","fastCheck_","fiberId_","dual","identity","globalValue","hashMap_","hashSet_","errors_","filters_","util_","list_","number_","option_","ParseResult","pipeArguments","Predicate","record_","redacted_","Request","AST","sortedSet_","string_","struct_","TypeId","Symbol","for","make","ast","SchemaClass","variance","Type","Encoded","Context","annotations","mergeSchemaAnnotations","pipe","arguments","toString","String","_A","_","_I","_R","builtInAnnotations","schemaId","SchemaIdAnnotationId","message","MessageAnnotationId","missingMessage","MissingMessageAnnotationId","identifier","IdentifierAnnotationId","title","TitleAnnotationId","description","DescriptionAnnotationId","examples","ExamplesAnnotationId","default","DefaultAnnotationId","documentation","DocumentationAnnotationId","jsonSchema","JSONSchemaAnnotationId","arbitrary","ArbitraryAnnotationId","pretty","PrettyAnnotationId","equivalence","EquivalenceAnnotationId","concurrency","ConcurrencyAnnotationId","batching","BatchingAnnotationId","parseIssueTitle","ParseIssueTitleAnnotationId","parseOptions","ParseOptionsAnnotationId","decodingFallback","DecodingFallbackAnnotationId","toASTAnnotations","out","key","id","asSchema","schema","format","encodedSchema","encodedAST","encodedBoundSchema","encodedBoundAST","typeSchema","typeAST","asserts","decodeOption","decodeSync","decodeUnknownOption","decodeUnknownSync","encodeOption","encodeSync","encodeUnknownOption","encodeUnknownSync","is","validateOption","validateSync","encodeUnknown","options","u","overrideOptions","mapError","parseError","encodeUnknownEither","mapLeft","encodeUnknownPromise","parser","runPromise","encode","encodeEither","encodePromise","decodeUnknown","decodeUnknownEither","decodeUnknownPromise","decode","decodeEither","decodePromise","validate","validateEither","validatePromise","isSchema","hasProperty","isObject","getDefaultLiteralAST","literals","isMembers","Union","mapMembers","literal","Literal","makeLiteralClass","LiteralClass","isNonEmptyReadonlyArray","Never","pickLiteral","_schema","UniqueSymbolFromSelf","symbol","UniqueSymbol","getDefaultEnumsAST","enums","Enums","Object","keys","filter","map","makeEnumsClass","EnumsClass","TemplateLiteral","head","tail","astOrs","getTemplateLiterals","getTemplateLiteralParameterAST","span","flatMap","a","b","combineTemplateLiterals","astOr","isString","spans","modifyNonEmptyLast","TemplateLiteralSpan","type","appendAll","_tag","types","Error","getSchemaUnsupportedLiteralSpanErrorMessage","TemplateLiteralParser","params","encodedSchemas","typeSchemas","numbers","i","length","p","encoded","isNumberKeyword","push","from","re","getTemplateLiteralCapturingRegExp","TemplateLiteralParserClass","transform","Tuple","strict","s","exec","slice","index","Number","tuple","join","declareConstructor","typeParameters","Declaration","tp","declarePrimitive","input","succeed","fail","declare","Array","isArray","BrandSchemaId","fromBrand","constructor","self","makeBrandClass","Refinement","predicate","either","isLeft","some","left","v","none","InstanceOfSchemaId","instanceOf","name","Undefined","undefinedKeyword","Void","voidKeyword","Null","null","neverKeyword","Unknown","unknownKeyword","Any","anyKeyword","BigIntFromSelf","bigIntKeyword","SymbolFromSelf","symbolKeyword","String$","stringKeyword","Number$","numberKeyword","Boolean$","booleanKeyword","Object$","objectKeyword","Boolean","getDefaultUnionAST","members","m","makeUnionClass","UnionClass","NullOr","UndefinedOr","NullishOr","keyof","element","ElementImpl","OptionalType","optionalElement","_Token","isOptional","getDefaultTupleTypeAST","elements","rest","TupleType","el","makeTupleTypeClass","TupleTypeClass","args","makeArrayClass","value","ArrayClass","Array$","makeNonEmptyArrayClass","NonEmptyArrayClass","NonEmptyArray","ArrayEnsure","value_","ArrayEnsureClass","ensure","arr","NonEmptyArrayEnsure","NonEmptyArrayEnsureClass","formatPropertySignatureToken","PropertySignatureDeclaration","isReadonly","defaultValue","token","FromPropertySignature","fromKey","ToPropertySignature","formatPropertyKey","undefined","JSON","stringify","PropertySignatureTransformation","to","mergeSignatureAnnotations","PropertySignatureTypeId","isPropertySignature","PropertySignatureImpl","_TypeToken","_Key","_EncodedToken","_HasDefault","makePropertySignature","PropertySignatureWithFromImpl","propertySignature","withConstructorDefault","applyDefaultValue","o","match","onNone","onSome","withDecodingDefault","withDefaults","defaults","decoding","optionalToRequired","requiredToOptional","optionalToOptional","optionalPropertySignatureAST","isExact","exact","isNullable","nullable","asOption","as","asOptionEncode","onNoneEncoding","orElse","OptionFromSelf","isNotNull","isNotUndefined","optional","optionalWith","getDefaultTypeLiteralAST","fields","records","ownKeys","pss","transformations","field","toAnnotations","PropertySignature","issFrom","issTo","r","indexSignatures","propertySignatures","record","forEach","ps","IndexSignature","parameter","Transformation","TypeLiteral","TypeLiteralTransformation","iss","lazilyMergeDefaults","makeTypeLiteralClass","TypeLiteralClass","props","propsWithDefaults","getDisableValidationMakeOption","pick","Struct","omit","tag","TaggedStruct","makeRecordClass","RecordClass","Record","pluck","getPropertyKeyIndexedAccess","orUndefined","ak","BrandClass","brand","annotation","getBrandAnnotation","brands","formatUnknown","BrandAnnotationId","partial","partialWith","required","mutable","intersectTypeLiterals","x","y","path","isTypeLiteral","findIndex","extendAST","concat","getSchemaExtendErrorMessage","preserveRefinementAnnotations","blackListAnnotations","addRefinementToMembers","refinement","asts","intersectUnionMembers","getTypes","isUnion","xs","ys","isStringKeyword","isNumber","isBoolean","isBooleanKeyword","isLiteral","isRefinement","Suspend","f","isTypeLiteralTransformation","transformation","propertySignatureTransformations","extend","that","compose","suspend","RefineSchemaId","makeRefineClass","RefineClass","fromFilterPredicateReturnTypeItem","item","issue","Pointer","toFilterParseIssue","isSingle","issues","filterMap","Composite","filterEffect","transformOrFail","filterReturnType","makeTransformationClass","TransformationClass","FinalTransformation","fromA","_options","_ast","toA","toI","transformLiteral","transformLiterals","pairs","attachPropertySignature","isSymbol","rename","mapping","TrimmedSchemaId","trimmed","trim","pattern","MaxLengthSchemaId","maxLength","MinLengthSchemaId","minLength","PatternSchemaId","regex","source","lastIndex","test","fc","stringMatching","StartsWithSchemaId","startsWith","EndsWithSchemaId","endsWith","IncludesSchemaId","includes","searchString","LowercasedSchemaId","lowercased","toLowerCase","Lowercased","CapitalizedSchemaId","capitalized","toUpperCase","Capitalized","UncapitalizedSchemaId","uncapitalized","Uncapitalized","UppercasedSchemaId","uppercased","Uppercased","LengthSchemaId","Math","max","floor","min","Char","nonEmptyString","Lowercase","Uppercase","Capitalize","capitalize","Uncapitalize","uncapitalize","Trimmed","NonEmptyTrimmedString","Trim","split","separator","JsonString","getParseJsonTransformation","try","parse","reviver","catch","e","replacer","space","ParseJsonSchemaId","parseJson","schemaOrOptions","NonEmptyString","UUIDSchemaId","uuidRegexp","UUID","uuid","ULIDSchemaId","ulidRegexp","ULID","ulid","FiniteSchemaId","finite","isFinite","GreaterThanSchemaId","greaterThan","exclusiveMinimum","GreaterThanOrEqualToSchemaId","greaterThanOrEqualTo","minimum","MultipleOfSchemaId","multipleOf","divisor","remainder","abs","IntSchemaId","int","isSafeInteger","LessThanSchemaId","lessThan","exclusiveMaximum","LessThanOrEqualToSchemaId","lessThanOrEqualTo","maximum","BetweenSchemaId","between","NonNaNSchemaId","nonNaN","isNaN","positive","negative","nonPositive","nonNegative","clamp","parseNumber","fromOption","n","NumberFromString","Finite","Int","NonNaN","Positive","Negative","NonPositive","NonNegative","JsonNumberSchemaId","JsonNumber","Not","not","Symbol$","sym","GreaterThanBigIntSchemaId","GreaterThanBigintSchemaId","greaterThanBigInt","GreaterThanOrEqualToBigIntSchemaId","greaterThanOrEqualToBigInt","LessThanBigIntSchemaId","lessThanBigInt","LessThanOrEqualToBigIntSchemaId","lessThanOrEqualToBigInt","BetweenBigIntSchemaId","BetweenBigintSchemaId","betweenBigInt","positiveBigInt","negativeBigInt","nonNegativeBigInt","nonPositiveBigInt","clampBigInt","BigInt$","fromString","BigInt","PositiveBigIntFromSelf","PositiveBigInt","NegativeBigIntFromSelf","NegativeBigInt","NonPositiveBigIntFromSelf","NonPositiveBigInt","NonNegativeBigIntFromSelf","NonNegativeBigInt","BigIntFromNumber","fromNumber","toNumber","redactedArbitrary","toComposite","eff","onSuccess","actual","mapBoth","onFailure","redactedParse","isRedacted","RedactedFromSelf","getEquivalence","Redacted","DurationFromSelf","isDuration","oneof","constant","infinity","bigUint","nanos","micros","maxSafeNat","millis","seconds","minutes","hours","days","weeks","DurationFromNanos","duration","toNanos","val","DurationFromMillis","ms","toMillis","hrTime","Duration","toHrTime","clampDuration","betweenDuration","LessThanDurationSchemaId","lessThanDuration","LessThanOrEqualToDurationSchemaId","lessThanOrEqualToDuration","GreaterThanDurationSchemaId","greaterThanDuration","GreaterThanOrEqualToDurationSchemaId","greaterThanOrEqualToDuration","BetweenDurationSchemaId","Uint8ArrayFromSelf","isUint8Array","u8arr","uint8Array","equals","Uint8Array$","Uint8Array","makeUint8ArrayTransformation","decodeException","Uint8ArrayFromBase64","decodeBase64","encodeBase64","Uint8ArrayFromBase64Url","decodeBase64Url","encodeBase64Url","Uint8ArrayFromHex","decodeHex","encodeHex","makeEncodingTransformation","StringFromBase64","decodeBase64String","StringFromBase64Url","decodeBase64UrlString","StringFromHex","decodeHexString","MinItemsSchemaId","minItems","getInvalidArgumentErrorMessage","StableFilterAnnotationId","MaxItemsSchemaId","maxItems","ItemsCountSchemaId","itemsCount","getNumberIndexedAccess","of","headOrElse","fallback","ValidDateSchemaId","validDate","getTime","LessThanDateSchemaId","lessThanDate","formatDate","LessThanOrEqualToDateSchemaId","lessThanOrEqualToDate","GreaterThanDateSchemaId","greaterThanDate","GreaterThanOrEqualToDateSchemaId","greaterThanOrEqualToDate","BetweenDateSchemaId","betweenDate","DateFromSelf","isDate","date","noInvalidDate","Date","ValidDateFromSelf","DateFromString","d","Date$","DateFromNumber","DateTimeUtcFromSelf","isDateTime","isUtc","unsafeFromDate","decodeDateTime","unsafeMake","DateTimeUtcFromNumber","dt","toEpochMillis","DateTimeUtc","formatIso","timeZoneOffsetArbitrary","integer","zoneMakeOffset","TimeZoneOffsetFromSelf","isTimeZoneOffset","zone","TimeZoneOffset","tz","offset","timeZoneNamedArbitrary","constantFrom","Intl","supportedValuesOf","zoneUnsafeMakeNamed","TimeZoneNamedFromSelf","isTimeZoneNamed","TimeZoneNamed","TimeZoneFromSelf","TimeZone","zoneFromString","zoneToString","timeZoneArbitrary","DateTimeZonedFromSelf","isZoned","chain","timeZone","unsafeMakeZoned","DateTimeZoned","makeZonedFromString","formatIsoZoned","OptionNoneEncoded","optionSomeEncoded","optionEncoded","optionDecode","optionArbitrary","ctx","optionPretty","optionParse","isOption","isNone","makeNoneEncoded","makeSomeEncoded","Option","OptionFromNullOr","fromNullable","getOrNull","OptionFromNullishOr","getOrUndefined","OptionFromUndefinedOr","OptionFromNonEmptyTrimmedString","getOrElse","rightEncoded","right","leftEncoded","eitherEncoded","eitherDecode","eitherArbitrary","eitherPretty","onLeft","onRight","eitherParse","parseRight","decodeUnknownLeft","isEither","EitherFromSelf","makeLeftEncoded","makeRightEncoded","Either","right_","left_","EitherFromUnion","toright","toleft","fromRight","fromLeft","l","mapArbitrary","items","array","depthIdentifier","Map","readonlyMapPretty","entries","k","readonlyMapEquivalence","arrayEquivalence","ka","va","kb","vb","readonlyMapParse","isMap","mapFromSelf_","Key","Value","ReadonlyMapFromSelf","MapFromSelf","ReadonlyMap","key_","ReadonlyMapFromRecord","fromEntries","MapFromRecord","setArbitrary","Set","readonlySetPretty","set","values","readonlySetEquivalence","readonlySetParse","isSet","setFromSelf_","ReadonlySetFromSelf","SetFromSelf","ReadonlySet","bigDecimalPretty","normalize","bigDecimalArbitrary","bigInt","scale","BigDecimalFromSelf","isBigDecimal","BigDecimal","num","BigDecimalFromNumber","unsafeToNumber","GreaterThanBigDecimalSchemaId","greaterThanBigDecimal","GreaterThanOrEqualToBigDecimalSchemaId","greaterThanOrEqualToBigDecimal","LessThanBigDecimalSchemaId","lessThanBigDecimal","LessThanOrEqualToBigDecimalSchemaId","lessThanOrEqualToBigDecimal","PositiveBigDecimalSchemaId","positiveBigDecimal","isPositive","PositiveBigDecimalFromSelf","NonNegativeBigDecimalSchemaId","nonNegativeBigDecimal","NonNegativeBigDecimalFromSelf","NegativeBigDecimalSchemaId","negativeBigDecimal","isNegative","NegativeBigDecimalFromSelf","NonPositiveBigDecimalSchemaId","nonPositiveBigDecimal","NonPositiveBigDecimalFromSelf","BetweenBigDecimalSchemaId","betweenBigDecimal","clampBigDecimal","chunkArbitrary","fromIterable","chunkPretty","c","toReadonlyArray","chunkParse","isChunk","isEmpty","empty","ChunkFromSelf","Chunk","nonEmptyChunkArbitrary","unsafeFromNonEmptyArray","nonEmptyChunkPretty","nonEmptyChunkParse","isNonEmpty","NonEmptyChunkFromSelf","NonEmptyChunk","toData","struct","dataArbitrary","dataPretty","dataParse","isEqual","DataFromSelf","Data","assign","isField","isFields","every","getFields","hasFields","getSchemaFromFieldsOr","fieldsOr","getFieldsFromFieldsOr","Class","makeClass","kind","Base","getClassTag","TaggedClass","newFields","taggedFields","extendFields","TaggedError","prototype","TaggedErrorClass","disableToString","getASTDuplicatePropertySignatureErrorMessage","orElseTitleAnnotation","getTitleAnnotation","disableValidation","classSymbol","validateSchema","encodedSide","typeSide","fallbackInstanceOf","klass","declaration","arb","SurrogateAnnotationId","newFieldsOr","newSchema","extendedFields","transformedFields","transformOrFailFrom","defineProperty","configurable","FiberIdNoneEncoded","FiberIdRuntimeEncoded","startTimeMillis","FiberIdCompositeEncoded","FiberIdEncoded","fiberIdArbitrary","letrec","tie","None","Runtime","FiberId","fiberIdDecode","fiberIdPretty","fiberId","FiberIdFromSelf","isFiberId","runtime","composite","fiberIdEncode","causeDieEncoded","defect","CauseEmptyEncoded","causeFailEncoded","error","CauseInterruptEncoded","causeParallelEncoded","causeEncoded","causeSequentialEncoded","recur","causeArbitrary","Empty","Fail","Die","Interrupt","Sequential","Parallel","Cause","causeDecode","causePretty","cause","causeParse","isCause","causeEncode","CauseFromSelf","die","interrupt","sequential","parallel","error_","defect_","Defect","err","stack","exitFailureEncoded","exitSuccessEncoded","exitEncoded","exitDecode","failCause","exitArbitrary","exitPretty","exit","exitParse","decodeUnknownValue","decodeUnknownCause","isExit","ExitFromSelf","failure","success","Exit","success_","failure_","hashSetArbitrary","hashSetPretty","hashSetEquivalence","hashSetParse","isHashSet","HashSetFromSelf","HashSet","hashMapArbitrary","hashMapPretty","hashMapEquivalence","hashMapParse","isHashMap","HashMapFromSelf","HashMap","listArbitrary","listPretty","listEquivalence","listParse","isList","ListFromSelf","List","sortedSetArbitrary","ord","sortedSetPretty","sortedSetParse","isSortedSet","SortedSetFromSelf","ordA","ordI","SortedSet","BooleanFromUnknown","isTruthy","Config","decodeEither_","string","mapOrFail","InvalidData","TreeFormatter","formatErrorSync","symbolSerializable","asSerializable","serializable","serializableSchema","serialize","deserialize","symbolWithResult","asWithResult","withExit","failureSchema","successSchema","exitSchemaCache","WeakMap","exitSchema","proto","getPrototypeOf","get","serializeFailure","deserializeFailure","serializeSuccess","deserializeSuccess","serializeExit","deserializeExit","asSerializableWithResult","procedure","TaggedRequest","payload","TaggedRequestClass","go","getEquivalenceAnnotation","getAnnotation","hook","isSome","getEquivalenceUnsupportedErrorMessage","memoizeThunk","annotatedAST","len","j","aStringKeys","aSymbolKeys","getOwnPropertySymbols","aHas","hasOwnProperty","call","bHas","bSymbolKeys","bStringKeys","base","getParameterBase","isSymbolKeyword","aKeys","searchTree","getSearchTree","candidates","isRecordOrArray","buckets","otherwise","tuples"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}